<HTML>
  <HEAD>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <TITLE>i5/OS Programmer's Toolkit - MI/EMI Programmer's Guide</TITLE>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="doxygen.css" rel="stylesheet" type="text/css">
    <link href="docs.css" rel="stylesheet" type="text/css">

    <table width="100%" border="0" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left">
          <a href="http://sourceforge.net/donate/index.php?group_id=254578"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> </a>
        </td>
        <td align="right">
          <a href="http://sourceforge.net/projects/i5toolkit"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=254578&amp;type=13" width="120" height="30" alt="Get i5/OS Programmer's Toolkit at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a>
        </td>

      </tr>
    </table>

  </HEAD>
  <body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Space Object Tools</h1>
<p>
<h3 align="center">0.2.16 </h3>Go back to <a href="../index.html">main page</a> of i5/OS Programmer's Toolkit.<h2><a class="anchor" name="s_spc_intro">
Introduction to Space Object Tools</a></h2>
Space Object Tools is a subproject of <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>. This subproject is designed to help IBM i programmers to operate space objects more conveniently. As you know, IBM provides neither CL command to allow users to display or modify the attributes of a space object interactively, nor CL command to change the content of a space object interactively. This is why the subproject is designed.<p>
Tools and how-tos about space objects provided by this subproject include:<ul>
<li><a class="el" href="page_chgusrspc.html">The Change User Space (CHGUSRSPC) Command</a></li><li><a class="el" href="index.html#s_spc_mi_spc">MI Space Objects</a></li><li><a class="el" href="index.html#s_spc_mats">How to Retrieve Space Attributes of an MI Space Object</a><ul>
<li><a class="el" href="index.html#ss_spc_mats_dmp_cmd">Retrieve Space Attributes of an MI Space Object via the DMPOBJ or DMPSYSOBJ Commands</a></li><li><a class="el" href="index.html#ss_spc_mats_mi_way">Retrieve Space Attributes of an MI Space Object via the MATS Instruction</a></li></ul>
</li><li><a class="el" href="index.html#s_spc_ptr">How to Recognize Pointers in the Content of a Space Object</a></li></ul>
<h2><a class="anchor" name="s_spc_mi_spc">
MI Space Objects</a></h2>
The MI object type code of an MI space object is hex 19. On IBM i, many types of external objects are MI space objects. For example, a *FILE object is an MI space object with type code and subtype code hex 1901. The following simple CL program can help you discover the relationship between MI space objects with different subtype code and corresponding external objects, <a href="https://i5toolkit.svn.sourceforge.net/svnroot/i5toolkit/cl/cl007.clp">cl007.clp</a>. <div class="fragment"><pre class="fragment">             PGM
             DCL        VAR(&amp;OPT) TYPE(*CHAR) LEN(10) +
                          VALUE('*HEXTOSYM')
             DCL        VAR(&amp;EXTYP) TYPE(*CHAR) LEN(10)
             DCL        VAR(&amp;MITYP) TYPE(*UINT) LEN(2) VALUE(X'1900')
             DCL        VAR(&amp;EC) TYPE(*CHAR) LEN(16)
             DCL        VAR(&amp;ECLEN) TYPE(*UINT) STG(*DEFINED) LEN(4) +
                          DEFVAR(&amp;EC)
             DCL        VAR(&amp;ECRTN) TYPE(*UINT) STG(*DEFINED) LEN(4) +
                          DEFVAR(&amp;EC 5)
             DCL        VAR(&amp;MSG) TYPE(*CHAR) LEN(16)
             DCL        VAR(&amp;NIBLEN) TYPE(*UINT) LEN(4) VALUE(4)

             CHGVAR     VAR(&amp;ECLEN) VALUE(16)
 LOOP:       CHGVAR     VAR(&amp;MITYP) VALUE(&amp;MITYP + 1)
             IF         COND(&amp;MITYP *GT 6655) THEN(GOTO +
                          CMDLBL(SEEYOU)) <span class="comment">/* when &amp;MITYP &gt; x'19FF' */</span>
             CALL       PGM(QLICVTTP) PARM(&amp;OPT &amp;EXTYP &amp;MITYP &amp;EC) +
                          <span class="comment">/* Convert MI object type code to +</span>
<span class="comment">                          external object type name */</span>
             IF         COND(&amp;ECRTN *NE 0) THEN(GOTO CMDLBL(LOOP))
             CALL       PGM(CVTHC) PARM(&amp;MSG &amp;MITYP &amp;NIBLEN)
             CHGVAR     VAR(%SST(&amp;MSG 7 10)) VALUE(&amp;EXTYP)
             SNDPGMMSG  MSG(&amp;MSG)
             GOTO       CMDLBL(LOOP)

 SEEYOU:     ENDPGM
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a href="rpg/page_tool_misc.html#s_tool_misc_cvthc">CVTHC</a> is an OPM MI program that converts each hex digit (4-bit value) in the source character string to a character (8-bit value) in the receiver character string.</dd></dl>
Call CL007, the output is the following: <div class="fragment"><pre class="fragment">1901  *FILE  
1902  *MSGQ  
1903  *JOBD  
1904  *CLS   
1905  *CMD   
1906  *TBL   
1907  *PRTIMG
1908  *EDTD  
1909  *SBSD  
190A  *DTAARA
190B  *CLD   
190C  *GSS   
190D  *CHTFMT
190E  *DOC   
190F  *DOCL  
1910  *IGCTBL
1911  *QRYDFN
1912  *FLR   
1913  *EXITRG
1914  *NTBD  
1915  *PNLGRP
1916  *MENU  
1917  *SVRSTG
1918  *CFGLO 
1919  *S36   
191A  *IGCSRT
191B  *PRDDFN
191C  *MEDDFN
191D  *PRDLOD
191E  *IPXD  
191F  *SQLUDT
1920  *DTADCT
1921  *LOCALE
1922  *CSPMAP
1923  *CSPTBL
1924  *M36CFG
1925  *PSFCFG
1926  *FNTRSC
1927  *PAGSEG
1928  *FORMDF
1929  *OVL   
192A  *NODGRP
192B  *FNTTBL
192C  *CRG   
192D  *MGTCOL
192E  *IMGCLG
192F  *TIMZON
1930  *PDG   
1931  *QMQRY 
1932  *QMFORM
1933  *PRDAVL
1934  *USRSPC
1935  *CSI   
1936  *PAGDFN
1937  *BNDDIR
1938  *WSCST 
1939  *NWSCFG
</pre></div><h2><a class="anchor" name="s_spc_mats">
How to Retrieve Space Attributes of an MI Space Object</a></h2>
To retrieve space attributes of an MI space object, you can either issue the DMPOBJ or DMPSYSOBJ commands directly on an MI space object, or use the MATS (Materialize Space Attributes) instruction in an OPM MI or ILE program.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The DMPXXX commands are really very handy when being used to check object attributes or the content or an MI object, but using them requires the *ALLOBJ special authority.</dd></dl>
<h3><a class="anchor" name="ss_spc_mats_dmp_cmd">
Retrieve Space Attributes of an MI Space Object via the DMPOBJ or DMPSYSOBJ Commands</a></h3>
To retrieve space attributes of an MI space object, you can issue the the DMPOBJ or DMPSYSOBJ commands directly on it, and then check the <em>SPACE ATTRIBUTES</em> section in the result spooled file. The format of the 116-byte <em>SPACE ATTRIBUTES</em> section is exactly the same with the instruction template of <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATS.htm">MATS</a>. This instruction template is defined as mats_tmpl_t in <a href="https://i5toolkit.svn.sourceforge.net/svnroot/i5toolkit/rpg/mih-spc.rpgleinc">mih-spc.rpgleinc</a> and mats-tmpl-t in <a href="https://i5toolkit.svn.sourceforge.net/svnroot/i5toolkit/cobol/mih-spc.cblleinc">mih-spc.cblleinc</a>.<p>
From section <a class="el" href="index.html#s_spc_mi_spc">MI Space Objects</a>, you can see that an external object of type *FILE or *SBSD (Subsystem Description) is an MI space object. The MI object type code and subtype code for a *FILE or *SBSD object is hex 1901 and hex 1909 respectively. Say that you have a *FILE object <em>AUG0B</em> and a *SBSD object <em>OCT</em> in a library called <em>SOMELIB</em>. You can dump them like the following: <div class="fragment"><pre class="fragment"><span class="comment">/* Dump file object SOMELIB/AUG0B */</span>
DMPOBJ OBJ(SOMELIB/AUG0B) OBJTYPE(*FILE)
<span class="comment">/* or */</span>
DMPSYSOBJ OBJ(AUG0B) CONTEXT(SOMELIB) TYPE(19) SUBTYPE(01)

<span class="comment">/* Dump *SBSD object SOMELIB/OCT */</span>
DMPOBJ OBJ(SOMELIB/OCT) OBJTYPE(*SBSD)
<span class="comment">/* or */</span>
DMPSYSOBJ OBJ(OCT) CONTEXT(SOMELIB) TYPE(19) SUBTYPE(09)
</pre></div><p>
The 116-byte <em>SPACE ATTRIBUTES</em> sections of them might like the following:<ul>
<li>*FILE SOMBLIB/AUG0B <pre>
 SPACE ATTRIBUTES-
   000000   00FFF000 00000074 1901C1E4 C7F0C240   40404040 40404040 40404040 40404040  *  0      AUG0B                 *
   000020   40404040 40404040 E0060000 00000000   00001000 00100000 00000000 00000000  *        $                       *
   000040   00000000 00000000 01111305 F1000400   00000000 00000000 00000000 00000000  *            1                   *
   000060   00000000 00000000 00000000 00000000   00FFF000                             *                  0             *
</pre></li><li>*SBSD SOMBLIB/OCT <pre>
 SPACE ATTRIBUTES-
   000000   00FFF000 00000074 1909D6C3 E3404040   40404040 40404040 40404040 40404040  *  0      OCT                   *
   000020   40404040 40404040 A0000000 00000000   00001000 00110000 00000000 00000000  *        ~                       *
   000040   00000000 00000000 01111305 F1000400   00000000 00000000 00000000 00000000  *            1                   *
   000060   00000000 00000000 00000000 00000000   00001000                             *                                *
</pre></li></ul>
<p>
According to documentation on the instruction template of MATS, you can find out the space attributes of these two space objects. <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td rowspan="2">Offset (Hex) </td><td rowspan="2">Field </td><td colspan="2">*FILE SOMBLIB/AUG0B </td><td colspan="2">*SBSD SOMBLIB/OCT <p>
</td></tr>
<tr bgcolor="silver">
<td>Value </td><td>Meaning </td><td>Value </td><td>Meaning <p>
</td></tr>
<tr>
<td>0 </td><td>Bin(4). Number of bytes provided for materialization </td><td>hex 00FFF000 </td><td>- </td><td>hex 00FFF000 </td><td>- <p>
</td></tr>
<tr>
<td>4 </td><td>Bin(4). Number of bytes available for materialization  </td><td>hex 00000074 </td><td>116 bytes </td><td>hex 00000074 </td><td>116 bytes <p>
</td></tr>
<tr>
<td>8 </td><td>Char(32). Object identification </td><td>hex 1901C1E4..4040 </td><td>MI object type is hex 1901. Object name is 'AUG0B'. </td><td>hex 1909D6C3..4040 </td><td>MI object type is hex 1909. Object name is 'OCT'. <p>
</td></tr>
<tr>
<td>28 </td><td>Char(4). Object creation options </td><td>hex E0060000 </td><td><ul>
<li>bit 0 = 1. Object is permanent</li><li>bit 1 = 1. Space is variable-length</li><li>bit 2 = 1. Addressability in context</li><li>bit 13 = 1. Do not initialize space</li><li>bit 14 = 1. Automatically extend space  </li></ul>
</td><td>hex A0000000 </td><td><ul>
<li>bit 0 = 1. Object is permanent</li><li>bit 1 = 0. Space is fixed-length</li><li>bit 2 = 1. Addressability in context</li><li>bit 13 = 0. Initialize space</li><li>bit 14 = 0. Do NOT automatically extend space  </li></ul>
<p>
</td></tr>
<tr>
<td>2E </td><td>Char(2). ASP number </td><td>hex 0000 </td><td>Space object is allocate in the system ASP </td><td>hex 0000 </td><td>Space object is allocate in the system ASP <p>
</td></tr>
<tr>
<td>30 </td><td>Bin(4). Size of space </td><td>hex 00001000 </td><td>4096 bytes </td><td>hex 00001000 </td><td>4096 bytes <p>
</td></tr>
<tr>
<td>34 </td><td>Char(1). Initial value of space </td><td>hex 00 </td><td>- </td><td>hex 00 </td><td>- <p>
</td></tr>
<tr>
<td>35 </td><td>Char(4). Performance class </td><td>hex 10000000Performance class </td><td><ul>
<li>Bit 3 = 1. Machine chooses space alignment. The alignment chosen is a multiple of 512.  </li></ul>
</td><td>hex 10000000Performance class </td><td><ul>
<li>Bit 3 = 1. Machine chooses space alignment. The alignment chosen is a multiple of 512.</li><li>Bit 7 = 1. <em>Obsolete. This field is no longer used and will be ignored.</em> Oops!  </li></ul>
<p>
</td></tr>
<tr>
<td>38 </td><td>Char(1). Expanded transfer size advisory. [1]  </td><td>hex 00 </td><td>- </td><td>hex 00 </td><td>- <p>
</td></tr>
<tr>
<td>40 </td><td>System pointer to the context object </td><td>hex 00000000 00000000 01111305 F1000400 </td><td>[2] </td><td>hex 00000000 00000000 01111305 F1000400 </td><td>[2] <p>
</td></tr>
<tr>
<td>50 </td><td>System pointer to the access group object </td><td>hex 00..00 </td><td>Pointer not set </td><td>hex 00..00 </td><td>Pointer not set <p>
</td></tr>
<tr>
<td>70 </td><td>Bin(4). Maximum size of space </td><td>hex 00FFF000 </td><td>16773120 bytes (16M - 1 Page). 1 page is 4K. </td><td>hex 00001000 </td><td>4096 bytes <p>
</td></tr>
</table>
<p>
<b>Notes</b><ul>
<li>[1] The <em>expanded transfer size advisory</em> specifies the desired number of pages to be transferred between main store and auxiliary storage for implicit access state changes. This value is only an advisory; the machine may use a value of its choice for performing access state changes under some circumstances. For example, the machine may limit the transfer size to a smaller value than is specified. A value of zero is an explicit indication that the machine should use the machine default storage transfer size for this object.</li><li>[2] Byte 14 of a system pointer is the MI object type code of the MI object pointed to by the system pointer. Here, a value of hex 04 of byte 14 means this is a system pointer to a context (library) object.</li></ul>
<h3><a class="anchor" name="ss_spc_mats_mi_way">
Retrieve Space Attributes of an MI Space Object via the MATS Instruction</a></h3>
To retrieve space attributes of an MI space object in the MI way, use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATS.htm">MATS</a> instruction. You can either use the MATS instruction in an OPM MI program, or in an ILE HLL program via the bound program access interface of it, _MATS.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Although there is an API called Retrieve User Space Attributes (QUSRUSAT), it cares about only one of all types of MI space object, the *USRSPC objects (with MI object type code and subtype code hex 1934). Furthermore, it returns only the space size, automatic extendibility, and intitial value attributes of a *USRSPC.</dd></dl>
Here's an example ILE COBOL program that analyzes the create-option attributes of a *USRSPC object retrieved using the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATS.htm">MATS</a> instruction, <a href="https://i5toolkit.svn.sourceforge.net/svnroot/i5toolkit/cobol/test/cbl015.cblle">cbl015.cblle</a>, and then prints the result of analyzation to printer file QSYSPRT.<p>
<pre>
       process
           NOSTDTRUNC
           NOMONOPRC.</pre><p>
<pre>       id division.
       program-id. cbl015.</pre><p>
<pre>       environment division.
       configuration section.
       special-names.
           copy mih-lnktyp.</pre><p>
<pre>       input-output section.
       file-control.
           select spcattr-report assign to printer-QSYSPRT.</pre><p>
<pre>       data division.
       file section.
       fd spcattr-report.
       01 report-rec.
          05 attr-name  pic x(28).
          05 filler     pic x(2).
          05 attr-value pic x(50).</pre><p>
<pre>       working-storage section.
           copy mih-comp.
           copy mih-spc.
           copy mih-ptr.</pre><p>
<pre>       01 r-tmpl type rslvsp-tmpl-t.
       01 usrspc usage pointer.
       01 spc-attr type mats-tmpl-t.
       01 offset pic 9(9) usage comp-4.
       01 flag   pic 9(9) usage comp-4.
       01 mask     pic x(4) value x"01800000".
       01 str-flag pic x(4).</pre><p>
<pre>       linkage section.
       77 usrspc-name pic x(10).</pre><p>
<pre>       procedure division using usrspc-name.
       main-program.</pre><p>
<pre>       resolve-syp.
           move all x"00" to r-tmpl.
           move x"1934" to obj-type of r-tmpl.
           move usrspc-name to obj-name of r-tmpl.
           call "_RSLVSP2" using
                by reference usrspc
                by reference r-tmpl.</pre><p>
<pre>           move length of mats-tmpl-t to bytes-in of spc-attr.
           call "_MATS" using
                by reference spc-attr
                by reference usrspc.</pre><p>
<pre>       generate-report.
           open output spcattr-report.
           move "Attribute Name" to attr-name.
           move "Attribute Value" to attr-value.
           write report-rec.
           move "---------------" to attr-name.
           move "----------------" to attr-value.
           write report-rec.</pre><p>
<pre>           move 0 to offset.
           call "_TSTBTS" using
                by reference   crt-opt of spc-attr
                by value       offset
                returning into flag.
           if flag is equal to 1
              then
              move "Permanent" to attr-value
           else
              move "Temporary" to attr-value
           end-if.
           move "Existence attribute" to attr-name.
           write report-rec.</pre><p>
<pre>           move 1 to offset.
           call "_TSTBTS" using
                by reference   crt-opt of spc-attr
                by value       offset
                returning into flag.
           if flag is equal to 1
              then
              move "Variable-length" to attr-value
           else
              move "Fixed-length" to attr-value
           end-if.
           move "Space attribute" to attr-name.
           write report-rec.</pre><p>
<pre>           move 2 to offset.
           call "_TSTBTS" using
                by reference   crt-opt of spc-attr
                by value       offset
                returning into flag.
           if flag is equal to 1
              then
              move "Addressability in context" to attr-value
           else
              move "Addressability not in context" to attr-value
           end-if.
           move "Context" to attr-name.
           write report-rec.</pre><p>
<pre>           move 13 to offset.
           call "_TSTBTS" using
                by reference   crt-opt of spc-attr
                by value       offset
                returning into flag.
           if flag is equal to 1
              then
              move "Do not initialize" to attr-value
           else
              move "Initialize" to attr-value
           end-if.
           move "Initialize space" to attr-name.
           write report-rec.</pre><p>
<pre>           move 14 to offset.
           call "_TSTBTS" using
                by reference   crt-opt of spc-attr
                by value       offset
                returning into flag.
           if flag is equal to 1
              then
              move "Yes" to attr-value
           else
              move "No" to attr-value
           end-if.
           move "Automatically extend space" to attr-name.
           write report-rec.</pre><p>
<pre>       Bits_15-16.
           call "_ANDSTR" using
                by reference str-flag
                by reference crt-opt of spc-attr
                by reference mask
                by value     4.
           evaluate str-flag
               when x"00000000"
                    move "Reference and modify allowed for user state PGMs"
                         to attr-value
               when x"00800000"
                    move "Only reference allowed for user state programs"
                         to attr-value
               when x"01000000"
                    move "A value hex 10 is invalid for bits 15-16"
                         to attr-value
               when x"01800000"
                    move "No reference or modify allowed for user state PGMs"
                         to attr-value
           end-evaluate.
           move "Hardware storage protection" to attr-name.
           write report-rec.</pre><p>
<pre>           move 21 to offset.
           call "_TSTBTS" using
                by reference   crt-opt of spc-attr
                by value       offset
                returning into flag.
           if flag is equal to 1
              then
              move "At all times"
                   to attr-value
           else
              move "When hardware protection is enforced for all STG"
                   to attr-value
           end-if.
           move "Enforce hardware protection" to attr-name.
           write report-rec.</pre><p>
<pre>       see-you.
           stop run.
       end program cbl015.
</pre><p>
Call CBL015 like the following (CBL014 is a *USRSPC object): <div class="fragment"><pre class="fragment">CALL CBL015 CBL014
</pre></div><p>
The output of CBL015 might be like the following: <pre>
Attribute Name                Attribute Value                                 
---------------               ----------------
Existence attribute           Permanent                                       
Space attribute               Variable-length                                 
Context                       Addressability in context                       
Initialize space              Initialize                                      
Automatically extend space    Yes                                             
Hardware storage protection   Reference and modify allowed for user state PG  
Enforce hardware protection   When hardware protection is enforced for all STG
</pre><h2><a class="anchor" name="s_spc_ptr">
How to Recognize Pointers in the Content of a Space Object</a></h2>
The answer lies in the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATPTRL.htm">Materialize Pointer Locations (MATPTRL) </a> instruction. The instruction template for it in ILE RPG and ILE COBOL and its system-builtin prototype in ILE RPG can be found in <a href="https://i5toolkit.svn.sourceforge.net/svnroot/i5toolkit/rpg/mih-ptr.rpgleinc">mih-ptr.rpgleinc</a> and <a href="https://i5toolkit.svn.sourceforge.net/svnroot/i5toolkit/cobol/mih-ptr.cblleinc">mih-ptr.cblleinc</a> respectively. IBM's documentation on the MATPTRL instruction is <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATPTRL.htm">here</a>.<p>
Now follow the simple demonstration steps showed bellow to see how to find out pointers in the content of a space object via the MATPTRL instruction.<ul>
<li>Create an MI space object. For simplicity, here we create a *USRSPC object by calling the QUSCRTUS API. <div class="fragment"><pre class="fragment"><span class="comment">/* Create a *USRSPC called U_POINTERS in the current library */</span>
CALL PGM(QUSCRTUS)
     PARM('U_POINTERS*CURLIB'
          'MAY'                 <span class="comment">/* Attribute */</span>
          X'00000200'           <span class="comment">/* Space size */</span>
          X'00'                 <span class="comment">/* Initial value */</span>
          '*CHANGE'             <span class="comment">/* Public authority */</span>
          'Recognize PTRs')     <span class="comment">/* Text */</span>
</pre></div></li><li>Write some scalar data and pointer data into the created space using the <a class="el" href="page_chgusrspc.html">The Change User Space (CHGUSRSPC) Command</a>. <div class="fragment"><pre class="fragment">CHGUSRSPC USRSPC(*LIBL/U_POINTERS)
          OFFSET(0)
          DTA('Lyrics: Why do birds suddenly')
          DTALEN(*CALC)
<span class="comment">/* Write the system pointer to *CMD CHGUSRSPC itself into the space object */</span>
CHGUSRSPC USRSPC(*LIBL/U_POINTERS)
          OFFSET(32)
          DTATYPE(*PTR)
          PTRTYPE(*SYP)
          SYSOBJ(*LIBL/CHGUSRSPC)
          OBJTYPE(*CMD)
</pre></div></li><li>Check what's in the space object now by dumping the space object. e.g. DMPOBJ OBJ(U_POINTERS) OBJTYPE(*USRSPC). The content of *USRSPC is the following. Note that the dump result indicates that there is a system pointer at offset hex 20 of the content of the space object U_POINTERS. <pre>
 SPACE-
   000000   D3A89989 83A27A40 E688A840 84964082   899984A2 40A2A484 84859593 A80F0000  *Lyrics: Why do birds suddenly   *
   000020   00000000 00000000 2D26C48D D3001900   00000000 00000000 00000000 00000000  *          DL                   *
   000040   00000000 00000000 00000000 00000000   00000000 00000000 00000000 00000000  *                                *
         LINES  000060    TO    000DFF  SAME AS ABOVE
 .POINTERS-
   000020   SYP 19 05 CHGUSRSPC                       04 01 I5TOOLKIT                       0000  0000  *CMD
</pre></li><li>Find pointer locations in the content of U_POINTERS using the MATPTRL instruction. The following is an ILE COBOL example, <a href="https://i5toolkit.svn.sourceforge.net/svnroot/i5toolkit/cobol/test/cbl016.cblle">cbl016.cblle</a>. <pre></pre></li></ul>
<p>
<pre>       process
           NOSTDTRUNC
           NOMONOPRC.</pre><p>
<pre>       id division.
       program-id. cbl016.</pre><p>
<pre>       environment division.
       configuration section.
       special-names.
           copy mih-lnktyp.</pre><p>
<pre>       data division.
       working-storage section.</pre><p>
<pre>       01 r-tmpl     type rslvsp-tmpl-t.
       01 spc-obj    usage pointer.
       01 spp-ptr    usage pointer.
 Size of *USRSPC U_POINTERS is 512 bytes
       01 dta-len    pic 9(9) usage comp-4 value 512.
       01 test-tmpl  type matptrl-tmpl-t.
       01 bitmap-len pic 9(9) usage comp-4.
       01 i          pic 9(9) usage comp-4.
       01 bit-flag   pic 9(9) usage comp-4.
       01 ptr-pos    pic 9(9) usage comp-4.</pre><p>
<pre>       linkage section.
           copy mih-ptr.</pre><p>
<pre>       procedure division.
       main.
           move all x"00" to r-tmpl.
           move x"1934" to obj-type of r-tmpl.
           move "U_POINTERS" to obj-name of r-tmpl.
           call "_RSLVSP2" using
                by reference spc-obj
                by reference r-tmpl.</pre><p>
<pre>           call "_SETSPPFP" using
                by value       spc-obj
                returning into spp-ptr.</pre><p>
<pre>           move all x"00" to test-tmpl.
           move length of test-tmpl to bytes-in of test-tmpl.
           call "_MATPTRL" using
                by reference test-tmpl
                by value     spp-ptr
                by reference dta-len.</pre><p>
<pre> set bitmap-len to number of bits to returned by MATPTRL
           compute bitmap-len = (bytes-out of test-tmpl - 8) * 8.
           perform test-for-ptr
                   test before
                   varying i from 0 by 1
                   until   i &gt;= bitmap-len.</pre><p>
<pre>       see-you.
           stop run.</pre><p>
<pre>       test-for-ptr.
           call "_TSTBTS" using
                by reference   bitmap of test-tmpl
                by value       i
                returning into bit-flag.
           if bit-flag is equal to 1
              then
              compute ptr-pos = i * 16
              display "Pointer detected at offset: "
                      ptr-pos
           end-if.</pre><p>
<pre>       end program cbl016.
</pre><ul>
<li>Call CBL016 to find out pointers within the content of U_POINTERS. The result output is the following. The only pointer (system pointer to the CHGUSRSPC command) is detected at offset 32 in the space object. <div class="fragment"><pre class="fragment">Pointer detected at offset: 0000000032
</pre></div> </li></ul>
</div>
<hr size="1">

<a href="http://sourceforge.net/donate/index.php?group_id=254578"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> </a>

<address style="text-align: right;"><small>Generated on Tue May 10 19:55:09 2011 for i5/OS Programmer's Toolkit: Space Object Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9  </small></address>
</body>
</html>
