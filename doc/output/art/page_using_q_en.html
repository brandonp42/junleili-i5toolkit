<HTML>
  <HEAD>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <TITLE>i5/OS Programmer's Toolkit - MI/EMI Programmer's Guide</TITLE>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="doxygen.css" rel="stylesheet" type="text/css">
    <link href="docs.css" rel="stylesheet" type="text/css">

    <table width="100%" border="0" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left">
          <a href="http://sourceforge.net/donate/index.php?group_id=254578"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> </a>
        </td>
        <td align="right">
          <a href="http://sourceforge.net/projects/i5toolkit"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=254578&amp;type=13" width="120" height="30" alt="Get i5/OS Programmer's Toolkit at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a>
        </td>

      </tr>
    </table>

  </HEAD>
  <body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="page_using_q_en">Using Queue Objects on i5/OS </a></h1><dl class="version" compact><dt><b>Version:</b></dt><dd>0.1 </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>2009-06-20 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Junlei Li</dd></dl>
Queue object is a native IPC method on i5/OS. Among all IPC methods available on i5/OS, queue object is the most often used, easy to use, and flexible one. Here we make an introduction to the most important attributes of queue objects and various operations on queue objects. Also, several interesting and useful demo applications are provided here:<ul>
<li><a href="page_using_q_en.html#en_ss_using_q_appendix_5">Joblog Saver Program</a><br>
 A batch program which saves newly generated spooled files on output queue QEZJOBLOG to a physical file, and then deletes the spooled file. See <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_outputq">6.2. Data Queue Support on Output Queues</a> 及 <a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a>.</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority">6.3. Implement Priority-based IPC by Keyed Queue Objects</a></li><li>ISQL/RUNSQL<br>
 CL commands to run SQL statements interatively or in a CL program or a REXX script. Command RUNSQL returns the SQL code of the SQL statement being executed, by which a CL program or a REXX script can determine the following proram logic such as commit or rollback. See <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync">6.4. Simulate Synchronous Calls by i5/OS Queue Objects</a>.</li><li>ISQL2/RUNSQL2<br>
 An enhanced version of ISQL/RUNSQL, which eliminates the limitation on the length of the SQL statement. See <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer">6.5. Pass Variable Length Data through i5/OS Queue Objects</a>.</li><li>Java version ISQL<br>
 Demonstates how to communicate with host language programs by user queue objects in java. See <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java">6.6. Java and i5/OS Queue objects</a>.</li></ul>
<p>
<b>Contents</b><ul>
<li><a class="el" href="page_using_q_en.html#en_sect_using_q_shuyu">1. Terms and Abbreviations</a></li><li><a class="el" href="page_using_q_en.html#en_sect_using_q_intro">2. An Introduction to Queue Objects on i5/OS</a></li><li><a class="el" href="page_using_q_en.html#en_sect_using_q_diffs">3. Difference between DTAQ and USRQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_domain">3.1. Object Domain</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_journal">3.2. Whether the Queue can be Journaled</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_operation">3.3. Operation Interfaces</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_weight">3.4. Operation Efficiency</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_senderid">3.5. DTAQ Messages can Include Sender's Information</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_sect_using_q_dtaq_howtos">4. Data Queue Operation Examples</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt">4.1. Create a DTAQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_1">4.1.1. Create a DTAQ of type FIFO or LIFO</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_2">4.1.2. Create a Keyed DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_3">4.1.3. Create a DTAQ Supports Sender's ID</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_4">4.1.4. Parameter MAXLEN(Maximum entry length) of CL command CRTDTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_5">4.1.5. Parameter SIZE of CL Command CRTDTAQ</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_dlt">4.2. Delete a DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq">4.3. Enqueue Messages to a DTAQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq_1">4.3.1. Enqueue messages to a FIFO/LIFO DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq_2">4.3.2. Enqueue Messages to a Keyed DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq_3">4.3.3. Enqueue Messages to a Keyed DTAQ (in ILE RPG)</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq">4.4. Dequeue Messages from a DTAQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq_1">4.4.1. Dequeue Messages from a FIFO/LIFO DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq_2">4.4.2. Dequeue Messages from a Keyed DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq_3">4.4.3. Dequeue Messages from a Keyed DTAQ without Removal of the Mequeued Messages</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_clr">4.5. Clear Messages on a DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_matqat">4.6. Retrieve Attributes of a DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_matmsg">4.7. Retrieve Messages from a DTAQ without Removing them</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_sect_using_q_usrq_howtos">5. User Queue Operation Examples</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt">5.1. Create a USRQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt_1">5.1.1. Maxinum Number of Messages of a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt_2">5.1.2. USRQ's Domain Attribute</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt_3">5.1.3. QUSCRTUQ's parameter 14, Number of Queue Extensions</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_dlt">5.2. Delete a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_enq">5.3. Enqueue Messages to a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_deq">5.4. Dequeue Messages from a USRQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_deq_1">5.4.1. Execute DEQ Instruction without Waiting</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_deq_2">5.4.2. Execute DEQ Instruction with Limited Time-out or Infinitely</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_clr">5.5. Clear a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_matqat">5.6. Retrieve Attributes of a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_matqmsg">5.7. Retrieve Messages on a USRQ</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_sect_using_q_usage_demo">6. Usage Examples of Queue Objects</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_byibm">6.1. IBM's USRQ example: Creating a Batch Machine</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_outputq">6.2. Data Queue Support on Output Queues</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority">6.3. Implement Priority-based IPC by Keyed Queue Objects</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority_1">6.3.1. Create the Keyed DTAQ Q27</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority_2">6.3.2. Write the Client Program R105</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority_3">6.3.3. Write the Server Program R106</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync">6.4. Simulate Synchronous Calls by i5/OS Queue Objects</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_1">6.4.1. Create DTAQ ISQL and ISQLR</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_2">6.4.2. Write the CL Command - ISQL</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_3">6.4.3. Write the Command Processing Program - ISQLCPP</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_4">6.4.4. Write the Request Porcessing Program - ISQLSVR</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_5">6.4.5. Run ISQLSVR and ISQL</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_6">6.4.6. Write CL command RUNSQL</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer">6.5. Pass Variable Length Data through i5/OS Queue Objects</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_1">6.5.1. Create USRQ ISQL2 and ISQLR2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_2">6.5.2. Write CL command - ISQL2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_3">6.5.3. Write Commnad Processing Program ISQLCPP2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_4">6.5.4. Write the Server Program ISQLSVR2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_5">6.5.5. Write CL Command RUNSQL2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_6">6.5.6. Run ISQLSVR2 and ISQL2</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java">6.6. Java and i5/OS Queue objects</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java_1">6.6.1. Write Java Class isql and isqlsvr</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java_2">6.6.2. Write Native Method isqlsvr.sendRequest</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java_3">6.6.3. Run Java Class isql</a></li></ul>
</li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_sect_using_q_appendices">Appendice</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_1">Appendix 1. Enqueue USRQ Q11 for 1000 times</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_3">Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_4">Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_6">Appendix 6 Reference</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_sect_using_q_about_me">About the Author</a></li></ul>
<h2><a class="anchor" name="en_sect_using_q_shuyu">
1. Terms and Abbreviations</a></h2>
Terms used in this article<ul>
<li>MI<br>
 Known also as TIMI(Technology Indepent Machine Interface), instroduced in S/38, the ancestor of i5/OS. MI is a logical interface between application programs and the SLIC(a software layer which dependent on the real hardwares). In another opinion, MI is an interface to the virtual machine implemented at the OS level on i5/OS. For details about MI, please refer to "Fortress Rochester: The Inside Story of the IBM ISeries", by Frank G. Soltis, ISBN 1583040838, 9781583040836.</li><li>Queue Object Types<br>
<ul>
<li>FIFO, queue entries are received in a first-in first-out sequence.</li><li>LIFO, queue entries are received in a last-in first-out sequence.</li><li>Keyed, queue entries are received by key. A key is a prefix added to an entry by its sender.</li></ul>
</li></ul>
<p>
Abbreviations used in this article<ul>
<li>DTAQ, Data Queue</li><li>USRQ, User Queue</li><li>OUTQ, Output Queue</li></ul>
<h2><a class="anchor" name="en_sect_using_q_intro">
2. An Introduction to Queue Objects on i5/OS</a></h2>
A queue is an MI object(with object type hex 0A) that can be used for storage and retrieval of data. Any jobs with authority to the queue can store and retrieve data from that queue. This makes a queue convenient for communications between programs. A process can test for data on a queue and either wait or continue execution if the data are not available. Data can be inserted on and removed from a queue based on a key value, or they can be processed based on order of arrival, either first-in-first-out (FIFO) or last-in-first-out (LIFO).<p>
On i5/OS, queue objects that can be operate through CL commands and APIs are: <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td></td><td>External Object Type </td><td>MI Object Type/Subtype  </td></tr>
<tr>
<td>Data Queue </td><td>*DTAQ </td><td>hex 0A01  </td></tr>
<tr>
<td>User Queue </td><td>*USRQ </td><td>hex 0A02  </td></tr>
</table>
<p>
Additionally, each i5/OS job uses a queue object named QMIRQ(Machine Interface Response Queue) to receive the I/O completion notification of each I/O request sent by the job. The MI object type of a QMIRQ is hex 0AEF.<p>
Main attributes of a queue object<ul>
<li>Maximum number of messages</li><li>Message text length (must be less than 64 KB)</li><li>Whether the queue is of fixed size or is extendable</li><li>Eextension value(number of messages per extension)</li><li>Initial number of messages when a queue object is creaeted</li><li>Whether storage reclaim will be attempted when the number of currently enqueued messages in the user queue reaches zero</li><li>Ordering sequence to use for messages: last-in-first-out (LIFO), first-in-first-out (FIFO), or keyed</li><li>Key length, if a key is present</li><li>Whether message data taken off the queue can contain pointers</li></ul>
<p>
Each queue message consists two parts, a message prefix and message text. For a keyed queue object, the key data resides in the message prefix. Both the message prefix and the message text are of fixed length. When enqueuing a message into a queue object, the length of the message text could be shorter than the <em>Message text length</em>, but the actual storage allocated on the queue object is the same to the <em>Message text length</em> attribute. For this reason, it is a bad idea to create a queue object for transferring different data formats which are different greatly in data length. That way will be a great waste in storage, and at the same time make damages to the efficiency of enqueue/dequeue operations.<p>
When a message is to be enqueued, the job requesting the enqueue must supply a message prefix and message text. The supplied message text may contains pointers; if it does, they are preserved by queueing. If the queue object is full, then one of the following actions occurs:<ul>
<li>If the queue is not extendable, or if the maximum number of extends specified by the user at queue creation has been reached, then the <em>queue full</em>(hex 2602, MCH3802) exception is signaled. The message is not enqueued.</li><li>If the queue is extendable, the queue is implicitly extended by the <em>extension value</em> attribute. The message is enqueued. No exception is signaled.</li></ul>
<p>
When using the QSNDDTAQ API to a enqueue data queue object, if the data queue object is full, QSNDDTAQ will raise exception CPF950A.<p>
When dequeuing a queue object, what happens to any pointers in the text depends on the <em>Whether message data taken off the queue can contain pointers</em> attribute. If pointers are allowed in message text, instructions to manipulate tagged pointers are used. Otherwise, the tags are not preserved and the pointers can no longer be used. If keys are used, pointers can be used as key values, but again the tags within the key are not preserved when the message is dequeued.<p>
When the queue is empty, or, if the messages are keyed and the requested key is not found, the job the dequeue can either wait or can exit. If the job waits, it can wait indefinitely or for a specified time period. When the time period expires, a <em>dequeue time-out</em> (hex 3A01, MCH5801) exception is signaled. When dequeue a data queue object with a specified time-out value, the Receive Data Queue (QRCVDTAQ) API will eat the <em>dequeue time-out</em> exception when a dequeue operation is timed-out. So it's the programmer's responsibility to distinguish whether a queue message is dequeued or the dequeue operatoin is timed-out when the QRCVDTAQ API returns by checking QRCVDTAQ's parameter 3 <em>length of dequeued data</em>. Parameter <em>length of dequeued data</em> of value 0, means that the dequeue operation is timed-out.<p>
To dequeue a data queue object with no wait, the QRCVDTAQ's parameter 5 <em>Wait time</em> should be set to 0. To dequeue a user queue object with no wait, the branch or indicator form of the DEQ instruction should be specified.<p>
You can save or restore a queue object; however, you can save or restore its definition only. You cannot save or restore the messages in it. For the same reason a queue object restored is always empty. You cannot restore a queue object if a queue object with the same name already exists in the library.<h2><a class="anchor" name="en_sect_using_q_diffs">
3. Difference between DTAQ and USRQ</a></h2>
Both DTAQ and USRQ are MI queue objects sharing all the attributes of a MI queue object, just with different external object type, *DTAQ and *USRQ. So what's the difference between them. We will discuss this problem considering the following aspects:<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_domain">3.1. Object Domain</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_journal">3.2. Whether the Queue can be Journaled</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_operation">3.3. Operation Interfaces</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_weight">3.4. Operation Efficiency</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_diffs_senderid">3.5. DTAQ Messages can Include Sender's Information</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_diffs_domain">
3.1. Object Domain</a></h3>
The only interface to create a DTAQ that IBM provided to programmers is the CL command CRTDTAQ. DTAQ objects created by this commad are always system domain object. Since user state processes cannot directly access system domain objects, we must access a DTAQ object through CL commands and APIs.<p>
To create a USRQ object, we must use the Create User Queue (QUSCRTUQ) API. This API allows a USRQ object to be created either as a system domain object or a user domain object. See <a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt_2">5.1.2. USRQ's Domain Attribute</a> for details. But a system doamin USRQ can only be accessed by queue operation MI instructions under security level 40.<h3><a class="anchor" name="en_ss_using_q_diffs_journal">
3.2. Whether the Queue can be Journaled</a></h3>
We can journal a DTAQ object, but not a USRQ object. Jounraling a DTAQ makes the IPC progress between jobs and threads transparent to the developers. Detail information about operations such as enqueue, dequeue, renaming, deletion on a DTAQ could be logged to journal entries once a DTAQ object is journaled. For all possible journal entry type for DTAQ operations, see <a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_4">Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a><p>
Remember that although a DTAQ object can be journaled, but the journal entries could neither be used to apply changes to a DTAQ object nor remove changes from a DTAQ object. The reason is that queue objects are designed for IPC tasks, users should not be permitted to change the data contents of a queue object by methods other than enqueue and dequeue. For the same reason, although a queue object can be saved or restored, but the data content of the queue object is NOT saved. Thus a newly restored queue object is always empty.<p>
Here we have an example, by which we can examine what will be logged into journal entries during enqueue, dequeue operations on a DTAQ object.<p>
<ul>
<li>Create DTAQ Q13 of type FIFO, entry length = 64 <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/Q13) MAXLEN(64)
</pre></div></li></ul>
<p>
<ul>
<li>Journal DTAQ Q13 <div class="fragment"><pre class="fragment">STRJRNOBJ OBJ(LSBIN/Q13) OBJTYPE(*DTAQ) JRN(JRN01) IMAGES(*AFTER)
</pre></div></li></ul>
<p>
<ul>
<li>Enqueue Q13 twice <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('Q13' 'LSBIN' X'00010F' 'AAAAAAAAAA')
CALL PGM(QSNDDTAQ) PARM('Q13' 'LSBIN' X'00020F' 'BBBBBBB CCCCCCC')
</pre></div> Use CL command <a href="../q/page_dspqmsg.html">DSPQMSG</a> provided by <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>, <div class="fragment"><pre class="fragment">DSPQMSG Q13 *DTAQ
</pre></div> Messages currently on DTAQ Q13 are: <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Number </td><td>Time enqueued </td><td>Message Text  </td></tr>
<tr>
<td>1 </td><td>2009-05-18-11.27.58.619412 </td><td>'AAAAAAAAAA'  </td></tr>
<tr>
<td>2 </td><td>2009-05-18-11.28.23.033237 </td><td>'BBBBBBB CCCCCCC'  </td></tr>
</table>
</li><li>Dequeue DTAQ Q13 <div class="fragment"><pre class="fragment">CALL PGM(QRCVDTAQ) PARM('Q13' 'LSBIN' X'00020F' '' X'00001D')
</pre></div></li></ul>
<p>
<ul>
<li>Check journal entries <div class="fragment"><pre class="fragment">DSPJRN JRN(LSBIN/JRN01) JRNCDE((Q))
</pre></div> Output of command DSPJRN <div class="fragment"><pre class="fragment">         11075   Q     QS   Q13         LSBIN       REDLIGHT    11:27:58
         11076   Q     QS   Q13         LSBIN       REDLIGHT    11:28:23
         11077   Q     QR   Q13         LSBIN       REDLIGHT    12:25:22
</pre></div><ul>
<li>Check journal entries of enqueue operation(journal entry type为'QS')<ul>
<li>journal entries contains enqueued messages <div class="fragment"><pre class="fragment">                            Display Journal Entry                      
                                                                       
Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN
Member . . . . . . . :                                                 
Incomplete data  . . :   No              Minimized entry data :   No   
Sequence . . . . . . :   11075                                         
Code . . . . . . . . :   Q  - Data queue operation                     
Type . . . . . . . . :   QS - Send data queue entry, no key            
                                                                       
            Entry specific data                                        
Column      *...+....1....+....2....+....3....+....4....+....5         
00001      <span class="stringliteral">' K   1.                           N             AA'</span>        
00051      <span class="stringliteral">'AAAAAAAA'</span>

                            Display Journal Entry                      
                                                                       
Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN
Member . . . . . . . :                                                 
Incomplete data  . . :   No              Minimized entry data :   No   
Sequence . . . . . . :   11076                                         
Code . . . . . . . . :   Q  - Data queue operation                     
Type . . . . . . . . :   QS - Send data queue entry, no key            
                                                                       
            Entry specific data                                        
Column      *...+....1....+....2....+....3....+....4....+....5         
00001      <span class="stringliteral">' K E! !                           N             BB'</span>        
00051      <span class="stringliteral">'BBBBB CCCCCCC     '</span>                                        
</pre></div></li><li>Use function key F10 to check information about the program and the job when and who enqueued the DTAQ <div class="fragment"><pre class="fragment">                         Display Journal Entry Details                       
                                                                             
 Journal  . . . . . . :   JRN01           Library  . . . . . . :   LSBIN     
                                                                             
 Sequence . . . . . . :   11075                                              
 Code . . . . . . . . :   Q  - Data queue operation                          
 Type . . . . . . . . :   QS - Send data queue entry, no key                 
                                                                             
 Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN     
 Member . . . . . . . :                   Flag . . . . . . . . :   0         
 Date . . . . . . . . :   09/05/18        Time . . . . . . . . :   11:27:58  
                                          Ref Constraint . . . :   No        
 Count/RRN  . . . . . :   0                                                  
 Job  . . . . . . . . :   254281/LJL/REDLIGHT                                
 Commit cycle ID  . . :   0                                                  
 User profile . . . . :   LJL             Program  . . . . . . :   QCMD      
 Ignore APY/RMV . . . :   No                Library  . . . . . :     *OMITTED
 Trigger  . . . . . . :   No                ASP device . . . . :     *OMITTED
</pre></div></li></ul>
</li><li>Check journal entries of the dequeue operation(journal entry type为'QR').<ul>
<li>Used function key F10 to check information about the program and the job when and who dequeued the DTAQ <div class="fragment"><pre class="fragment">                         Display Journal Entry Details                       
                                                                             
 Journal  . . . . . . :   JRN01           Library  . . . . . . :   LSBIN     
                                                                             
 Sequence . . . . . . :   11077                                              
 Code . . . . . . . . :   Q  - Data queue operation                          
 Type . . . . . . . . :   QR - Rcv data queue entry, no key                  
                                                                             
 Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN     
 Member . . . . . . . :                   Flag . . . . . . . . :   0         
 Date . . . . . . . . :   09/05/18        Time . . . . . . . . :   12:25:22  
                                          Ref Constraint . . . :   No        
 Count/RRN  . . . . . :   0                                                  
 Job  . . . . . . . . :   254281/LJL/REDLIGHT                                
 Commit cycle ID  . . :   0                                                  
 User profile . . . . :   LJL             Program  . . . . . . :   QCMD      
 Ignore APY/RMV . . . :   No                Library  . . . . . :     *OMITTED
 Trigger  . . . . . . :   No                ASP device . . . . :     *OMITTED
</pre></div></li></ul>
</li></ul>
</li></ul>
<h3><a class="anchor" name="en_ss_using_q_diffs_operation">
3.3. Operation Interfaces</a></h3>
i5/OS provides operation interfaces to DTAQ objects and USRQ objects from 3 different levels, CL commands, APIs, and MI instructions.  
<table border="1">
<caption align="bottom">"Operation Interfaces to i5/OS queue objects"</caption>
<tr bgcolor="Silver">
<td>Operation</td> <td>Data Queue</td> <td>User Queue</td>
</tr>
<tr>
<td>Create</td> <td>CL - CRTDTAQ</td> <td>API - QUSCRTUQ</td>
</tr>
<tr>
<td>Delete</td> <td>CL - DLTDTAQ</td> <td>CL - DLTUSRQ; API - QUSDLTUQ</td>
</tr>
<tr>
<td>Enqueue</td> <td>API - QSNDDTAQ</td> <td>MI - ENQ</td>
</tr>
<tr>
<td>Dequeue</td> <td>API - QRCVDTAQ</td> <td>MI - DEQ</td>
</tr>
<tr>
<td>Clear</td> <td>API - QCLRDTAQ</td> <td>~</td>
</tr>
<tr>
<td>Retrieve queue attributes</td> <td>API - QMHQRDQD</td> <td>MI - MATQAT</td>
</tr>
<tr>
<td>Retrieved queue messages (without removing messages from the queue)</td> <td>API - QMHRDQM</td> <td>MI - MATQMSG</td>
</tr>
</table>
<h3><a class="anchor" name="en_ss_using_q_diffs_weight">
3.4. Operation Efficiency</a></h3>
It is hard to find detail discussion on DTAQ or USRQ's operation efficiency in IBM's official documents such as the iSeries Information center,<p>
Here we make a comparison between enqueue operatoins on a DTAQ and a USRQ. The purpose of this comparison is to demonstrate that the difference of operation efficiency between data queues and user queues do exits but not to provide accurate statistics on all queue operations. Before we start, one thing must be mentioned first. That is for an extensible queue object, the extensions will take quite an amount of time. In IPC applications that may cache a huge amount of data on a queue object, the impact to enqueue operations due to queue extensions must be taken into consideration.<p>
In the following statistics, we use queue objects whose <em>initial number of messages</em> are set to a number big enough to avoid queue extensions.<p>
Here we make time statistics of 1000 times of enqueue operation in 3 different conditions. The result time values are in microseconds.<ul>
<li>case 1: Enqueue a FIFO USRQ, with entry length 64</li><li>case 2: Enqueue a FIFO DTAQ, with entry length 64. The DTAQ is not journaled.</li><li>case 3: Enqueue a FIFO DTAQ, with entry length 64. The DTAQ is journaled.</li></ul>
<p>
<table border="1" cellspacing="3" cellpadding="3">
<caption align="bottom">"Statistics of 1000 times of enqueue operation"</caption>
<tr bgcolor="Silver">
<td>Case </td><td>Time used(us,micro-seconds) </td><td>Details  </td></tr>
<tr>
<td>case 1 </td><td>4000 </td><td><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_1">Appendix 1. Enqueue USRQ Q11 for 1000 times</a>  </td></tr>
<tr>
<td>case 2 </td><td>15100 </td><td><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a>  </td></tr>
<tr>
<td>case 3 </td><td>40599000 </td><td><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_3">Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a>  </td></tr>
</table>
<p>
Although the statistics data are only concerned about enqueue operations, we can see that there's large difference in weights of two types of queue objects, DTAQ and USRQ. Additionally, we can see that journaling a DTAQ will make the enqueue operations to the DTAQ much more slower.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>A DTAQ created with parameter FORCE(*YES)(Force to auxiliary storage) will also make enqueue/dequeue operations slower.</dd></dl>
<h3><a class="anchor" name="en_ss_using_q_diffs_senderid">
3.5. DTAQ Messages can Include Sender's Information</a></h3>
Data queues have the ability to attach a sender ID to each message being placed on the queue. The sender ID, an attribute of the data queue which is established when the queue is created, contains the qualified job name and current user profile. This functionality is not a feature provided by the ENQ MI instruction. To achieve the same functionality on a USRQ, the program who enqueue the USRQ is responsible for adding it's job ID and current user profile name preceding the content of each message to enqueue. But doing this is not as meaningful as the sender ID support on DTAQs. Since the sender IDs in DTAQ messages are added by the system while the sender IDs in USRQ messages are added by the enqueue programs and then are NOT trustable.<p>
To include the sender ID in a DTAQ's messages, one should create the DTAQ with parameter SENDERID set to *YES. e.g. <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/Q14) MAXLEN(64) SENDERID(*YES) TEXT('with sender''s info')
</pre></div><p>
Now let's have a look on the so called sender's ID. Enqueue something on the newly create DTAQ Q14, then use CL command <a href="../q/page_dspqmsg.html">DSPQMSG</a> provided by <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>. <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('Q14' 'LSBIN' X'00011F' 'ABCDE *^_^*')
DSPQMSG Q(LSBIN/Q14) QTYPE(*DTAQ)
</pre></div> Output of command <a href="../q/page_dspqmsg.html">DSPQMSG</a> <div class="fragment"><pre class="fragment">                                Queue Message                            
                                                            System:   810
Queue  . . . . . . . :   Q14             Attribute  . . . . . :          
  Library  . . . . . :     LSBIN         Owner  . . . . . . . :   LJL    
Object ASP number  . :   1               Object Domain  . . . :   System 
Type . . . . . . . . :   *DTAQ           Key length . . . . . :   0      
                                         Key length . . . . . :   100    
                                         Number . . . . . . . :   1      
                                                                         
        -------------------Character data-------------------             
Column   *...+....1....+....2....+....3....+....4....+....5              
000001  <span class="stringliteral">'REDLIGHT  LJL       254281LJL       ABCDE *^_^*   '</span>             
000051  <span class="stringliteral">'                                                  '</span>             
</pre></div> We can see that the sender's ID consists 2 parts:<ul>
<li>26 bytes of job ID<ul>
<li>Job name, char(10)</li><li>User profile name, char(10)</li><li>Job number, char(6)</li></ul>
</li><li>Job's current user profile name, char(10)</li></ul>
<h2><a class="anchor" name="en_sect_using_q_dtaq_howtos">
4. Data Queue Operation Examples</a></h2>
Contents<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt">4.1. Create a DTAQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_1">4.1.1. Create a DTAQ of type FIFO or LIFO</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_2">4.1.2. Create a Keyed DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_3">4.1.3. Create a DTAQ Supports Sender's ID</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_4">4.1.4. Parameter MAXLEN(Maximum entry length) of CL command CRTDTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_crt_5">4.1.5. Parameter SIZE of CL Command CRTDTAQ</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_dlt">4.2. Delete a DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq">4.3. Enqueue Messages to a DTAQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq_1">4.3.1. Enqueue messages to a FIFO/LIFO DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq_2">4.3.2. Enqueue Messages to a Keyed DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_enq_3">4.3.3. Enqueue Messages to a Keyed DTAQ (in ILE RPG)</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq">4.4. Dequeue Messages from a DTAQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq_1">4.4.1. Dequeue Messages from a FIFO/LIFO DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq_2">4.4.2. Dequeue Messages from a Keyed DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_deq_3">4.4.3. Dequeue Messages from a Keyed DTAQ without Removal of the Mequeued Messages</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_clr">4.5. Clear Messages on a DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_matqat">4.6. Retrieve Attributes of a DTAQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_dtaq_howtos_matmsg">4.7. Retrieve Messages from a DTAQ without Removing them</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_crt">
4.1. Create a DTAQ</a></h3>
<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_crt_1">
4.1.1. Create a DTAQ of type FIFO or LIFO</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q21) MAXLEN(64) SEQ(*FIFO) TEXT('FIFO, entry length=64')
CRTDTAQ DTAQ(Q22) MAXLEN(64) SEQ(*LIFO) TEXT('LIFO, entry length=64')
</pre></div> Enqueue some messages to the LIFO DTAQ Q22, then use the <a href="../q/page_dspqmsg.html">DSPQMSG</a> command on Q22. Pay attention to the order of the messages on Q22. <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('Q22' 'LSBIN' X'00003F' 'abc')
CALL PGM(QSNDDTAQ) PARM('Q22' 'LSBIN' X'00003F' 'def')
DSPQMSG Q22
<span class="comment">/* output of DSPQMSG */</span>
                Time                        Message
Opt     Number  enqueued                    Key    
             1  2009-05-19-16.36.49.641679         
             2  2009-05-19-16.36.40.429570         
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_crt_2">
4.1.2. Create a Keyed DTAQ</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q23) MAXLEN(64) SEQ(*KEYED) KEYLEN(8) TEXT('keyed, key length = 8')
</pre></div> Enqueue some messages to the keyed DTAQ Q23, then use the <a href="../q/page_dspqmsg.html">DSPQMSG</a> command on Q23. Pay attention to the order of the messages on Q23. <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('Q23' 'LSBIN' X'00003F' 'abc' X'008F' '00000005')
CALL PGM(QSNDDTAQ) PARM('Q23' 'LSBIN' X'00003F' 'def' X'008F' '00000002')
CALL PGM(QSNDDTAQ) PARM('Q23' 'LSBIN' X'00003F' 'ghi' X'008F' '00000003')

DSPQMSG Q(Q23)
<span class="comment">/* output of DSPQMSG */</span>
                Time                        Message 
Opt     Number  enqueued                    Key     
             1  2009-05-19-16.48.14.771519  00000002
             2  2009-05-19-16.48.38.547735  00000003
             3  2009-05-19-16.48.04.499240  00000005
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_crt_3">
4.1.3. Create a DTAQ Supports Sender's ID</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q24) MAXLEN(64) SENDERID(*YES)
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_crt_4">
4.1.4. Parameter MAXLEN(Maximum entry length) of CL command CRTDTAQ</a></h3>
MAXLEN(Maximum entry length) specifies the maximum length of the entry that is sent to the data queue. Valid values range from 1 through 64512. As we previously metioned in <a class="el" href="page_using_q_en.html#en_sect_using_q_intro">2. An Introduction to Queue Objects on i5/OS</a> Although we can specify a length of message text shorter than the MAXLEN parameter, the actual storage occupied by one DTAQ message text is always the same with the MAXLEN parameter. To exchange variable length data on a queue object, please refer to <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer">6.5. Pass Variable Length Data through i5/OS Queue Objects</a>.<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_crt_5">
4.1.5. Parameter SIZE of CL Command CRTDTAQ</a></h3>
Parameter SIZE consist of 2 elements, the maximum number of entries and the initial number of entries for the data queue.<p>
For the <em>Maximum number of entries</em> element note that:<ul>
<li>When we specify a number for element <em>Maximum number of entries</em>, the number means the maxinum number of entries can be put on the DTAQ. The machine may modify the specified number a little. To get the accurate <em>Maximum number of entries</em> attribute of a newly created DTAQ, use the <a href="../q/page_dspqd.html">DSPQD</a> command of <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>.</li><li><em>Maximum number of entries</em> has two special values, MAX16MB, and *MAX2GB. These two special values are talk about the storage upper limit of a DTAQ, not the upper limit of DTAQ entries. The real <em>Maximum number of entries</em> will be determined by the machine, considering the DTAQ entry length, key length, includeing sender's ID or not. To get the real <em>Maximum number of entries</em> attribute of a newly created DTAQ, use the <a href="../q/page_dspqd.html">DSPQD</a> command of <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>.</li></ul>
<p>
The <em>Initial number of entries</em> element specifies the amount of storage that will initially be allocated to the data queue in order to hold the <em>Initial number of entries</em>. Note that:<ul>
<li>Specify a proper <em>Initial number of entries</em> will avoid runtime queue extensions and efficiency damages caused by queue extensions.</li><li>If a DTAQ is created with parameter AUTORCL (Automatic reclaim) set to *YES, the storage allocated for the data queue is automatically reclaimed when the data queue is empty. When this occurs, the storage occupied by the DTAQ is of the size that only <em>Initial number of entries</em> can be hold on the DTAQ.</li></ul>
<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_dlt">
4.2. Delete a DTAQ</a></h3>
To delete a DTAQ, use CL command DLTDTAQ, e.g. <div class="fragment"><pre class="fragment">DLTDTAQ LSBIN/Q21
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_enq">
4.3. Enqueue Messages to a  DTAQ</a></h3>
To enqueue messages to a DTAQ, one need to use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qsnddtaq.htm">Send to a Data Queue (QSNDDTAQ)</a> API.<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_enq_1">
4.3.1. Enqueue messages to a FIFO/LIFO DTAQ</a></h3>
<div class="fragment"><pre class="fragment">call qsnddtaq parm(          
     <span class="stringliteral">'Q21'</span>         <span class="comment">/* char(10), DTAQ name */</span>  
     <span class="stringliteral">'LSBIN'</span>       <span class="comment">/* char(10), DTAQ library */</span>
     X<span class="stringliteral">'00003F'</span>     <span class="comment">/* pkd(5,0), length of message text to enqueue */</span> 
     <span class="stringliteral">'ABC'</span>         <span class="comment">/* char(*), message text */</span>          
     )                       
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_enq_2">
4.3.2. Enqueue Messages to a Keyed DTAQ</a></h3>
<div class="fragment"><pre class="fragment">call qsnddtaq parm(      
     <span class="stringliteral">'Q23'</span>         <span class="comment">/* char(10), DTAQ name */</span>  
     <span class="stringliteral">'LSBIN'</span>       <span class="comment">/* char(10), DTAQ library */</span>
     X<span class="stringliteral">'00003F'</span>     <span class="comment">/* pkd(5,0), length of message text to enqueue */</span>
     <span class="stringliteral">'abc'</span>         <span class="comment">/* char(*), message text */</span>          
     x<span class="stringliteral">'008F'</span>       <span class="comment">/* pkd(3,0), key length */</span>
     <span class="stringliteral">'00000001'</span>    <span class="comment">/* char(*), key value */</span>
     )                   
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_enq_3">
4.3.3. Enqueue Messages to a Keyed DTAQ (in ILE RPG)</a></h3>
ILE RPG program <a href="src/r101.rpgle">r101.rpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r101.rpgle</span>
<span class="comment">      * enqueue DTAQ Q23(keyed, key length=8, entry length=64)</span>
<span class="comment">      */</span>

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm(<span class="stringliteral">'QSNDDTAQ'</span>)
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       64a   options(*varsize)
     d   key_len                      3p 0
     d   key                          8a   options(*varsize)

     d qname           s             10a   inz('Q23')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0 inz(64)
     d entry           s             64a
     d key_len         s              3p 0 inz(8)
     d key             s              8a

      /free
          entry = 'abc';
          key = '00000002';
          qsnddtaq(qname
                   : qlib
                   : entry_len
                   : entry
                   : key_len
                   : key );

          *inlr = *on;
      /end-free
     <span class="comment">/* eof */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_deq">
4.4. Dequeue Messages from a DTAQ</a></h3>
To dequeue messages from a DTAQ, one should use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qrcvdtaq.htm">Receive Data Queue (QRCVDTAQ)</a> API.<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_deq_1">
4.4.1. Dequeue Messages from a FIFO/LIFO DTAQ</a></h3>
OPM CL program<a href="src/cl101.clp">cl101.clp</a> dequeus FIFO DTAQ Q21, waiting inifinitely. <div class="fragment"><pre class="fragment">             <span class="comment">/************************************************/</span>
             <span class="comment">/* @FILE CL101.CLP                              */</span>
             <span class="comment">/* DEQUEUE FIFO DTAQ Q21                        */</span>
             <span class="comment">/************************************************/</span>
             PGM
             DCL        VAR(&amp;QNAM) TYPE(*CHAR) LEN(10) VALUE('Q21')
             DCL        VAR(&amp;QLIB) TYPE(*CHAR) LEN(10) VALUE('LSBIN')
             DCL        VAR(&amp;ENTLEN) TYPE(*DEC) LEN(5 0) <span class="comment">/* length +</span>
<span class="comment">                          of dequeued data */</span>
             DCL        VAR(&amp;ENTRY) TYPE(*CHAR) LEN(64)
             DCL        VAR(&amp;TIMEOUT) TYPE(*DEC) LEN(5 0) VALUE(-1) +
                          <span class="comment">/* dequeue infinittely */</span>
             DCL        VAR(&amp;MSG) TYPE(*CHAR) LEN(32) VALUE('entry +
                          dequeued:')

             CALL       PGM(QRCVDTAQ) PARM(&amp;QNAM &amp;QLIB &amp;ENTLEN +
                          &amp;ENTRY &amp;TIMEOUT)
             CHGVAR     VAR(%SST(&amp;MSG 17 16)) VALUE(&amp;ENTRY)
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&amp;MSG)

             ENDPGM
             <span class="comment">/* EOF - CL101.CLP */</span>
</pre></div><p>
OPM CL program<a href="src/cl105.clp">cl105.clp</a> dequeues FIFO DTAQ Q21, with limited time-out value. <div class="fragment"><pre class="fragment">             <span class="comment">/************************************************/</span>
             <span class="comment">/* @FILE CL101.CLP                              */</span>
             <span class="comment">/* DEQUEUE FIFO DTAQ Q21 WITH TIMEOUT           */</span>
             <span class="comment">/************************************************/</span>
             PGM
             DCL        VAR(&amp;QNAM) TYPE(*CHAR) LEN(10) VALUE('Q21')
             DCL        VAR(&amp;QLIB) TYPE(*CHAR) LEN(10) VALUE('LSBIN')
             DCL        VAR(&amp;ENTLEN) TYPE(*DEC) LEN(5 0) <span class="comment">/* length +</span>
<span class="comment">                          of dequeued data */</span>
             DCL        VAR(&amp;ENTRY) TYPE(*CHAR) LEN(64)
             DCL        VAR(&amp;TIMEOUT) TYPE(*DEC) LEN(5 0) VALUE(5) +
                          <span class="comment">/* time-out value = 5s */</span>
             DCL        VAR(&amp;MSG) TYPE(*CHAR) LEN(32) VALUE('entry +
                          dequeued:')

             CALL       PGM(QRCVDTAQ) PARM(&amp;QNAM &amp;QLIB &amp;ENTLEN +
                          &amp;ENTRY &amp;TIMEOUT)
             IF         COND(&amp;ENTLEN *EQ 0) THEN(DO)
             CHGVAR     VAR(&amp;MSG) VALUE('Dequeue timed-out')
             GOTO       CMDLBL(SENDMSG)
             ENDDO
             CHGVAR     VAR(%SST(&amp;MSG 17 16)) VALUE(&amp;ENTRY)
 SENDMSG:    SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&amp;MSG)

             ENDPGM
             <span class="comment">/* EOF - CL101.CLP */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_deq_2">
4.4.2. Dequeue Messages from a Keyed DTAQ</a></h3>
Keyed DTAQ Q23 with entry length 64 and key length 8. OPM CL program<a href="src/cl102.clp">cl102.clp</a> dequeues one message from Q23 whose key values is greater than '00000001'. <div class="fragment"><pre class="fragment">             <span class="comment">/************************************************/</span>
             <span class="comment">/* @FILE CL102.CLP                              */</span>
             <span class="comment">/* DEQUEUE KEYED DTAQ Q23                       */</span>
             <span class="comment">/************************************************/</span>
             PGM
             DCL        VAR(&amp;QNAM) TYPE(*CHAR) LEN(10) VALUE('Q23')
             DCL        VAR(&amp;QLIB) TYPE(*CHAR) LEN(10) VALUE('LSBIN')
             DCL        VAR(&amp;ENTLEN) TYPE(*DEC) LEN(5 0)
             DCL        VAR(&amp;ENTRY) TYPE(*CHAR) LEN(64)
             DCL        VAR(&amp;TIMEOUT) TYPE(*DEC) LEN(5 0) VALUE(-1) +
                          <span class="comment">/* dequeue infinittely */</span>
             DCL        VAR(&amp;KEYORDER) TYPE(*CHAR) LEN(2) +
                          VALUE('GT') <span class="comment">/* dequeue queue entries +</span>
<span class="comment">                          whose key value aregreater than variable +</span>
<span class="comment">                          &amp;KEY */</span>
             DCL        VAR(&amp;KEYLEN) TYPE(*DEC) LEN(3 0) VALUE(8)
             DCL        VAR(&amp;KEY) TYPE(*CHAR) LEN(8) VALUE('00000001')
             DCL        VAR(&amp;SNDINFOLEN) TYPE(*DEC) LEN(3 0) +
                          VALUE(0) <span class="comment">/* no sender info */</span>
             DCL        VAR(&amp;SNDINFO) TYPE(*CHAR) LEN(1)
             DCL        VAR(&amp;MSG) TYPE(*CHAR) LEN(96) +
                          VALUE('key:         ; message text: ')

             CALL       PGM(QRCVDTAQ) PARM(&amp;QNAM &amp;QLIB &amp;ENTLEN +
                          &amp;ENTRY &amp;TIMEOUT &amp;KEYORDER &amp;KEYLEN &amp;KEY +
                          &amp;SNDINFOLEN &amp;SNDINFO)
             CHGVAR     VAR(%SST(&amp;MSG 6 8)) VALUE(&amp;KEY)
             CHGVAR     VAR(%SST(&amp;MSG 30 64)) VALUE(&amp;ENTRY)
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&amp;MSG)

             ENDPGM
             <span class="comment">/* EOF - CL102.CLP */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_deq_3">
4.4.3. Dequeue Messages from a Keyed DTAQ without Removal of the Mequeued Messages</a></h3>
Keyed DTAQ Q23 with entry length 64 and key length 8. ILE RPG program<a href="src/r102.rpgle">rl102.rpgle</a> dequeues one messages on Q23 whose key values is greater than '00000001' without removal of the dequeued messages. <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r102.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * DTAQ Q23，类型为基于键值出列，entry长度64，key长度8，</span>
<span class="comment">      * 不含发送作业标识信息。</span>
<span class="comment">      *</span>
<span class="comment">      * 出列DTAQ Q23中键值大于'00000001'的entry，并保留DTAQ中的entry。</span>
<span class="comment">      */</span>

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm(<span class="stringliteral">'QRCVDTAQ'</span>)
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       64a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          8a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     d qname           s             10a   inz('Q23')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0
     d entry           s             64a
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('GT')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(8)
     d key             s              8a   inz('00000001')
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d remove_msg      s             10a   inz('*NO')                           <span class="comment">/* do NOT remove message from DTAQ */</span>
     d receiver_len    s              5p 0 inz(64)
     d ec              ds                  likeds(qusec_t)
     d msg             s             16a

      /free
          ec.bytes_in = 256;
          qrcvdtaq(  qname
                   : qlib
                   : entry_len
                   : entry
                   : timeout
                   : key_order
                   : key_len
                   : key
                   : sender_info_len
                   : sender_info
                   : remove_msg
                   : receiver_len
                   : ec );

           msg = %subst(entry : 1 : 16);
           dsply key '*EXT' msg;

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r102.rpgle */</span>
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>QRCVDTAQ's parameter 9, <em>Length of sender information</em> is an input/output parameter. On input, it should contain callers search criterion. On output, it contains the key value of the dequeued message.</dd></dl>
<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_clr">
4.5. Clear Messages on a DTAQ</a></h3>
To clear a DTAQ, one should use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qclrdtaq.htm">Clear Data Queue (QCLRDTAQ)</a> API, e.g. <div class="fragment"><pre class="fragment">CALL PGM(QCLRDTAQ) PARM('Q21' 'LSBIN')
</pre></div><h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_matqat">
4.6. Retrieve Attributes of a DTAQ</a></h3>
To retrieve attributes of a DTAQ, one should use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qmhqrdqd.htm">Retrieve Data Queue Description (QMHQRDQD)</a> API. QMHQRDQD supports 2 formats of DTAQ attributes, RDQD0100 and RDQD0200. The former is for a common DTAQ(*STD). The latter is for a DDM DTAQ(*DDM). ILE RPG program <a href="src/r103.rpgle">r103.rpgle</a> use QMHQRDQD to retrieve attributes of DTAQ Q23. <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r103.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * retrieve attribtutes of a DTAQ</span>
<span class="comment">      * Keyed DTAQ Q23 with entry length 64, key length 8,</span>
<span class="comment">      * does not include sender's ID</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     <span class="comment">/* receiver structure in format RDQD0100 */</span>
     d rdqd0100_t      ds           112    qualified
     d   bytes_...
     d     returned                  10i 0                                      <span class="comment">/* length of attribute data returned */</span>
     d   bytes_...
     d     available                 10i 0                                      <span class="comment">/* length DTAQ attribute data */</span>
     d   entry_len                   10i 0                                      <span class="comment">/* DTAQ entry length */</span>
     d   key_len                     10i 0                                      <span class="comment">/* DTAQ key length */</span>
     d   sequence                     1a                                        <span class="comment">/* DTAQ type:        */</span>
     d                                                                          <span class="comment">/*   - 'F', FIIO     */</span>
     d                                                                          <span class="comment">/*   - 'K', Keyed    */</span>
     d                                                                          <span class="comment">/*   - 'L', LIFO     */</span>
     d   include_...
     d    sender_info                 1a                                        <span class="comment">/* include sender info or not: Y/N */</span>
     d   force_to_stg                 1a                                        <span class="comment">/* force to storage: Y/N */</span>
     d   text                        50a                                        <span class="comment">/* text description */</span>
     d   ddm_dtaq                     1a                                        <span class="comment">/* is q DDM DTAQ:    */</span>
     d                                                                          <span class="comment">/*   - '0', no       */</span>
     d                                                                          <span class="comment">/*   - '1', yes      */</span>
     d   auto_reclaim                 1a                                        <span class="comment">/* automatic reclaim storage */</span>
     d                                                                          <span class="comment">/*   - '0', no       */</span>
     d                                                                          <span class="comment">/*   - '1', yes      */</span>
     d   reserved                     1a
     d   num_messages                10i 0                                      <span class="comment">/* messages currently on the DTAQ */</span>
     d   entries_...
     d     allocated                 10i 0                                      <span class="comment">/* entries currently allocated */</span>
     d   qname                       10a
     d   qlib                        10a
     d   max_messages                10i 0                                      <span class="comment">/* maximum number of messages */</span>
     d   init_...
     d     messages                  10i 0                                      <span class="comment">/* initial number of messages */</span>

     <span class="comment">/* prototype of API QMHQRDQD */</span>
     d qmhqrdqd        pr                  extpgm('QMHQRDQD')
     d   dtaq_attr                         likeds(rdqd0100_t)                   <span class="comment">/* receiver data */</span>
     d   receiver_len                10i 0                                      <span class="comment">/* length of receiver data */</span>
     d   format_name                  8a                                        <span class="comment">/* format name               */</span>
     d                                                                          <span class="comment">/*   - RDQD0100, normal DTAQ */</span>
     d                                                                          <span class="comment">/*   - RDQD0200, DDM DTAQ    */</span>
     d   qname_lib                   20a                                        <span class="comment">/* DTAQ name/library, e.g.   */</span>
     d                                                                          <span class="comment">/*   'Q23       LSBIN     '  */</span>

     d do_report       pr

     d dtaq_attr       ds                  likeds(rdqd0100_t)
     d len             s             10i 0 inz(112)
     d format          s              8a   inz('RDQD0100')
     d qname_lib       s             20a   inz('Q23       LSBIN')

      /free

          qmhqrdqd(  dtaq_attr
                   : len
                   : format
                   : qname_lib );

          do_report();

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - main procedure */</span>

     p do_report       b

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of QMHSNDPM */</span>
     d qmhsndpm        pr                  extpgm('QMHSNDPM')
     d   msgid                        7a
     d   msgf                        20a
     d   msgdata                    128a   options(*varsize)
     d   msgdata_len                 10i 0
     d   msgtype                     10a
     d   callstack_...
     d     entry                     10a
     d   callstack_...
     d     counter                   10i 0
     d   msgkey                       4a
     d   ec                                likeds(qusec_t)

     d msgid           s              7a   inz('CPF9898')
     d msgf            s             20a   inz('QCPFMSG   QSYS')
     d msgdata         s            128a
     d msgdata_len     s             10i 0
     d msgtype         s             10a   inz('*INFO')
     d callstack_...
     d   entry         s             10a   inz('*PGMBDY')
     d callstack_...
     d   counter       s             10i 0 inz(1)
     d msgkey          s              4a
     d ec              ds                  likeds(qusec_t)
     d msg             s            128a

      /free

          ec.bytes_in = 256;

          <span class="comment">// report DTAQ entry length</span>
          msgdata = 'Entry length: ' + %<span class="keywordtype">char</span>(dtaq_attr.entry_len);
          msgdata_len = %len(%trim(msgdata));
          qmhsndpm(  msgid
                   : msgf
                   : msgdata
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

          <span class="comment">// report DTAQ key length</span>
          msgdata = 'Key length: ' + %<span class="keywordtype">char</span>(dtaq_attr.key_len);
          msgdata_len = %len(%trim(msgdata));
          qmhsndpm(  msgid
                   : msgf
                   : msgdata
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

          <span class="comment">// report more DTAQ attributes</span>
          <span class="comment">// ... ...</span>

      /end-free
     p do_report       e

     <span class="comment">/* eof - r103.rpgle */</span>
</pre></div><p>
For more examples of using QMHQRDQD, please refer to internal entry points display-ddmq-attr(line 361) and display-dtaq-attr(line 396) in <a href="../q/page_dspqd.html">DSPQD</a> 's source code <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qattr.mi?view=markup">qattr.mi</a>.<h3><a class="anchor" name="en_ss_using_q_dtaq_howtos_matmsg">
4.7. Retrieve Messages from a DTAQ without Removing them</a></h3>
To retrieve messages from a DTAQ without removing them, one need to use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qmhrdqm.htm">Retrieve Data Queue Message (QMHRDQM)</a> API. Examples of using this API can be found in source code of command <a href="../q/page_dspqmsg.html">DSPQMSG</a>, <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qmsg.mi?view=markup">qmsg.mi</a><ul>
<li>internal entry point mat-keyed-q-msg(line 451), retrieve messages on a keyed DTAQ</li><li>internal entry point mat-nonkeyed-q-msg(line 580), retrieve messages on a FIFO/LIFO DTAQ</li></ul>
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The QMHRDQM API could not be used on a DDM DTAQ.</dd></dl>
<h2><a class="anchor" name="en_sect_using_q_usrq_howtos">
5. User Queue Operation Examples</a></h2>
<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt">5.1. Create a USRQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt_1">5.1.1. Maxinum Number of Messages of a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt_2">5.1.2. USRQ's Domain Attribute</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_crt_3">5.1.3. QUSCRTUQ's parameter 14, Number of Queue Extensions</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_dlt">5.2. Delete a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_enq">5.3. Enqueue Messages to a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_deq">5.4. Dequeue Messages from a USRQ</a><ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_deq_1">5.4.1. Execute DEQ Instruction without Waiting</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_deq_2">5.4.2. Execute DEQ Instruction with Limited Time-out or Infinitely</a></li></ul>
</li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_clr">5.5. Clear a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_matqat">5.6. Retrieve Attributes of a USRQ</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usrq_howtos_matqmsg">5.7. Retrieve Messages on a USRQ</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usrq_howtos_crt">
5.1. Create a USRQ</a></h3>
To create a USRQ, one should use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/quscrtuq.htm">Create User Queue (QUSCRTUQ)</a> API.<p>
Parameters of the QUSCRTUQ API<ul>
<li>Required Parameter Group:<ul>
<li>1 Qualified user queue name, Input, Char(20)</li><li>2 Extended attribute, Input, Char(10)</li><li>3 Queue type, Input, Char(1)</li><li>4 Key length, Input, Binary(4)</li><li>5 Maximum message size, Input, Binary(4)</li><li>6 Initial number of messages, Input, Binary(4)</li><li>7 Additional number of messages, Input, Binary(4)</li><li>8 Public authority, Input, Char(10)</li><li>9 Text description, Input, Char(50)</li></ul>
</li><li>Optional Parameter Group 1:<ul>
<li>10 Replace, Input, Char(10)</li><li>11 Error code, I/O, Char(*)</li></ul>
</li><li>Optional Parameter Group 2:<ul>
<li>12 Domain, Input, Char(10)</li><li>13 Pointers, Input, Char(10)</li></ul>
</li></ul>
<p>
<ul>
<li>Optional Parameter Group 3:<ul>
<li>14 Number of queue extensions, Input, Binary(4)</li><li>15 Reclaim storage, Input, Char(1)</li></ul>
</li></ul>
<p>
For detailed document of the QUSCRTUQ API, see <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/quscrtuq.htm">Create User Queue (QUSCRTUQ) API</a><h3><a class="anchor" name="en_ss_using_q_usrq_howtos_crt_1">
5.1.1. Maxinum Number of Messages of a USRQ</a></h3>
The following three parameters of the QUSCRTUQ API determines the maxinum number of messages(MAX_MSGS) could be placed on a USRQ:<ul>
<li><em>Initial number of messages</em>(INIT_MSGS)</li><li><em>Additional number of messages</em>(EXT_MSGS)</li><li><em>Number of queue extensions</em>(NUM_EXTENDS)</li></ul>
<p>
The fomula is: <div class="fragment"><pre class="fragment">MAX_MSGS = INIT_MSGS + EXT_MSGS * NUM_EXTENDS
<span class="comment">/*</span>
<span class="comment">e.g:</span>
<span class="comment">if</span>
<span class="comment">    INIT_MSGS = 1</span>
<span class="comment">    EXT_MSGS = 2</span>
<span class="comment">    NUM_EXTENDS = 1</span>
<span class="comment">then</span>
<span class="comment">    MAX_MSGS = 1 + 2 * 1 = 3</span>
<span class="comment">   */</span>
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The actual <em>Number of queue extensions</em> of a created USRQ may be modified a little by the machine. To get the accurate number, use CL commad <a href="../q/page_dspqd.html">DSPQD</a> provided by <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>.</dd></dl>
<h3><a class="anchor" name="en_ss_using_q_usrq_howtos_crt_2">
5.1.2. USRQ's Domain Attribute</a></h3>
QUSCRTUQ's parameter 12 <em>Domain</em> and the system value QALWUSRDMN determine a USRQ's domain attribute together. <table border="1" cellspacing="3" cellpadding="3">
<caption align="bottom">"USRQ's domain attribute"</caption>
<tr bgcolor="silver">
<td>QALWUSRDMN System Value </td><td>Destination Library </td><td>Optional Domain Parameter </td><td>Domain of Created Object  </td></tr>
<tr>
<td>*ALL </td><td>Any </td><td>*DEFAULT </td><td>User domain  </td></tr>
<tr>
<td>*ALL </td><td>Any </td><td>*SYSTEM </td><td>System domain  </td></tr>
<tr>
<td>*ALL </td><td>Any </td><td>*USER </td><td>User domain  </td></tr>
<tr>
<td>QTEMP </td><td>QTEMP </td><td>*DEFAULT </td><td>User domain  </td></tr>
<tr>
<td>QTEMP </td><td>QTEMP </td><td>*SYSTEM </td><td>System domain  </td></tr>
<tr>
<td>QTEMP </td><td>QTEMP </td><td>*USER </td><td>User domain  </td></tr>
<tr>
<td>Does not contain library name </td><td>Library name </td><td>*DEFAULT </td><td>System domain  </td></tr>
<tr>
<td>Does not contain library name </td><td>Library name </td><td>*SYSTEM </td><td>System domain  </td></tr>
<tr>
<td>Does not contain library name </td><td>Library name </td><td>*USER </td><td>None; error is returned  </td></tr>
</table>
<h3><a class="anchor" name="en_ss_using_q_usrq_howtos_crt_3">
5.1.3. QUSCRTUQ's parameter 14, Number of Queue Extensions</a></h3>
QUSCRTUQ's parameter 14, <em>Number of queue extensions</em> specifies the maximum number of extensions allowed for the USRQ. The iSeries information Center (V5R2/V5R4), document for the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/quscrtuq.htm">QUSCRTUQ API</a> said: <div class="fragment"><pre class="fragment">Number of queue extensions
    INPUT; BINARY(4)
    The maximum number of extensions allowed for the user queue.
    A value of -1 indicates that the maximum number of extensions
    will be chosen by the machine.
    If this parameter is not specified, 0 is assumed, which
    means the USRQ is not extensible.
</pre></div> But the experimental result on V5R2 is, whether specifying <em>Number of queue extensions</em> as -1 or not specifying <em>Number of queue extensions</em> the created USRQ's <em>Number of queue extensions</em> attribute will be choosed by the machine.<ul>
<li>Create USRQ Q34, specifying <em>Number of queue extensions</em> as -1. Then use the DSPQD command to check Q34's <em>Choose maximum number of extends</em> attribute and <em>Maximum number of extends</em> attribute. <div class="fragment"><pre class="fragment">       CALL PGM(QUSCRTUQ) PARM(
            'Q34       LSBIN'   <span class="comment">/* USRQ name */</span>
            'QQ'                <span class="comment">/* extended attribute */</span>
            'K'                 <span class="comment">/* queue type */</span>
            X'00000008'         <span class="comment">/* key length */</span>
            X'00000040'         <span class="comment">/* entry length */</span>
            X'00000001'         <span class="comment">/* initial number of messages */</span>
            X'00000002'         <span class="comment">/* number of messages per extension */</span>
            '*EXCLUDE'          <span class="comment">/* public authority */</span>
            '`Number of queue extensions`parameter  = -1' <span class="comment">/* text description */</span>
            '*YES'                                        <span class="comment">/* replace */</span>
            X'0000002000000000000000000000000000000000000000000000000000000000' <span class="comment">/* error code structure */</span>
            '*USER'             <span class="comment">/* object domain */</span>
            '*YES'              <span class="comment">/* contains poniter */</span>
            X'FFFFFFFF'         <span class="comment">/* number of queue extensions */</span>
            '0')                <span class="comment">/* auto-reclaim storage */</span>

       DSPQD Q(Q34) QTYPE(*USRQ)
       <span class="comment">/* Output */</span>
       Queue attributes:                                         
         Message content  . . . . . :   Contains scalar data only
         Queue type . . . . . . . . :   Keyed                    
         Queue overflow action  . . :   Extend queue             
         Choose maximum number of                                
           extends  . . . . . . . . :   Machine   <span class="comment">/* Determined by the machine */</span>
         Reclaim storage  . . . . . :   0                           
       
       ... ...
       
       Maximum number of extends  . :   87380     <span class="comment">/* The result 'Maximum number of extends' */</span>
</pre></div></li><li>Create USRQ, without specifying <em>Number of queue extensions</em> <div class="fragment"><pre class="fragment">       CALL PGM(QUSCRTUQ) PARM('Q34       LSBIN' 'QQ' 'K'
           X'00000008' X'00000040' X'00000001' X'00000002'
           '*EXCLUDE' 'Do NOT specify `Number of queue extensions` parameter')
    
       DSPQD Q(Q34) QTYPE(*USRQ)
       <span class="comment">/* Output */</span>
       Queue attributes:                                         
         Message content  . . . . . :   Contains scalar data only
         Queue type . . . . . . . . :   Keyed                    
         Queue overflow action  . . :   Extend queue             
         Choose maximum number of                                
           extends  . . . . . . . . :   Machine   <span class="comment">/* Determined by the machine */</span>
         Reclaim storage  . . . . . :   0                           
       
       ... ...
       
       Maximum number of extends  . :   87380     <span class="comment">/* The result 'Maximum number of extends' */</span>
</pre></div></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usrq_howtos_dlt">
5.2. Delete a USRQ</a></h3>
To delete a USRQ, one should use the CL command DLTUSRQ or the Delete User Queue (QUSDLTUQ) API. <div class="fragment"><pre class="fragment"><span class="comment">/* Using CL command DLTUSRQ */</span>
DLTUSRQ USRQ(LSBIN/Q31)
<span class="comment">/* Using API QUSCLTUQ */</span>
CALL PGM(QUSDLTUQ) PARM('Q34       LSBIN'
    X'0000002000000000000000000000000000000000000000000000000000000000') <span class="comment">/* QUSDLTUQ's second parameter, error code */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usrq_howtos_enq">
5.3. Enqueue Messages to a USRQ</a></h3>
To enqueue messages to a USRQ, one need to use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/ENQ.htm">Enqueue (ENQ)</a> MI instruction. Here we provide two examples about using the ENQ instruction respectively in ILE RPG and the MI language.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The third operation code of the ENQ instruction, <em>message text</em> must be aligned to 16 bytes boundary.</dd></dl>
ILE RPG program <a href="src/r104.rpgle">r104.rpgle</a> resolve to the USRQ object Q31 using the MI instruction <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/RSLVSP.htm">RSLVSP</a>, then enqueue Q31 by the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/ENQ.htm">ENQ</a> instruction. <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r104.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * enqueue USRQ Q31</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     <span class="comment">/* my protoype */</span>
     d i_main          pr                  extpgm('R104')
     d   p_key                        8a
     d   p_text                      64a

     d q               s               *
     d option          ds            34    qualified
     d   type                         2a   inz(x'0A02')                         <span class="comment">/* USRQ's MI object type: hex 0A02 */</span>
     d   name                        30a   inz('Q31')                           <span class="comment">/* USRQ name */</span>
     d   auth                         2a   inz(x'0000')
     <span class="comment">/* prototype of MI instruction RSLVSP */</span>
     d rslvsp          pr                  extproc('_RSLVSP2')
     d   syp                           *
     d   option                        *   value
     <span class="comment">/* prototype of MI instruction ENQ */</span>
     d enq             pr                  extproc('_ENQ')
     d   q                             *
     d   prefix                        *   value
     d   text                          *   value

     d prefix          ds                  qualified                            <span class="comment">/* message prefix */</span>
     d   text_len                    10i 0                                      <span class="comment">/* length of message text */</span>
     d   key                          8a   inz('00000001')                      <span class="comment">/* key data */</span>
     d text            s             64a   inz('hi, i''m rpg program R104:p')   <span class="comment">/* message text */</span>

     d i_main          pi
     d   p_key                        8a
     d   p_text                      64a

      /free

          rslvsp(q : %addr(option));

          prefix.key = p_key;
          text = p_text;
          enq(q : %addr(prefix) : %addr(text));

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r104.rpgle */</span>
</pre></div><p>
MI program <a href="src/enq31.mi">enq31.mi</a> implements the same work as <a href="src/r104.rpgle">r104.rpgle</a> <div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * @file enq31.mi</span>
<span class="comment"> *</span>
<span class="comment"> * enqueue USRQ Q31(keyed, key length = 8, entry lenght=64)</span>
<span class="comment"> *</span>
<span class="comment"> * usage example: CALL ENQ31 PARM('00000003' 'ABCDE...')</span>
<span class="comment"> */</span>

dcl sysptr q <span class="keyword">auto</span> init(<span class="stringliteral">"Q34"</span>, ctx(<span class="stringliteral">"LSBIN"</span>), type(q, 02)) ; 
dcl dd message-prefix char(9) auto ;
        dcl dd prefix-msglen bin(4) def(message-prefix) pos(1);
        dcl dd prefix-key <span class="keywordtype">char</span>(5) def(message-prefix) pos(5) ; 

dcl spcptr .key parm                ; 
dcl spcptr .text parm                ; 
dcl ol pl-main(.key, .text) parm ext        ; 

dcl dd key <span class="keywordtype">char</span>(8) bas(.key)    ; 
dcl dd text <span class="keywordtype">char</span>(64) bas(.text) ; 

dcl dd msg <span class="keywordtype">char</span>(64) auto bdry(16) ;
dcl spcptr msg-ptr auto init(msg) ; 

entry *(pl-main) ext;

        <span class="comment">/* enq */</span>
        cpynv prefix-msglen, 64;
        cpybla prefix-key, key  ;
        cpybla msg, text        ; 
        enq q, message-prefix, msg-ptr ; 

        rtx *;

pend;
<span class="comment">/* eof - enq31.mi */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usrq_howtos_deq">
5.4. Dequeue Messages from a USRQ</a></h3>
To dequeue a USRQ, one should use the MI instruction <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>.<p>
<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>'s operands are:<ul>
<li>operand 1, message prefix</li><li>operand 2, message text</li><li>operand 3, system pointer to the queue object</li></ul>
<p>
Format of operand 1 <em>message prefix</em>: <div class="fragment"><pre class="fragment">Offset  
Dec   Hex   Field Name                                      Data Type and Length
0   0   Timestamp of enqueue of message     Char(8) ++
8   8   Dequeue wait time-out value                     Char(8) +
          (ignored <span class="keywordflow">if</span> branch options specified) 
16  10  Size of message dequeued                  Bin(4) ++
          (The maximum allowable size of a queue message
                is 64 K bytes.)
20  14  Access state modification option indicator  Char(1) +
                and message selection criteria  
20  14  Access state modification option when entering Dequeue wait   Bit 0 +
                0 =   Access state is not modified
                1 =   Access state is modified
20  14  Access state modification option when leaving Dequeue wait  Bit 1 +
                0 =   Access state is not modified
                1 =   Access state is modified
20  14  Multiprogramming level option                             Bit 2 +
                0 =   Leave current MPL <span class="keyword">set</span> at Dequeue wait
                1 =   Remain in current MPL <span class="keyword">set</span> at Dequeue wait
20  14  Time-out option                                                 Bit 3 +
                0 =   Wait <span class="keywordflow">for</span> specified time, then signal time-out exception
                1 =   Wait indefinitely
20  14  Actual key to input key relationship                            Bits 4-7 +
          (<span class="keywordflow">for</span> keyed queue)
                0010 =  Greater than
                0100 =  Less than
                0110 =  Not equal
                1000 =  Equal
                1010 =  Greater than or equal
                1100 =  Less than or equal
21  15  Search key (ignored <span class="keywordflow">for</span> FIFO/LIFO queues but  Char(key length) +
                must be present <span class="keywordflow">for</span> FIFO/LIFO queues with
                nonzero key length values)  
  *   Message key                                     Char(key length) ++
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Fields shown here with one plus sign (+) indicate input to the instruction, and fields shown here with two plus signs (++) are returned by the machine. <p>
For details, please refer to <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">Dequeue (DEQ)</a></dd></dl>
<h3><a class="anchor" name="en_ss_using_q_usrq_howtos_deq_1">
5.4.1. Execute DEQ Instruction without Waiting</a></h3>
DEQ instruction retrieves a queue message based on the queue type (FIFO, LIFO, or keyed) specified during the queue's creation. If the queue was created with the keyed option, messages can be retrieved by any of the following relationships between an enqueued message key and a selection key specified in operand 1 <em>message prefix</em> of the DEQ instruction: =, &lt;&gt;, &gt;, &lt;, &lt;=, and &gt;=. If the queue was created with either the LIFO or FIFO attribute, then only the next message can be retrieved from the queue.<p>
If a message is not found that satisfies the dequeue selection criterion and the branch or indicator options are not specified, the thread waits until a message arrives to satisfy the dequeue or until the dequeue wait time-out expires. When specififying branch or indicator options, the thread is not placed in the dequeue wait state and either the control flow is altered according to the branch options, or indicator values are set based on the presence or absence of a message to be dequeued, e.g. <div class="fragment"><pre class="fragment">dcl sysptr q <span class="keyword">auto</span> init(<span class="stringliteral">"Q31"</span>, ctx(<span class="stringliteral">"LSBIN"</span>), type(q, 02)) ; 
dcl dd prefix char(37) auto     ;
dcl spcptr prefix-ptr auto init(prefix) ;
dcl spc prefix-t bas(prefix-ptr) ; 
        dcl dd time-enqueued <span class="keywordtype">char</span>(8) dir ; <span class="comment">/* output */</span>
        dcl dd timeout <span class="keywordtype">char</span>(8) dir ;
        dcl dd text-len bin(4) dir ;       <span class="comment">/* output */</span>
        dcl dd access-state-option <span class="keywordtype">char</span>(1) dir ;
        dcl dd search-key <span class="keywordtype">char</span>(8) ;
        dcl dd returned-key <span class="keywordtype">char</span>(8) ;      <span class="comment">/* output */</span>
dcl dd text <span class="keywordtype">char</span>(64) auto bdry(16) ;
dcl spcptr text-ptr auto init(text) ; 

entry * ext                     ; 

brk "DEQB"                      ; 
        <span class="comment">/* binary:      11000010 */</span>
        <span class="comment">/* dequeue messages whose keys are greater than search-key */</span>
        cpybla access-state-option, x"1202" ;
        cpybla search-key, "00000001" ; 
        deq(b) prefix, text-ptr, q / neq(not-found), eq(found) ; 
        
found:      <span class="comment">/* when a queue message dequeued, control flow will be branched here */</span>

not-found:  <span class="comment">/* when no queue message dequeued, control flow will be branched here */</span>

brk "DEQI"                        ;
dcl dd ind-found <span class="keywordtype">char</span>(1) auto   ; 
dcl dd ind-not-found <span class="keywordtype">char</span>(1) auto   ;
        deq(i) prefix, text-ptr, q / neq(ind-not-found), eq(ind-found) ;
        <span class="comment">/* when a queue message is dequeued, ind-found = '1', ind-not-found = '0' */</span>
        <span class="comment">/* when no queue message is dequeued, ind-found = '0', ind-not-found = '1' */</span>

        rtx *                   ; 
pend                                ; 
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>For more examples, please refer to the source code of <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>'s tool program <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/clrusrq.mi?view=markup">clrusrq.mi</a>, which clears a USRQ without waiting.</dd></dl>
<h3><a class="anchor" name="en_ss_using_q_usrq_howtos_deq_2">
5.4.2. Execute DEQ Instruction with Limited Time-out or Infinitely</a></h3>
To wait infinitely for a message satisfies the dequeue selection criterion, bit 3 of operand <em>message prefix</em>'s <em>Access state modification option indicator and message selection criteria</em> parameter must be set to 1. e.g. <div class="fragment"><pre class="fragment">dcl dd prefix char(37) auto     ;
dcl spcptr prefix-ptr auto init(prefix) ;
dcl spc prefix-t bas(prefix-ptr) ; 
        dcl dd time-enqueued <span class="keywordtype">char</span>(8) dir ; <span class="comment">/* output */</span>
        dcl dd timeout <span class="keywordtype">char</span>(8) dir ;
        dcl dd text-len bin(4) dir ;       <span class="comment">/* output */</span>
        dcl dd access-state-option <span class="keywordtype">char</span>(1) dir ;

        <span class="comment">/* set 'Time-out option' */</span>
        setbts access-state-option, 3;
</pre></div><p>
To specify a limited time-out value, one should set bit 3 of operand <em>message prefix</em>'s <em>Access state modification option indicator and message selection criteria</em> parameter to 0, and specify a time-out value in <em>message prefix</em>'s <em>Dequeue wait time-out value</em> parameter. The char(8) <em>Dequeue wait time-out value</em> is in the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MININ.htm#HDRTIMEFMT">Standard Time Format</a>. A zero <em>Dequeue wait time-out value</em> causes the default wait time-out of the current job is taken as the <em>Dequeue wait time-out value</em>. When the <em>Dequeue wait time-out value</em> expires, a <em>Dequeue Time-Out</em> exception (hex 3A01) is signaled. The following is an example of dequeue with limited time-out value. <div class="fragment"><pre class="fragment">dcl dd prefix char(37) auto     ;
dcl spcptr prefix-ptr auto init(prefix) ;
dcl spc prefix-t bas(prefix-ptr) ; 
        dcl dd time-enqueued <span class="keywordtype">char</span>(8) dir ; <span class="comment">/* output */</span>
        dcl dd timeout <span class="keywordtype">char</span>(8) dir ;
        dcl dd text-len bin(4) dir ;       <span class="comment">/* output */</span>
        dcl dd access-state-option <span class="keywordtype">char</span>(1) dir ;

dcl dd seconds bin(4) auto init(7) ; <span class="comment">/* 7 seconds */</span>
        mult(s) seconds, 125000 ; 
        cpybtrls timeout, seconds, 17 ;<span class="comment">/* copy seconds to timeout aligning from the left; shift 17 bits to the right */</span>

        <span class="comment">/* clear 'Time-out option' */</span>
        clrbts access-state-option, 3;
</pre></div><h3><a class="anchor" name="en_ss_using_q_usrq_howtos_clr">
5.5. Clear a USRQ</a></h3>
There's no CL command or API to clear to a USRQ. To clear a USRQ, we have to materize the attributes of a USRQ, and then dequeue it until it is empty. Here's an example, <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/clrusrq.mi?view=markup">clrusrq.mi</a>. You may call this program like the following: <div class="fragment"><pre class="fragment">CALL CLRUSRQ PARM(usrq_name)
</pre></div><h3><a class="anchor" name="en_ss_using_q_usrq_howtos_matqat">
5.6. Retrieve Attributes of a USRQ</a></h3>
To retrieve attributes of a USRQ, one should use the MI instruction <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQAT.htm">MATQAT</a><ul>
<li>For examples of using MATQAT, see <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>'s source code <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qattr.mi?view=markup">qattr.mi</a>.</li><li>For detailed documents on MATQAT, please refer to <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQAT.htm">Materialize Queue Attributes (MATQAT)</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usrq_howtos_matqmsg">
5.7. Retrieve Messages on a USRQ</a></h3>
To retrieve messages on a USRQ, use the <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQMSG.htm">MATQMSG</a> instruction.<ul>
<li>For examples of using MATQMSG, see <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>'s source code <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qmsg.mi?view=markup">qmsg.mi</a>.</li><li>For detailed documents on MATQMSG, please refer to <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQMSG.htm">Materialize Queue Messages (MATQMSG)</a></li></ul>
<h2><a class="anchor" name="en_sect_using_q_usage_demo">
6. Usage Examples of Queue Objects</a></h2>
Examples here<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_byibm">6.1. IBM's USRQ example: Creating a Batch Machine</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_outputq">6.2. Data Queue Support on Output Queues</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority">6.3. Implement Priority-based IPC by Keyed Queue Objects</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync">6.4. Simulate Synchronous Calls by i5/OS Queue Objects</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer">6.5. Pass Variable Length Data through i5/OS Queue Objects</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java">6.6. Java and i5/OS Queue objects</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_byibm">
6.1. IBM's USRQ example: Creating a Batch Machine</a></h3>
In the iSeries Information Center, IBM provides a basic usage demo on USRQs: <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apiref/apiexcremac.htm">Creating a Batch Machine</a>. In this example, one or more clients enqueues CL commands to a USRQ from which the server dequeues each commands and run them on behalf of the clients. The USRQ is of type FIFO, and with entry length 100.<h3><a class="anchor" name="en_ss_using_q_usage_demo_outputq">
6.2. Data Queue Support on Output Queues</a></h3>
Support is available to optionally associate a DTAQ with an output queue using the Create Output Queue (CRTOUTQ) or Change Output Queue (CHGOUTQ) command. Entries are logged in the DTAQ when spooled files are in ready (RDY) status on the output queue. A user program can determine when a spooled file is available on an output queue using the Receive DTAQ API (QRCVDTAQ) to receive information from a DTAQ.<p>
Each time a spooled file on the output queue reaches RDY status an entry is sent to the DTAQ. A spooled file can have several changes in status (for example, ready (RDY) to held (HLD) to release (RLS) to ready (RDY) again) before it is taken off the output queue. These status changes result in entries in the DTAQ for a spooled file each time the spooled file goes to RDY status.<p>
There're two methods to associate a DTAQ with one or more output queues.<ul>
<li>Add an evironment variable QIBM_NOTIFY_CRTSPLF with its value set to '*DTAQ' plus a valid DTAQ name and let the job who generates spooled file see it.</li><li>Specify the <em>DTAQ</em> parameter as a valid DTAQ name when using command CRTOUTQ or CHGOUTQ.</li></ul>
<p>
Here we will make an experimennt to show the data content of the DTAQ entry which is sent to the DTAQ when a spooled file reaches RDY status. Additionally, a Joblog Saver program is introduced in <a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a>.<p>
<b>Create the Notification Receiver DTAQ</b><br>
 First we create a DTAQ to receive notifications from the output queue. Note that:<ul>
<li>Type of the DTAQ must be eighter FIFO or LIFO</li><li>Length of the DTAQ entry must be greater or equal 128 bytes for notification type '01' or 144 bytes for notification type '02'.</li><li>User profile QSPL must has *USE authority to the DTAQ and EXECUTE authority to the library where the DTAQ resides in. <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/SPLF)
        MAXLEN(144)     <span class="comment">/* to receive type '02' notifications */</span>
        SEQ(*FIFO)
        SIZE(*MAX2GB)
        TEXT('Notification Queue for Spooled Files')
</pre></div></li></ul>
<p>
<b>Add Environment Variable QIBM_NOTIFY_CRTSPLF</b><br>
 <div class="fragment"><pre class="fragment">ADDENVVAR ENVVAR(QIBM_NOTIFY_CRTSPLF)
          VALUE('*DTAQ LSBIN/SPLF')
          LEVEL(*SYS)     <span class="comment">/* take system wide effects */</span>
</pre></div><p>
<b>Check the Notification DTAQ Entry</b><br>
 Try to generate a spooled file in a interactive job such compiling a RPG program. Use CL command <a href="../q/page_dspqmsg.html">DSPQMSG</a> to check the notification DTAQ entry in character format and hexadecimal format. <div class="fragment"><pre class="fragment"><span class="comment">/* DSPQMSG */</span>
DSPQMSG Q(LSBIN/SPLF)

<span class="comment">/* character format */</span>
        -------------------Character data-------------------
Column   *...+....1....+....2....+....3....+....4....+....5 
000001  <span class="stringliteral">'*SPOOL    02REDLIGHT  LJL       254395AAA         '</span>
000051  <span class="stringliteral">' QPRINT    QGPL      REDLIGHT  LJL       254395  '</span>
000101  <span class="stringliteral">'                   S65FAA4B  1090518164906       '</span>

<span class="comment">/* hexadecimal format */</span>
        ------------------Hexadecimal data------------------
Column   * . . . + . . . . 1 . . . . + . . . . 2 . . . . +  
000001  <span class="stringliteral">'5CE2D7D6D6D340404040F0F2D9C5C4D3C9C7C8E34040D3D1D3'</span>
000026  <span class="stringliteral">'40404040404040F2F5F4F3F9F5C1C1C1404040404040400000'</span>
000051  <span class="stringliteral">'0001D8D7D9C9D5E340404040D8C7D7D3404040404040D9C5C4'</span>
000076  <span class="stringliteral">'D3C9C7C8E34040D3D1D340404040404040F2F5F4F3F9F54040'</span>
000101  <span class="stringliteral">'4040404040404040000000000000000000000003E2F6F5C6C1'</span>
000126  <span class="stringliteral">'C1F4C24040F1F0F9F0F5F1F8F1F6F4F9F0F600            '</span>
</pre></div> The format of notification type '02' is: <table border="1" cellspacing="3" cellpadding="3">
<caption align="bottom">Format of notification type '02'</caption>
<tr bgcolor="silver">
<td>Offset Dec </td><td>Offset Hex </td><td>Field Meaning </td><td>Data Type and Length </td><td>Value in out example  </td></tr>
<tr>
<td>0 </td><td>0 </td><td>char(10) </td><td>Function name, always '*SPOOL' </td><td>'*SPOOL '  </td></tr>
<tr>
<td>10 </td><td>A </td><td>char(2) </td><td>Notification type, '02' </td><td>'02'  </td></tr>
<tr>
<td>12 </td><td>C </td><td>char(26) </td><td>Job ID. char(10) job name, char(10) user name, char(6) job number </td><td>'REDLIGHT LJL 254395'  </td></tr>
<tr>
<td>38 </td><td>26 </td><td>char(10) </td><td>Spooled file name </td><td>'AAA '  </td></tr>
<tr>
<td>48 </td><td>30 </td><td>binary(4) </td><td>Spooled file number </td><td>x'00000001'  </td></tr>
<tr>
<td>52 </td><td>34 </td><td>char(20) </td><td>Output queue name </td><td>'QPRINT QGPL '  </td></tr>
<tr>
<td>72 </td><td>48 </td><td>char(26) </td><td>Job ID </td><td>'REDLIGHT LJL 254395'  </td></tr>
<tr>
<td>98 </td><td>62 </td><td>char(10) </td><td>User data </td><td>' '  </td></tr>
<tr>
<td>108 </td><td>6C </td><td>binary(4) </td><td>Reserved </td><td>x'00000000'  </td></tr>
<tr>
<td>112 </td><td>70 </td><td>char(8) </td><td>Thread ID. ID of the thread that created the spooled file </td><td>x'0000000000000003'  </td></tr>
<tr>
<td>120 </td><td>78 </td><td>char(10) </td><td>System name. System on which the spooled file is created </td><td>'S65FAA4B '  </td></tr>
<tr>
<td>130 </td><td>82 </td><td>char(7) </td><td>Spooled file's creation date, in CYYMMDD format </td><td>'1090518'  </td></tr>
<tr>
<td>137 </td><td>89 </td><td>char(6) </td><td>Spooled file's creation time, in HHMMSS format </td><td>'164906'  </td></tr>
<tr>
<td>143 </td><td>8F </td><td>char(1) </td><td>Reserved </td><td>x'00'  </td></tr>
</table>
<p>
If a user application designed to receive notifications from the DTAQ needs to uniquely locate a spooled file by spooled file CL commands (e.g. CPYSPLF) or spooled file APIs (such as QSPOPNSP), commonly by the first three of the following six fields is enough:<ul>
<li><em>Spooled file name</em></li><li><em>Spooled file number</em></li><li><em>Job ID</em></li><li><em>System name</em></li><li><em>Spooled file's creation date</em></li><li><em>Spooled file's creation time</em></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_priority">
6.3. Implement Priority-based IPC by Keyed Queue Objects</a></h3>
Message priority is supported in various communication models. A priority-based communication model permits messages with higher priorities be processed first, so that one can ensure time critical tasks be processed in time by assigning higher priorities to them. On i5/OS, we can implement priority-based IPC by means of keyed queue objects.<p>
In the following example, client programs sent request to the server program by a keyed DTAQ. The key value of the DTAQ message acts as a message's priority whose permitted values are from '00' to '99'. '00' means the highest priority, '99' means the lowest priority. The server program dequeues all messages whose key values are greater than or equal to '00', thus a message with highest priority (smallest key value) will be dequeued first.<p>
Components in our example<ul>
<li>Keyed DTAQ Q27, with key length 2 and entry length 16.</li><li>The ILE RPG client program <a href="src/r105.rpgle">r105.rpgle</a></li><li>The ILE RPG server program <a href="src/r106.rpgle">r106.rpgle</a></li></ul>
<p>
Steps<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority_1">6.3.1. Create the Keyed DTAQ Q27</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority_2">6.3.2. Write the Client Program R105</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_priority_3">6.3.3. Write the Server Program R106</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_priority_1">
6.3.1. Create the Keyed DTAQ Q27</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q27)
        MAXLEN(16)  <span class="comment">/* entry length = 16 */</span>
        SEQ(*KEYED) <span class="comment">/* DTAQ type: keyed */</span>
        KEYLEN(2)   <span class="comment">/* key length = 2 */</span>
        TEXT('for priority-based IPC')
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_priority_2">
6.3.2. Write the Client Program R105</a></h3>
Input paramters of ILE RPG program <a href="src/r105.rpgle">r105.rpgle</a><ul>
<li>priority, char(2), request priority</li><li>delay, pkd(2,0), time to delay</li><li>msg, char(14), request data <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r105.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * enqueue DTAQ Q27</span>
<span class="comment">      *</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     d i_main          pr                  extpgm('R105')
     d   priority                     2a
     d   delay                        2p 0
     d   msg                         14a

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm('QSNDDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       16a   options(*varsize)
     d   key_len                      3p 0 options(*nopass)
     d   key                          2a   options(*nopass:*varsize)

     d qname           s             10a   inz('Q27')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0 inz(16)
     d key_len         s              3p 0 inz(2)

     <span class="comment">/* queue entry format, used both by the client and the server */</span>
     d q_format        ds                  qualified
     d   dly_time                     2p 0                                      <span class="comment">/* how long to    */</span>
     d   msg                         14a                                        <span class="comment">/* greeting words */</span>

     d i_main          pi
     d   priority                     2a
     d   delay                        2p 0
     d   msg                         14a

      /free

          q_format.dly_time = delay;
          q_format.msg      = msg;
          qsnddtaq(  qname
                   : qlib
                   : entry_len
                   : q_format
                   : key_len
                   : priority );

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r105.rpgle */</span>
</pre></div></li></ul>
<p>
One should call R105 like the following <div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment">Call R105</span>
<span class="comment"> - priority: '01'</span>
<span class="comment"> - delay: 15, hex 015F</span>
<span class="comment"> - msg: 'morning :p'</span>
<span class="comment">*/</span>
CALL PGM(R105) PARM('01' X'015F' 'morning :p')

<span class="comment">/* Use DSPQMSG command to check what has been enqueued on DTAQ Q27 */</span>
DSPQMSG Q(Q27) QTYPE(*DTAQ)

<span class="comment">/* Key data */</span>
        -------------------Character data-------------------
Column   *...+....1....+....2....+....3....+....4....+....5 
000001  '01                                                '

<span class="comment">/* hexadecimal format of queue entry's message text  */</span>
        ------------------Hexadecimal data------------------
Column   * . . . + . . . . 1 . . . . + . . . . 2 . . . . +  
000001  '015F94969995899587407A9740404040                  '
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_priority_3">
6.3.3. Write the Server Program R106</a></h3>
ILE RPG program<a href="src/r106.rpgle">r106.rpgle</a> dequeues all messages whose key values are greater than or equal to '00' looply. After dequeued a queue entry the server program delays the current job for seconds requested by the client and then display the request data passed by the client.<p>
<div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r106.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * deq R106</span>
<span class="comment">      *</span>
<span class="comment">      * queue message format</span>
<span class="comment">      *  - delay, pkd(2,0), delay time</span>
<span class="comment">      *  - msg, char(14), message from the client</span>
<span class="comment">      */</span>
     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm(<span class="stringliteral">'QRCVDTAQ'</span>)
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       64a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          8a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     <span class="comment">/* queue entry format, used both by the client and the server */</span>
     d q_format        ds                  qualified
     d   dly_time                     2p 0                                      <span class="comment">/* how long to    */</span>
     d   msg                         14a                                        <span class="comment">/* greeting words */</span>

     d qname           s             10a   inz('Q27')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0 inz(16)
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('GE')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(2)
     d key             s              2a   inz('00')
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d priority        s             16a

     d qcmdexc         pr                  extpgm('QCMDEXC')
     d   cmd                         64a   options(*varsize)
     d   cmdlen                      15p 5

     d dlyjob_cmd      s             64a
     d len             s             15p 5

     d QUIT_CMDS       c                   'q Q qu QU quit QUITT'
     d KEY_ARG         c                   '01'

      /free

          dow '1';

              key = KEY_ARG;
              <span class="comment">// deq DTAQ Q27</span>
              qrcvdtaq(  qname
                       : qlib
                       : entry_len
                       : q_format
                       : timeout
                       : key_order
                       : key_len
                       : key
                       : sender_info_len
                       : sender_info );

              <span class="comment">// should i quit?</span>
              if %scan( %trim(q_format.msg) : QUIT_CMDS ) &gt; 0;
                  priority = 'Priority: 100';
                  q_format.msg = 'see you :)';
                  dsply priority '' q_format.msg;
                  leave;
              endif;

              <span class="comment">// delay job</span>
              dlyjob_cmd = 'DLYJOB ' + %<span class="keywordtype">char</span>(q_format.dly_time);
              len = %len(%trim(dlyjob_cmd));
              qcmdexc(dlyjob_cmd : len);

              <span class="comment">// display message</span>
              priority = 'Priority: ' + key;
              dsply priority '' q_format.msg;

          enddo;

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r106.rpgle */</span>
</pre></div><p>
Now run the server program and the client program <div class="fragment"><pre class="fragment"><span class="comment">/* submit the server job */</span>
SBMJOB CMD(CALL R106)

<span class="comment">/* then call the client program for 4 times */</span>
CALL PGM(R105) PARM('99' X'015F' 'see you')
CALL PGM(R105) PARM('03' X'001F' 'Third')
CALL PGM(R105) PARM('02' X'001F' 'Second')
CALL PGM(R105) PARM('01' X'001F' 'First')

<span class="comment">/* check and reply R106's messages in *MSGQ QSYSOPR */</span>
First
  Reply . . :   a
Second
  Reply . . :   a
Third
  Reply . . :   a
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_sync">
6.4. Simulate Synchronous Calls by i5/OS Queue Objects</a></h3>
In IPC progresses based on queue objects instruced previously, programs that enqueue messages to a queue object do not know when a specific message is processed and the result of the processing. As a communication model, sometimes this is not acceptable. For example, in conditions that the processing result of a request message is meaningful for the program who sent the request messages to determine what to do next. Or a program who sends request messages have to wait util a previous request message has been processed to start the next step of its program logic such as sending the next request message.<p>
To solve the problems mentioned above in IPC models based on queue objects, we may simulate synchronous calls using queue objects. IPC models to simulate synchronous calls using queue objects are different in implementation details, but a common feature of them is that the two participants of the IPC progress use one queue object as the request queue, use another queue object as the reply queue. The requester program enqueue a request message to the request queue, then dequeue a reply message from the request processing program from the reply queue.<p>
As an example, here we implement a simple queue-based IPC model to simulate syncrhonous calls and design a SQL client(ISQL) and a SQL server(ISQLSVR) program which communicate with this IPC model.<p>
In the IPC model we discussed here:<ul>
<li>The request program (in many situations also the client program) communicate with the request processing program (the server program) on a pair of keyed DTAQs, one of which is a request queue, while the another a reply queue.</li><li>When sending a request, the request program enqueue a message to the request queue, with the message's key value set to a unique request ID, e.g. a UUID( 16 bytes Universal Unique ID), and the message's message text is set to the request data.</li><li>After sending a request the request program turns to the reply queue waiting for the reply message from the request processing program. The way to get the reply message of the current request is to dequeue a message from the reply queue whose key value is the same to the request ID of the current request.</li><li>The request processing program dequeues each available request from the request queue looply. After a request message is dequeued, the request processing program saves the message's key value (the unique request ID), processes the request data in the message's message text, and then enqueue a reply message to the reply queue, with the message's key value set to the request ID, and the message's message text set to the reply data or processing result.</li><li>After receiving the reply to a request, the request program checks the reply data, and determine what to do next according to the processing result represented by the reply data.</li></ul>
<p>
ISQL and ISQLSVR<ul>
<li>The client program ISQL (implemented as a CL command), send SQL statement to the server program ISQLSVR. ISQL and ISQLSVR communicate on a pair of keyed DTAQs of which one works as the a queue and the other works as a reply queue.</li><li>When sending a request, ISQL generate a UUID(Universal Unique ID) as a request ID and then enqueue a message to the request queue whose key value is the request ID, and message text is the SQL statement to execute. ISQL then turn to the reply queue to dequeue ISQLSVR's reply message whose key value is equal to the request ID.</li><li>ISQLSVR dequeues all available messages from the request queue looply. After a request message is dequeued, ISQLSVR saves the reqeust ID stored in the message key, executes the SQL statement in the message text. Then enqueue a reply message to the reply queue, with the message's key value set to the request ID of current request handled, and the message text set to the SQL code of the SQL statement executed.</li><li>After getting a reply message from ISQLSVR, ISQL retrieve the SQL code from the reply message and report the execution result to the user according to value of the returned SQL code.</li></ul>
<p>
Components involved in the ISQL example<ul>
<li>Request queue: data queue ISQL</li><li>Reply queue: data queue ISQLR</li><li>CL command ISQL: accepts user input and invokes command processing program ISQLCPP</li><li>CL command RUNSQL: accepts user input, invokes command processing program ISQLCPP, and returns the result SQL code. This command can be used in CL programs or REXX scripts.</li><li>CL command processing program ISQLCPP</li><li>Request processing program ISQLSVR</li></ul>
<p>
Steps<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_1">6.4.1. Create DTAQ ISQL and ISQLR</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_2">6.4.2. Write the CL Command - ISQL</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_3">6.4.3. Write the Command Processing Program - ISQLCPP</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_4">6.4.4. Write the Request Porcessing Program - ISQLSVR</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_5">6.4.5. Run ISQLSVR and ISQL</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync_6">6.4.6. Write CL command RUNSQL</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_sync_1">
6.4.1. Create DTAQ ISQL and ISQLR</a></h3>
DTAQ ISQL<ul>
<li>of type keyed</li><li>with key length 16 to hold a UUID(Universal Unique ID)</li><li>with entry length 256</li><li>queue entry format <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>SQL statement </td><td>char(256) </td><td>SQL statement string  </td></tr>
<tr>
<td>256 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
DTAQ ISQLR<ul>
<li>of type keyed</li><li>with key length 16 to hold a UUID(Universal Unique ID)</li><li>with entry length 4</li><li>queue entry format <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>SQL code </td><td>bin(4) </td><td>SQL code  </td></tr>
<tr>
<td>4 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
CL command to create the DTAQs <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/ISQL) MAXLEN(256) SEQ(*KEYED) KEYLEN(16) TEXT('Request Data Queue for ISQL')
CRTDTAQ DTAQ(LSBIN/ISQLR) MAXLEN(4) SEQ(*KEYED) KEYLEN(16) TEXT('Reply Data Queue for ISQL')
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_sync_2">
6.4.2. Write the CL Command - ISQL</a></h3>
Source code of CL command ISQL, <a href="src/isql.cmd">isql.cmd</a> <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE ISQL.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(256) MIN(1) +
                          INLPMTLEN(50) PROMPT('SQL statement')
<span class="comment">/* EOF */</span>
</pre></div><p>
Compile CL command ISQL <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/ISQL) PGM(*LIBL/ISQLCPP) SRCFILE(LS2008/DEC)
  SRCMBR(*CMD) TEXT('i can sql')
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_sync_3">
6.4.3. Write the Command Processing Program - ISQLCPP</a></h3>
Source code of ILE RPG program ISQLCPP, <a href="src/isqlcpp.rpgle">isqlcpp.rpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlcpp.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * commmand processing program for CL command ISQL</span>
<span class="comment">      */</span>

     h dftactgrp(*no)

     d i_main          pr                  extpgm('ISQLCPP')
     d   sql                        256a
     d   sqlcod                      10i 0 options(*nopass)

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* input checking procedure */</span>
     d input_check     pr              n

     <span class="comment">/*</span>
<span class="comment">      * do_request</span>
<span class="comment">      *  - send SQL request to server program ISQLSVR</span>
<span class="comment">      *  - receive the SQLCOD returned by ISQLSVR</span>
<span class="comment">      *  - report result message to the user</span>
<span class="comment">      *</span>
<span class="comment">      * @pre sql</span>
<span class="comment">      * @return sqlcod</span>
<span class="comment">      */</span>
     d do_request      pr            10i 0

     <span class="comment">/* send message to interactive user */</span>
     d sendmsg         pr
     d   msg                        256a

     d i_main          pi
     d   sql                        256a
     d   sqlcod                      10i 0 options(*nopass)

     d msg             s            256a
     d rtn             s             10i 0

      /free

          if input_check();
              rtn = do_request();
          endif;

          sendmsg(msg);

          <span class="comment">// return SQLCOD to the caller when parameter sqlcod is specified</span>
          if %parms() &gt; 1;
              sqlcod = rtn;
          endif;

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - i_main() */</span>

     <span class="comment">/* procedure input_check() */</span>
     p input_check     b
     d input_check     pi              n

      /free
          if sql = *blanks;
              msg = 'Empty SQL statement';
              return *off;
          endif;

          return *on;
      /end-free
     p input_check     e

     <span class="comment">/* procedure do_request() */</span>
     p do_request      b

     d q_entry         ds                  qualified
     d   sql                        256a
     d   sqlcod                      10i 0
     d   ch_sqlcod                    4a   overlay(sqlcod)

     d uuid_template   ds                  qualified
     d   bytes_in                    10u 0 inz(32)
     d   bytes_out                   10u 0
     d   reserved                     8a   inz(x'0000000000000000')
     d   uuid                        16a

     d genuuid         pr                  extproc('_GENUUID')
     d   template                      *   value

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm('QSNDDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm('QRCVDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     d qname           s             10a
     d qlib            s             10a   inz('*LIBL')
     d entry_len       s              5p 0
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('EQ')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(16)
     d key             s             16a
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d ec              ds                  likeds(qusec_t)

     d do_request      pi            10i 0
      /free

          <span class="comment">// generate UUID</span>
          genuuid(%addr(uuid_template));

          <span class="comment">// enqueue DTAQ ISQL</span>
          entry_len = 256;
          qname = 'ISQL';
          q_entry.sql = sql;
          qsnddtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.sql
                   : key_len
                   : uuid_template.uuid );

          <span class="comment">// dequeue DTAQ ISQL</span>
          clear ec;
          ec.bytes_in = 256;
          qname = 'ISQLR';
          entry_len = 4;
          qrcvdtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.ch_sqlcod
                   : timeout
                   : key_order
                   : key_len
                   : uuid_template.uuid
                   : sender_info_len
                   : sender_info );
          if ec.bytes_out &lt;&gt; 0;
              msg = 'QRCVDTAQ() failed with exception ID: '
                       + ec.exid;
              return -9999;
          endif;

          <span class="comment">// set msg according to returned SQLCOD</span>
          if q_entry.sqlcod &lt; 0;
              msg = 'SQL statement failed with SQLCOD '
                       + %<span class="keywordtype">char</span>(q_entry.sqlcod);
          elseif q_entry.sqlcod &gt; 0;
              msg = 'SQL statement succeeded with SQLCOD '
                       + %<span class="keywordtype">char</span>(q_entry.sqlcod);
          else;
              msg = 'SQL statement succeeded';
          endif;

          return q_entry.sqlcod;
      /end-free
     p do_request      e

     <span class="comment">/* procedure sendmsg() */</span>
     p sendmsg         b

     <span class="comment">/* prototype of QMHSNDPM */</span>
     d qmhsndpm        pr                  extpgm('QMHSNDPM')
     d   msgid                        7a
     d   msgf                        20a
     d   msgdata                    512a   options(*varsize)
     d   msgdata_len                 10i 0
     d   msgtype                     10a
     d   callstack_...
     d     entry                     10a
     d   callstack_...
     d     counter                   10i 0
     d   msgkey                       4a
     d   ec                                likeds(qusec_t)

     d sendmsg         pi
     d   msg                        256a

     d msgid           s              7a   inz('CPF9898')
     d msgf            s             20a   inz('QCPFMSG   QSYS')
     d msgdata_len     s             10i 0
     d msgtype         s             10a   inz('*INFO')
     d callstack_...
     d   entry         s             10a   inz('*PGMBDY')
     d callstack_...
     d   counter       s             10i 0 inz(1)
     d msgkey          s              4a
     d ec              ds                  likeds(qusec_t)

     d cmd             s            512a
     d len             s             15p 5

      /free

          ec.bytes_in = 256;

          msgdata_len = %len(%trim(msg));
          qmhsndpm(  msgid
                   : msgf
                   : msg
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

      /end-free
     p sendmsg         e

     <span class="comment">/* eof - isqlcpp.rpgle */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_sync_4">
6.4.4. Write the Request Porcessing Program - ISQLSVR</a></h3>
Source code of ILE SQLRPG program ISQLSVR, <a href="src/isqlsvr.sqlrpgle">isqlsvr.sqlrpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlsvr.sqlrpgle</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from DTAQ ISQL</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      */</span>
     <span class="comment">/* to use activation group scope commitment control */</span>
     h dftactgrp(*no) actgrp('ISQLSVR')

     <span class="comment">/*</span>
<span class="comment">      * procedure server_client</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from DTAQ ISQL</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      *</span>
<span class="comment">      * @return boolean, *off if the main procedure should quit.</span>
<span class="comment">      */</span>
     d serve_client    pr              n

     <span class="comment">/*</span>
<span class="comment">      * procedure run_sql()</span>
<span class="comment">      *</span>
<span class="comment">      * @return SQLCOD</span>
<span class="comment">      */</span>
     d run_sql         pr            10i 0
     d   sql                        256a   options(*varsize)

      /free

          dow serve_client();
          enddo;

          *inlr = *on;
      /end-free
     p serve_client    b

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm('QSNDDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm('QRCVDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     d qname           s             10a
     d qlib            s             10a   inz('*LIBL')
     d entry_len       s              5p 0
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('GE')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(16)
     d key             s             16a
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d ec              ds                  likeds(qusec_t)

     d q_entry         ds                  qualified
     d   sql                        256a
     d   sqlcod                      10i 0
     d   ch_sqlcod                    4a   overlay(sqlcod)

     d uuid            s             16a
     d msg             s             26a
     d rtn             s              1a
     d QUIT_CMDS       c                   'q Q qu QU quit QUITT'
     d KEY_ARG         c                   x'00000000000000000000000000000000'

     d serve_client    pi              n
      /free

          rtn = *on;

          <span class="comment">// dequeue client request from DTAQ ISQL</span>
          clear ec;
          ec.bytes_in = 256;
          qname = 'ISQL';
          entry_len = 256;
          uuid = KEY_ARG;
          qrcvdtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.sql
                   : timeout
                   : key_order
                   : key_len
                   : uuid
                   : sender_info_len
                   : sender_info );
          if ec.bytes_out &lt;&gt; 0;
              <span class="comment">// error handling</span>
              msg = 'QRCVDTAQ failed: '
                       + ec.exid;
              dsply 'Error' '' msg;
              return *off;
          endif;

          <span class="comment">// should i quit?</span>
          if %scan(%trim(q_entry.sql) : QUIT_CMDS) &gt; 0;
              rtn = *off;
          else;
              <span class="comment">// run sql statement</span>
              q_entry.sqlcod = run_sql(q_entry.sql);
          endif;

          <span class="comment">// enqueue reply to DTAQ ISQLR</span>
          entry_len = 4;
          qname = 'ISQLR';
          qsnddtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.ch_sqlcod
                   : key_len
                   : uuid );

          return rtn;
      /end-free
     p serve_client    e

     p run_sql         b
     d run_sql         pi            10i 0
     d   sql                        256a   options(*varsize)

     c/exec sql prepare stmt from :sql
     c/end-exec
     c                   if        sqlcod &lt; 0
     c                   return    sqlcod
     c                   endif
     c/exec sql execute stmt
     c/end-exec

     c                   return    sqlcod
     p run_sql         e
     <span class="comment">/* eof - isqlsvr.sqlrpgle</span>
</pre></div><p>
Compile ISQLSVR <div class="fragment"><pre class="fragment">CRTSQLRPGI OBJ(LSBIN/ISQLSVR) SRCFILE(LS2008/DEC)
           SRCMBR(*OBJ) COMMIT(*CS)
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that ISQLSVR uses activation group level commit control. Thus, one must set parameter COMMIT to a value other than *NONE.</dd></dl>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_sync_5">
6.4.5. Run ISQLSVR and ISQL</a></h3>
Submit the ISQL server job <div class="fragment"><pre class="fragment">SBMJOB CMD(CALL PGM(ISQLSVR))
</pre></div><p>
Start journaling physical file PF16 <div class="fragment"><pre class="fragment">STRJRNPF FILE(PF16) JRN(JRN01) IMAGES(*BOTH)
</pre></div><p>
Clear physical file PF16 <div class="fragment"><pre class="fragment">CLRPFM FILE(PF16)
</pre></div><p>
Use DELETE statement on PF16 <div class="fragment"><pre class="fragment">ISQL SQL(<span class="stringliteral">'delete from pf16'</span>)
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">SQL statement succeeded with SQLCOD 100.</span>
<span class="comment">*/</span>
</pre></div><p>
Use INSERT statement of PF16 <div class="fragment"><pre class="fragment">ISQL SQL(<span class="stringliteral">'insert into pf16 values('</span><span class="stringliteral">'Field 1'</span><span class="stringliteral">', '</span><span class="stringliteral">'Field 2'</span><span class="stringliteral">', '</span><span class="stringliteral">'Field 3'</span><span class="charliteral">')'</span>)
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">SQL statement succeeded.</span>
<span class="comment">*/</span>
</pre></div><p>
Use DSPJOB command to heck commitment control information of the server job <div class="fragment"><pre class="fragment">DSPJOB JOB(257356/LJL/LJL_DAILY) OPTION(*CMTCTL)
<span class="comment">/* Replace the job ID with your server job's job ID. */</span>
</pre></div><p>
Currently the server job has an activiation group level commitment control. <div class="fragment"><pre class="fragment">        Commitment                           
Opt     Definition     Text                  
        ISQLSVR        Activation-group-level
</pre></div> And there's one pending record level change under the activation group level commitment control. <div class="fragment"><pre class="fragment">Job:   LJL_DAILY      User:   LJL            Number:   257356         
                                                                      
Commitment definition  . . . . . . . . :   ISQLSVR                    
                                                                      
                                    -------------Changes--------------
File        Library     Member          Commit    Rollback     Pending
PF16        LSBIN       PF16                 0           0           0
                        PF16                 0           0           1
</pre></div><p>
Commit changes to PF16 <div class="fragment"><pre class="fragment">ISQL SQL(<span class="stringliteral">'commit'</span>)
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">SQL statement succeeded.</span>
<span class="comment">*/</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_sync_6">
6.4.6. Write CL command RUNSQL</a></h3>
CL command ISQL should not be used in CL programs or REXX scripts, since it does not return the result SQL code. Here is another version of command ISQL, RUNSQL which returns the result SQL code and can only be used in CL programs or REXX scripts. In CL programs or REXX scripts, with the returned SQL code, we can determine what to do next such as to rollback all previous changes to database tables.<p>
Source code of CL command RUNSQL, <a href="src/runsql.cmd">runsql.cmd</a> <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE RUNSQL.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(256) MIN(1) +
                          INLPMTLEN(50) PROMPT('SQL statement')
             PARM       KWD(SQLCOD) TYPE(*CHAR) LEN(4) RTNVAL(*YES) +
                          MIN(1) PROMPT('SQLCOD returned')
<span class="comment">/* EOF */</span>
</pre></div><p>
Compile CL command RUNSQL <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/RUNSQL) PGM(*LIBL/ISQLCPP) SRCFILE(LS2008/DEC)
       ALLOW(*BPGM *IPGM *BREXX *IREXX) <span class="comment">/* Do NOT invoke me interactively. */</span>
</pre></div><p>
OPM CL program <a href="src/cl103.clp">CL103</a> invoke CL command RUNSQL like the following. <div class="fragment"><pre class="fragment">             <span class="comment">/* @FILE CL103.CLP */</span>
PGM
             DCL        VAR(&amp;SQLCOD) TYPE(*CHAR) LEN(4)
 RUN_SQL:    RUNSQL     SQL('delete from pf16') SQLCOD(&amp;SQLCOD) <span class="comment">/* +</span>
<span class="comment">                          clear PF16 */</span>
             RUNSQL     SQL('insert into PF16 values(''A'', ''B'', +
                          ''C'')') SQLCOD(&amp;SQLCOD) <span class="comment">/* insert new +</span>
<span class="comment">                          records */</span>
             IF         COND(%BIN(&amp;SQLCOD) *LT 0) THEN(DO)
             SNDPGMMSG  MSG('SQL operations failed.') +
                          TOMSGQ(*TOPGMQ) MSGTYPE(*INFO)
             RUNSQL     SQL('rollback') SQLCOD(&amp;SQLCOD) <span class="comment">/* rollbak +</span>
<span class="comment">                          when insert operation failed */</span>
             GOTO       CMDLBL(END)
             ENDDO

             RUNSQL     SQL('commit') SQLCOD(&amp;SQLCOD) <span class="comment">/* commit */</span>

 END:        ENDPGM
<span class="comment">/* EOF - CL103.CLP */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_pointer">
6.5. Pass Variable Length Data through i5/OS Queue Objects</a></h3>
In the ISQL example in <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync">6.4. Simulate Synchronous Calls by i5/OS Queue Objects</a>, the length of the request SQL statement is limited to the length of request queue entry. Although we can enlarge the queue entry length, but the longer the queue entry length is the more storage will be wasted when short SQL statement are put on the request queue. Obviously, to solve this problem we need to pass variable length data through i5/OS queue objects.<p>
In section <a class="el" href="page_using_q_en.html#en_sect_using_q_intro">2. An Introduction to Queue Objects on i5/OS</a> we have metioned an attribute of i5/OS queue objects: whether message data taken off the queue can contain pointers. Pointers we talked here are MI pointers, such as space pointers, data pointers, system pointers, etc. A space pointer is used to describe addressibility of data items. As an MI pointer, a space pointer contains common pointer attributes such as pointer type and tag bits and specific attributes such as the offset portion. One can roughly equate a space pointer with an i5/OS HLL data pointer. To pass variable length data through a queue object, we need to:<ul>
<li>create an queue object which can contain pointers in its message data</li><li>allocate storage for variable length data in one program, then get the space pointer that addresses to the allocated storage and enqueue the space pointer to the queue object</li><li>dequeue the space pointer from the queue object in a program who consume the variable length data, then access the variable length data through the space pointer</li></ul>
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Program who enqueue a space pointer to a queue object must ensure the storage that the space pointer points to not be released until the program who consumes the storage does not need it any more. <p>
Structures that contains pointers must align to 16 bytes boundary. <p>
IBM does not provide any interface to create data queue object that can contain pointers. Thus when we need to pass pointers through a queue object, we can only choose a user queue object. <p>
One can pass other type of pointers through a queue object. For example by passing a system pointer to a program object through a queue object, we can let a request processing program run business logics without caring about what program it's running.</dd></dl>
Here we make an enhancement for program ISQL introduced in section <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_sync">6.4. Simulate Synchronous Calls by i5/OS Queue Objects</a> to eliminate the limitation on length of SQL statements. We call the enhanced version ISQL2.<p>
<b>Components of ISQL2</b><br>
<ul>
<li>Request queue: user queue ISQL2</li><li>Reply queue: user queue ISQLR2</li><li>CL command ISQL2: accepts user input and invokes command processing program ISQLCPP2</li><li>CL command RUNSQL2: accepts user input, invokes command processing program ISQLCPP2, and returns the result SQL code. This command can be used in CL programs or REXX scripts.</li><li>Command processing program ISQLCPP2. ISQLCPP2 enqueues a space pointer of a SQL statement to the request queue, then dequeues returned SQL code from the reply queue.</li><li>Request processing program ISQLSVR2. ISQLSVR2 dequeues space pointers of each request SQL statement, retrieves SQL statement data, runs it, and enqueues the result SQL code to the reply queue.</li></ul>
<p>
Steps<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_1">6.5.1. Create USRQ ISQL2 and ISQLR2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_2">6.5.2. Write CL command - ISQL2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_3">6.5.3. Write Commnad Processing Program ISQLCPP2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_4">6.5.4. Write the Server Program ISQLSVR2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_5">6.5.5. Write CL Command RUNSQL2</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer_6">6.5.6. Run ISQLSVR2 and ISQL2</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_pointer_1">
6.5.1. Create USRQ ISQL2 and ISQLR2</a></h3>
The request USRQ ISQL2<ul>
<li>of type keyed</li><li>with key length 16 to hold 16 bytes UUID</li><li>with entry length 16 to hold a space pointer</li><li>queue entry format <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>Pointer to SQL statement </td><td>SPCPTR </td><td>Pointer to SQL statement data  </td></tr>
<tr>
<td>16 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
The reply USRQ ISQLR2<ul>
<li>of type keyed</li><li>with key length 16 to hold 16 bytes UUID</li><li>with entry length 4 to hold a SQL code</li><li>queue entry format <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>SQL code </td><td>bin(4) </td><td>SQL code  </td></tr>
<tr>
<td>4 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
CL command to create the USRQs <div class="fragment"><pre class="fragment"><span class="comment">/* The request USRQ ISQL2 */</span>
CALL PGM(QUSCRTUQ) PARM(
     'ISQL2     LSBIN'   <span class="comment">/* USRQ name */</span>
     'QQ'                <span class="comment">/* extended attribute */</span>
     'K'                 <span class="comment">/* queue type */</span>
     X'00000010'         <span class="comment">/* key length */</span>
     X'00000010'         <span class="comment">/* entry length */</span>
     X'00000010'         <span class="comment">/* initial number of messages */</span>
     X'00000010'         <span class="comment">/* number of messages per extension */</span>
     '*EXCLUDE'          <span class="comment">/* public authority */</span>
     'ISQL request queue. key length = 16, entry length = 16' <span class="comment">/* text description */</span>
     '*YES'              <span class="comment">/* replace */</span>
     X'0000002000000000000000000000000000000000000000000000000000000000' <span class="comment">/* error code structure */</span>
     '*USER'             <span class="comment">/* object domain */</span>
     '*YES')             <span class="comment">/* contains poniter */</span>

<span class="comment">/* The reply USRQ ISQLR2 */</span>
CALL PGM(QUSCRTUQ) PARM(
     'ISQLR2    LSBIN'   <span class="comment">/* USRQ name */</span>
     'QQ'                <span class="comment">/* extended attribute */</span>
     'K'                 <span class="comment">/* queue type */</span>
     X'00000010'         <span class="comment">/* key length */</span>
     X'00000004'         <span class="comment">/* entry length */</span>
     X'00000010'         <span class="comment">/* initial number of messages */</span>
     X'00000010'         <span class="comment">/* number of messages per extension */</span>
     '*EXCLUDE'          <span class="comment">/* public authority */</span>
     'ISQL reply queue. key length = 16, entry length = 4') <span class="comment">/* text description */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_pointer_2">
6.5.2. Write CL command - ISQL2</a></h3>
Source code of CL command ISQL2 <a href="src/isql2.cmd">isql2.cmd</a> <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE ISQL.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(256) MIN(1) +
                          INLPMTLEN(50) PROMPT('SQL statement')
<span class="comment">/* EOF */</span>
</pre></div><p>
Compile CL command ISQL2 <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/ISQL2) PGM(*LIBL/ISQLCPP2) SRCFILE(LS2008/DEC)
       SRCMBR(*CMD) TEXT('i can sql too :p')
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_pointer_3">
6.5.3. Write Commnad Processing Program ISQLCPP2</a></h3>
Source code of ILE RPG program <a href="src/isqlcpp2.rpgle">isqlcpp2.rpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlcpp2.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     d sql_param_t     ds                  qualified
     d   sql_len                     10i 0
     d   sql                      32767a

     d i_main          pr                  extpgm('ISQLCPP2')
     d   sql_parm                          likeds(sql_param_t)
     d   sqlcod                      10i 0 options(*nopass)

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/*</span>
<span class="comment">      * do_request</span>
<span class="comment">      *  - send SQL request to server program ISQLSVR2</span>
<span class="comment">      *  - receive the SQLCOD returned by ISQLSVR2</span>
<span class="comment">      *  - report result message to the user</span>
<span class="comment">      *</span>
<span class="comment">      * @pre sql</span>
<span class="comment">      * @return sqlcod</span>
<span class="comment">      */</span>
     d do_request      pr            10i 0

     <span class="comment">/* send message to interactive user */</span>
     d sendmsg         pr
     d   msg                        256a

     <span class="comment">/*</span>
<span class="comment">      * prototype of procedure resolve_qs</span>
<span class="comment">      * @return boolean, *on if both the request USRQ and the reply</span>
<span class="comment">      *         USRQ are resolved.</span>
<span class="comment">      */</span>
     d resolve_qs      pr              n

     <span class="comment">/* request USRQ ISQL2 */</span>
     d request_q       s               *

     <span class="comment">/* reply USRQ ISQLR2 */</span>
     d reply_q         s               *

     d msg             s            256a
     d rtn             s             10i 0

     d i_main          pi
     d   sql_parm                          likeds(sql_param_t)
     d   sqlcod                      10i 0 options(*nopass)

      /free

          <span class="comment">// resolve request q, reply q</span>
          if resolve_qs();
              rtn = do_request();
          endif;

          sendmsg(msg);

          <span class="comment">// return SQLCOD to the caller when parameter sqlcod is specified</span>
          if %parms() &gt; 1;
              sqlcod = rtn;
          endif;

          *inlr = *on;
      /end-free

     <span class="comment">/* procedure resolve_qs() */</span>
     p resolve_qs      b
     <span class="comment">/* prototype of MI instruction RSLVSP */</span>
     d rslvsp          pr                  extproc('_RSLVSP2')
     d   syp                           *
     d   option                        *   value

     d resolve_option  ds            34    qualified
     d   type                         2a   inz(x'0A02')
     d   name                        30a
     d   auth                         2a   inz(x'0000')

     d rtn             s               n

     d resolve_qs      pi              n
      /free

          rtn = *on;

          <span class="comment">// resolve request q, reply q</span>
          monitor;   <span class="comment">// monitor MCH3401</span>
              resolve_option.name = 'ISQL2';
              rslvsp(request_q : %addr(resolve_option));
              resolve_option.name = 'ISQLR2';
              rslvsp(reply_q : %addr(resolve_option));
          on-error;
              msg = 'Failed to resolve request user queue' +
                    ' or reply user queue';
              rtn = *off;
          endmon;

          return rtn;
      /end-free
     p resolve_qs      e

     <span class="comment">/* procedure do_request() */</span>
     p do_request      b

     d uuid_template   ds                  qualified
     d   bytes_in                    10u 0 inz(32)
     d   bytes_out                   10u 0
     d   reserved                     8a   inz(x'0000000000000000')
     d   uuid                        16a

     d genuuid         pr                  extproc('_GENUUID')
     d   template                      *   value

     <span class="comment">/* prototype of MI instruction ENQ */</span>
     d enq             pr                  extproc('_ENQ')
     d   q                             *
     d   prefix                        *   value
     d   text                          *   value

     <span class="comment">/* prototype of MI instruction DEQ */</span>
     d deq             pr                  extproc('_DEQWAIT')
     d   prefix                        *   value
     d   text                          *   value
     d   q                             *

     <span class="comment">/* enq prefix */</span>
     d enq_prefix      ds            20    qualified
     d   text_len                    10i 0
     d   key                         16a

     <span class="comment">/* deq prefix */</span>
     d deq_prefix      ds            53    qualified
     d   enqueue_time                 8a
     d   timeout                      8a
     d   text_len                    10i 0
     d   acc_sts_mod                  1a   inz(x'D8')                           <span class="comment">/* deq infinitely */</span>
     d   key_in                      16a
     d   key_out                     16a

     <span class="comment">/* request data */</span>
     d request         ds                  qualified
     d   sql_len                     10u 0
     d   reserved                     8a                                        <span class="comment">/* align to 16 bytes boundary */</span>
     d   sql_ptr                       *
     d request_ptr     s               *   inz(%addr(request))

     <span class="comment">/* reply message from ISQLSVR2 */</span>
     d reply           ds            16    qualified
     d   sqlcod                      10i 0

     d do_request      pi            10i 0

      /free

          <span class="comment">// generate UUID</span>
          genuuid(%addr(uuid_template));

          <span class="comment">// enqueue SQL statement to USRQ ISQL2</span>
          enq_prefix.text_len = 16;
          enq_prefix.key = uuid_template.uuid;
          request.sql_len = sql_parm.sql_len;
          request.sql_ptr = %addr(sql_parm.sql);
          enq(request_q : %addr(enq_prefix) : %addr(request_ptr));

          <span class="comment">// dequeue SQLCOD from USRQ ISQLR2</span>
          deq_prefix.key_in = uuid_template.uuid;
          deq(%addr(deq_prefix) : %addr(reply) : reply_q);

          <span class="comment">// set msg according to returned SQLCOD</span>
          if reply.sqlcod &lt; 0;
              msg = 'SQL statement failed with SQLCOD '
                       + %<span class="keywordtype">char</span>(reply.sqlcod);
          elseif reply.sqlcod &gt; 0;
              msg = 'SQL statement succeeded with SQLCOD '
                       + %<span class="keywordtype">char</span>(reply.sqlcod);
          else;
              msg = 'SQL statement succeeded';
          endif;

          return reply.sqlcod;
      /end-free
     p do_request      e

     <span class="comment">/* procedure sendmsg() */</span>
     p sendmsg         b

     <span class="comment">/* prototype of QMHSNDPM */</span>
     d qmhsndpm        pr                  extpgm('QMHSNDPM')
     d   msgid                        7a
     d   msgf                        20a
     d   msgdata                    512a   options(*varsize)
     d   msgdata_len                 10i 0
     d   msgtype                     10a
     d   callstack_...
     d     entry                     10a
     d   callstack_...
     d     counter                   10i 0
     d   msgkey                       4a
     d   ec                                likeds(qusec_t)

     d msgid           s              7a   inz('CPF9898')
     d msgf            s             20a   inz('QCPFMSG   QSYS')
     d msgdata_len     s             10i 0
     d msgtype         s             10a   inz('*INFO')
     d callstack_...
     d   entry         s             10a   inz('*PGMBDY')
     d callstack_...
     d   counter       s             10i 0 inz(1)
     d msgkey          s              4a
     d ec              ds                  likeds(qusec_t)

     d cmd             s            512a
     d len             s             15p 5

     d sendmsg         pi
     d   msg                        256a

      /free

          clear ec;
          ec.bytes_in = 256;

          msgdata_len = %len(%trim(msg));
          qmhsndpm(  msgid
                   : msgf
                   : msg
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

      /end-free
     p sendmsg         e

     <span class="comment">/* eof - isqlcpp2.rpgle */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_pointer_4">
6.5.4. Write the Server Program ISQLSVR2</a></h3>
Source code of ILE SQLRPG program <a href="src/isqlsvr2.sqlrpgle">isqlsvr2.sqlrpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlsvr.sqlrpgle</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from USRQ ISQL2</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      */</span>
     <span class="comment">/* to use activation group scope commitment control */</span>
     h dftactgrp(*no) actgrp('ISQLSVR2')

     <span class="comment">/*</span>
<span class="comment">      * prototype of procedure resolve_qs</span>
<span class="comment">      * @return boolean, *on if both the request USRQ and the reply</span>
<span class="comment">      *         USRQ are resolved.</span>
<span class="comment">      */</span>
     d resolve_qs      pr              n

     <span class="comment">/*</span>
<span class="comment">      * procedure server_client</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from USRQ ISQL2</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      *</span>
<span class="comment">      * @return boolean, *off if the main procedure should quit.</span>
<span class="comment">      */</span>
     d serve_client    pr              n

     <span class="comment">/*</span>
<span class="comment">      * procedure run_sql()</span>
<span class="comment">      *</span>
<span class="comment">      * @return SQLCOD</span>
<span class="comment">      */</span>
     d run_sql         pr            10i 0
     d   the_sql                   5000a   options(*varsize)

     <span class="comment">/* request USRQ ISQL2 */</span>
     d request_q       s               *
     <span class="comment">/* reply USRQ ISQLR2 */</span>
     d reply_q         s               *
     d msg             s             26a

      /free

          <span class="comment">// resolve request q and reply q</span>
          if not resolve_qs();
              msg = 'Failed to resolve user queues';
              dsply '' '' msg;
              *inlr = *on;
              return;
          endif;

          <span class="comment">// serves client</span>
          dow serve_client();
          enddo;

          *inlr = *on;
      /end-free

     <span class="comment">/* procedure resolve_qs() */</span>
     p resolve_qs      b
     <span class="comment">/* prototype of MI instruction RSLVSP */</span>
     d rslvsp          pr                  extproc('_RSLVSP2')
     d   syp                           *
     d   option                        *   value

     d resolve_option  ds            34    qualified
     d   type                         2a   inz(x'0A02')
     d   name                        30a
     d   auth                         2a   inz(x'0000')

     d rtn             s               n

     d resolve_qs      pi              n
      /free

          rtn = *on;

          <span class="comment">// resolve request q, reply q</span>
          monitor;
              resolve_option.name = 'ISQL2';
              rslvsp(request_q : %addr(resolve_option));
              resolve_option.name = 'ISQLR2';
              rslvsp(reply_q : %addr(resolve_option));
          on-error;
              msg = 'Failed to resolve request user queue' +
                    ' or reply user queue';
              rtn = *off;
          endmon;

          return rtn;
      /end-free
     p resolve_qs      e

     p serve_client    b
     <span class="comment">/* prototype of MI instruction ENQ */</span>
     d enq             pr                  extproc('_ENQ')
     d   q                             *
     d   prefix                        *   value
     d   text                          *   value

     <span class="comment">/* prototype of MI instruction DEQ */</span>
     d deq             pr                  extproc('_DEQWAIT')
     d   prefix                        *   value
     d   text                          *   value
     d   q                             *

     <span class="comment">/* enq prefix */</span>
     d enq_prefix      ds            20    qualified
     d   text_len                    10i 0
     d   key                         16a

     <span class="comment">/* deq prefix */</span>
     d deq_prefix      ds            53    qualified
     d   enqueue_time                 8a
     d   timeout                      8a
     d   text_len                    10i 0
     d   acc_sts_mod                  1a   inz(x'DA')                           <span class="comment">/* deq infinitely, key relation:'GE' */</span>
     d   key_in                      16a
     d   key_out                     16a

     <span class="comment">/* request data */</span>
     d request         ds                  qualified
     d                                     based(request_ptr)
     d   sql_len                     10u 0
     d   reserved                     8a                                        <span class="comment">/* align to 16 bytes boundary */</span>
     d   sql_ptr                       *
     d request_ptr     s               *
     d sql_str         ds                  based(request.sql_ptr)
     d                                     qualified
     d   <span class="keywordtype">string</span>                   32767a

     <span class="comment">/* reply message to ISQLCPP2 */</span>
     d reply           ds            16    qualified
     d   sqlcod                      10i 0

     d quit_cmd        s              4a
     d rtn             s               n
     d QUIT_CMDS       c                   'q Q qu QU quit QUITT'
     d MIN_KEY_VALUE   c                   x'00000000000000000000000000000000'  <span class="comment">/* 16 bytes */</span>
     d sql             s          32767a

     d serve_client    pi              n

      /free

          rtn = *on;

          <span class="comment">// dequeue client's request from USRQ ISQL2</span>
          deq_prefix.text_len = 16;
          deq_prefix.key_in = MIN_KEY_VALUE;
          deq(%addr(deq_prefix) : %addr(request_ptr) : request_q);

          <span class="comment">// run sql statement</span>
          sql = %subst(sql_str.<span class="keywordtype">string</span> : 1 : request.sql_len);
          quit_cmd = %subst(sql : 1 : 4);
          if %scan(%trim(quit_cmd) : QUIT_CMDS) &gt; 0;
              rtn = *off;
          else;
              reply.sqlcod = run_sql(sql);
          endif;

          <span class="comment">// enqueue reply message to USRQ ISQLR2</span>
          enq_prefix.text_len = 4;
          enq_prefix.key = deq_prefix.key_out;
          enq(reply_q : %addr(enq_prefix) : %addr(reply));

          return rtn;
      /end-free
     p serve_client    e

     p run_sql         b
     d run_sql         pi            10i 0
     d   the_sql                   5000a   options(*varsize)

     c/exec sql prepare stmt from :the_sql
     c/end-exec
     c                   if        sqlcod &lt; 0
     c                   return    sqlcod
     c                   endif
     c/exec sql execute stmt
     c/end-exec

     c                   return    sqlcod
     p run_sql         e

     <span class="comment">/* eof - isqlsrv2.sqlrpgle */</span>
</pre></div><p>
Compile <a href="src/isqlsvr2.sqlrpgle">isqlsvr2.sqlrpgle</a> <div class="fragment"><pre class="fragment">CRTSQLRPGI OBJ(LSBIN/ISQLSVR2) SRCFILE(LS2008/DEC)
           SRCMBR(*OBJ) COMMIT(*CS)
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that ISQLSVR2 uses activation group level commit control. Thus, one must set parameter COMMIT to a value other than *NONE.</dd></dl>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_pointer_5">
6.5.5. Write CL Command RUNSQL2</a></h3>
Source code <a href="src/runsql2.cmd">runsql2.cmd</a> <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE RUNSQL2.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(5000) MIN(1) +
                          VARY(*YES *INT4) INLPMTLEN(50) +
                          PROMPT('SQL statement')
             PARM       KWD(SQLCOD) TYPE(*CHAR) LEN(4) RTNVAL(*YES) +
                          MIN(1) PROMPT('SQLCOD returned')
<span class="comment">/* EOF */</span>
</pre></div><p>
Compile CL command RUNSQL2 <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/RUNSQL2) PGM(*LIBL/ISQLCPP2) SRCFILE(LS2008/DEC)
       ALLOW(*BPGM *IPGM *BREXX *IREXX) <span class="comment">/* allow RUNSQL2 to be invoked</span>
<span class="comment">                                           from interactive or batch CL</span>
<span class="comment">                                           programs or REXX scripts */</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_pointer_6">
6.5.6. Run ISQLSVR2 and ISQL2</a></h3>
Prepare an OPM CL program who makes use of CL command RUNSQL2, <a href="src/cl104.clp">cl104.clp</a> <div class="fragment"><pre class="fragment">             <span class="comment">/* @FILE CL104.CLP */</span>
PGM
             DCL        VAR(&amp;SQLCOD) TYPE(*CHAR) LEN(4)
 RUN_SQL:    RUNSQL2    SQL('delete from pf16') SQLCOD(&amp;SQLCOD) <span class="comment">/* +</span>
<span class="comment">                          clear PF16 */</span>
             RUNSQL2    SQL('insert into PF16 values(''A'', ''B'', +
                          ''C'')') SQLCOD(&amp;SQLCOD) <span class="comment">/* insert new +</span>
<span class="comment">                          records */</span>
             IF         COND(%BIN(&amp;SQLCOD) *LT 0) THEN(DO)
             SNDPGMMSG  MSG('SQL operations failed.') +
                          TOMSGQ(*TOPGMQ) MSGTYPE(*INFO)
             RUNSQL2    SQL('rollback') SQLCOD(&amp;SQLCOD) <span class="comment">/* rollbak +</span>
<span class="comment">                          when insert operation failed */</span>
             GOTO       CMDLBL(END)
             ENDDO

             RUNSQL2    SQL('commit') SQLCOD(&amp;SQLCOD) <span class="comment">/* commit */</span>

 END:        ENDPGM
<span class="comment">/* EOF - CL104.CLP */</span>
</pre></div><p>
Compile CL104 <div class="fragment"><pre class="fragment">CRTCLPGM PGM(LSBIN/CL104) SRCFILE(LS2008/DEC)
         LOG(*YES)  <span class="comment">/* enable logging of CL commands being called */</span>
</pre></div><p>
Use CL command ISQL2 and CL program CL104 to operate physical file PF16. <div class="fragment"><pre class="fragment"><span class="comment">/* Submit the server job */</span>
SBMJOB CMD(CALL PGM(ISQLSVR2))

<span class="comment">/* Clear PF16 */</span>
ISQL2 SQL('delete from pf16')
ISQL2 SQL('commit')

<span class="comment">/* Run CL104 */</span>
CALL CL104                                                          
   400 - RUNSQL2 SQL('delete from pf16') SQLCOD(&amp;SQLCOD)            
SQL statement succeeded with SQLCOD 100.                            
   600 - RUNSQL2 SQL('insert into PF16 values(''A'', ''B'', ''C'')')
  SQLCOD(&amp;SQLCOD)                                                   
SQL statement succeeded.                                            
  1700 - RUNSQL2 SQL('commit') SQLCOD(&amp;SQLCOD)                      
SQL statement succeeded.                                            
       - RETURN        <span class="comment">/* RETURN due to end of CL program */</span>        

<span class="comment">/* Notify the server job to quit */</span>
ISQL2 SQL('qu')
</pre></div> <dl class="attention" compact><dt><b>Attention:</b></dt><dd>Make sure that the physical file has been journaled.</dd></dl>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_java">
6.6. Java and i5/OS Queue objects</a></h3>
Java programs running on i5/OS can take advantage of i5/OS queue objects when they need to communicate with host lanuguage programs or other Java programs. <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzahh/page1.htm">IBM Toolbox for Java</a> provides access methods of DTAQs for Java. With <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzahh/page1.htm">IBM Toolbox for Java</a>'s client version jt400.jar or its host version jt400Native.jar a Java program can access a DTAQ object either remotely from a client PC or locally on the host server. Refer to <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzahh/TW/javadoc/com/ibm/as400/access/BaseDataQueue.html">BaseDataQueue</a> and its derived classes for details. IBM does not provide interfaces to access USRQs for Java. To access a USRQ object in Java, one will have to implement native methods which operate on USRQs on behalf of Java programs.<p>
On i5/OS, a Java program can benifit from queue objects, the native IPC method on i5/OS from the following aspects:<ul>
<li>Queue objects provide a flexible, easy-to-use, and efficient IPC method for Java.</li><li>Comparing with calling a host program directly (e.g. by PCML) or calling a native method, communicating through a queue object seperates the thread model and resource management model of JVM and a job running host language programs. For example, many existing host language programs are insensible of thread-safety. Calling them directly from JVM's multi-threaded environment would lead to expected exceptions.</li><li>Comparing with invoking Java methods from a host language program, communicating through a queue object can avoid starting JVM repeatedly.</li></ul>
<p>
Here, as an example we implement a Java version of ISQL2 which is introduced in <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_pointer">6.5. Pass Variable Length Data through i5/OS Queue Objects</a>.<p>
Components of the Java version ISQL2<ul>
<li>Class isql<br>
 Class isql accepts a SQL statement from user input, invokes native method isqlsvr.sendRequest, which enqueues request data to USRQ ISQL2 and waits for returned SQL code on USRQ ISQLR2.</li><li>Class isqlsvr declares native method sendRequest；</li><li>Service Program(*SRVPGM) ISQLSVR<br>
 SRVPGM ISQLSVR implements native method isqlsvr.sendRequest</li></ul>
<p>
Steps<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java_1">6.6.1. Write Java Class isql and isqlsvr</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java_2">6.6.2. Write Native Method isqlsvr.sendRequest</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_java_3">6.6.3. Run Java Class isql</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_usage_demo_java_1">
6.6.1. Write Java Class isql and isqlsvr</a></h3>
Source code of <a href="src/isql.java">isql.java</a> <div class="fragment"><pre class="fragment">
<span class="keyword">public</span> <span class="keyword">class </span>isql {

    <span class="keyword">static</span> {

        System.loadLibrary(<span class="stringliteral">"ISQLSVR"</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String _usage =
        <span class="stringliteral">"usage info: java isql \"SQL statement to run.\""</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main(String[] args) {

        isql client = <span class="keyword">new</span> isql();
        client.run(args);

    }

    <span class="keyword">protected</span> <span class="keywordtype">void</span> run(String[] args) {

        <span class="keywordflow">if</span>(args.length &lt; 1) {

            System.out.println(_usage);
            <span class="keywordflow">return</span>;
        }

        String msg = <span class="stringliteral">""</span>;
        <span class="keywordflow">try</span> {

            <span class="comment">// send request to ISQLSVR</span>
            <span class="keywordtype">int</span> sqlcod = isqlsvr.sendRequest(args[0]);

            <span class="comment">// compose msg</span>
            <span class="keywordflow">if</span>(sqlcod &lt; 0)
                msg = <span class="stringliteral">"SQL statement failed with SQLCOD "</span> + sqlcod;
            <span class="keywordflow">else</span>
                msg = <span class="stringliteral">"SQL statement succeeded with SQLCOD "</span> + sqlcod;

        } <span class="keywordflow">catch</span>(Exception e) {

            System.out.println(e.getMessage());
            <span class="keywordflow">return</span>;
        }

        <span class="comment">// report execuation result</span>
        System.out.println(msg);
    }

}

<span class="comment">/* eof - isql.java */</span>
</pre></div> Source code of <a href="src/isqlsvr.java">isqlsvr.java</a> <div class="fragment"><pre class="fragment">
<span class="keyword">public</span> <span class="keyword">class </span>isqlsvr {

    <span class="keyword">public</span>
        <span class="keyword">static</span>
        native
        <span class="keyword">synchronized</span>
            <span class="keywordtype">int</span> sendRequest(
                            String sql
                            ) <span class="keywordflow">throws</span> Exception;

}

<span class="comment">/* eof - isqlsvr.java */</span>
</pre></div><p>
Compile Java classes <div class="fragment"><pre class="fragment"><span class="comment">/* Upload isql.java, isqlsvr.java to IFS */</span>
<span class="comment">/* Start a QShell session */</span>
qsh

<span class="comment">/* Include current directory into environment variable CLASSPATH */</span>
export CLASSPATH=.

<span class="comment">/* Compile java classes with javac */</span>
javac -encoding utf-8 *java

<span class="comment">/* Generate C header for JNI methods */</span>
javah isqlsvr
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_java_2">
6.6.2. Write Native Method isqlsvr.sendRequest</a></h3>
To implement Java native method isqlsvr.sendRequest, we write a c file <a href="src/isqlsvr.c">isqlsvr.c</a> which is to be compiled into a module object and then bind the module into *SRVPGM ISQLSVR.<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor"># include &lt;isqlsvr.h&gt;</span>

<span class="comment">// libc</span>
<span class="preprocessor"># include &lt;stdlib.h&gt;</span>
<span class="preprocessor"># include &lt;string.h&gt;</span>
<span class="preprocessor"># include &lt;except.h&gt;</span>

<span class="comment">// libmi</span>
<span class="preprocessor"># include &lt;mih/rslvsp.h&gt;</span>
<span class="preprocessor"># include &lt;mih/enq.h&gt;</span>
<span class="preprocessor"># include &lt;mih/genuuid.h&gt;</span>

<span class="comment">// libiconv</span>
<span class="preprocessor"># include &lt;iconv.h&gt;</span>

<span class="comment">// apis</span>
<span class="preprocessor"># include &lt;qusec.h&gt;</span>
<span class="preprocessor"># include &lt;qusrjobi.h&gt;</span>

<span class="keyword">typedef</span> _Packed <span class="keyword">struct </span>_deq_prefix {

  <span class="keywordtype">char</span> time_enqueued[8];
  <span class="keywordtype">char</span> timeout[8];
  <span class="keywordtype">int</span> text_len_returned;
  <span class="keywordtype">char</span> acc_state_mod[1];
  <span class="keywordtype">char</span> key_in[16];
  <span class="keywordtype">char</span> key_out[16];
} deq_prefix_t;

<span class="comment">// prototype of instruction DEQWAIT</span>
<span class="preprocessor"># pragma linkage(_DEQWAIT, builtin)</span>
<span class="preprocessor"></span><span class="keywordtype">void</span> _DEQWAIT (
               deq_prefix_t *,
               <span class="keywordtype">void</span>*,
               _SYSPTR*
               );

<span class="preprocessor"># define REQUEST_Q "ISQL2"</span>
<span class="preprocessor"></span><span class="preprocessor"># define REPLY_Q   "ISQLR2"</span>
<span class="preprocessor"></span><span class="preprocessor"># define UTF8_CCSID \</span>
<span class="preprocessor">  "IBMCCSID012080000000\0\0\0\0\0\0\0\0\0\0\0\0"</span>
<span class="preprocessor"></span><span class="preprocessor"># define ECLEN   256</span>
<span class="preprocessor"></span><span class="preprocessor"># define TEXTLEN 16</span>
<span class="preprocessor"></span><span class="preprocessor"># define KEYLEN  16</span>
<span class="preprocessor"></span><span class="preprocessor"># define ENQ_PREFIX_LEN 20</span>
<span class="preprocessor"></span><span class="preprocessor"># define DEQ_PREFIX_LEN 53</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> _Packed <span class="keyword">struct </span>_request {

  <span class="keywordtype">size_t</span> sql_len;
  <span class="keywordtype">char</span> reserved[8];
  <span class="keywordtype">char</span> *sql;
} request_t;

<span class="keyword">static</span> request_t _r;

<span class="keyword">typedef</span> _Packed <span class="keyword">struct </span>_reply {

  <span class="keywordtype">int</span> sqlcod;
  <span class="keywordtype">char</span> reserved[12];
} reply_t;

<span class="keywordtype">void</span> gen_uuid(<span class="keywordtype">char</span> *uuid);

<span class="keywordtype">int</span> get_job_ccsid();

<span class="keywordtype">void</span>
utf8_2_ebcdic (
               <span class="keyword">const</span> <span class="keywordtype">char</span> *source,
               <span class="keywordtype">size_t</span> source_length,
               <span class="keywordtype">char</span> *dest
               );

<span class="keywordtype">void</span> enq_request(
                 _SYSPTR q,
                 <span class="keyword">const</span> <span class="keywordtype">char</span> *key,
                 <span class="keyword">const</span> <span class="keywordtype">char</span> *sql
                 );

<span class="keywordtype">int</span> deq_reply(_SYSPTR q, <span class="keyword">const</span> <span class="keywordtype">char</span>* key);

<span class="keywordtype">int</span> resolve_queues(
                   _SYSPTR *request_q,
                   _SYSPTR *reply_q
                   );

<span class="comment">/*</span>
<span class="comment"> * implements isqlsvr.sendRequest()</span>
<span class="comment"> *</span>
<span class="comment"> * - resolve request q</span>
<span class="comment"> * - resolve reply q</span>
<span class="comment"> * - enq SQL</span>
<span class="comment"> */</span>
JNIEXPORT
jint
JNICALL
Java_isqlsvr_sendRequest (
                          JNIEnv *env,
                          jclass jthis,
                          jstring jsql
                          ) {

  <span class="keywordtype">int</span> r = 0;
  <span class="keywordtype">int</span> sqlcod = 0;
  jclass class_exception;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *utf8_sql = NULL;
  <span class="keywordtype">char</span> *sql = NULL;
  jboolean is_copy = JNI_FALSE;
  <span class="keywordtype">size_t</span> len = 0;
  <span class="keywordtype">char</span> uuid[16] = {0};

  _SYSPTR request_q = NULL;
  _SYSPTR reply_q = NULL;

  <span class="comment">/* resolve qs */</span>
  <span class="keywordflow">if</span>(resolve_queues(&amp;request_q, &amp;reply_q) != 0) {

    <span class="comment">// raise exception and return</span>
<span class="preprocessor"># pragma convert(819)</span>
<span class="preprocessor"></span>    class_exception = (*env)-&gt;FindClass(env, <span class="stringliteral">"java/lang/Exception"</span>);
<span class="preprocessor"># pragma convert(0)</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span>(class_exception != 0)
      (*env)-&gt;ThrowNew(env,
                       class_exception,
                       <span class="stringliteral">"Failed to resolve user queues"</span>
                       );
    <span class="keywordflow">return</span>;
  }

  <span class="comment">// convert sql to ebcdic</span>
  utf8_sql = (*env)-&gt;GetStringUTFChars(env, jsql, &amp;is_copy);
  len = (*env)-&gt;GetStringUTFLength(env, jsql);
  sql = malloc(len * 2 + 1);
  utf8_2_ebcdic(utf8_sql, len, sql);
  (*env)-&gt;ReleaseStringUTFChars(env, jsql, utf8_sql);

  <span class="comment">// enq request q</span>
  gen_uuid(uuid);
  enq_request(request_q, uuid, sql);

  <span class="comment">// deq reply q</span>
  sqlcod = deq_reply(reply_q, uuid);

  free(sql);
  <span class="keywordflow">return</span> sqlcod;
}

<span class="keywordtype">void</span> gen_uuid(<span class="keywordtype">char</span> *uuid) {

  _UUID_Template_T tmpl;

  memset(&amp;tmpl, 0, 32);
  tmpl.bytesProv = 32;
  _GENUUID(&amp;tmpl);

  memcpy(uuid, tmpl.uuid, 16);
}

<span class="keywordtype">int</span> get_job_ccsid() {

  <span class="keywordtype">int</span> ccsid = 0;
  Qwc_JOBI0400_t jobi;
  Qus_EC_t *ec = NULL;

  ec = (Qus_EC_t*)malloc(ECLEN);
  memset(ec, 0, ECLEN);
  ec-&gt;Bytes_Provided = ECLEN;
  jobi.Bytes_Avail = <span class="keyword">sizeof</span>(Qwc_JOBI0400_t);
  QUSRJOBI(
           &amp;jobi,
           <span class="keyword">sizeof</span>(Qwc_JOBI0400_t),
           <span class="stringliteral">"JOBI0400"</span>,
           <span class="stringliteral">"*                         "</span>,
           <span class="stringliteral">"                "</span>,
           ec
           );
  <span class="keywordflow">if</span>(ec-&gt;Bytes_Available != 0)
    ccsid = 37; <span class="comment">// ascii ccsid</span>
  <span class="keywordflow">else</span>
    ccsid = jobi.Coded_Char_Set_ID;

  free(ec);
  <span class="keywordflow">return</span> ccsid;
}

<span class="keywordtype">void</span>
utf8_2_ebcdic (
               <span class="keyword">const</span> <span class="keywordtype">char</span> *source,
               <span class="keywordtype">size_t</span> source_length,
               <span class="keywordtype">char</span> *dest
               ) {

  <span class="keywordtype">size_t</span> result_length = source_length * 2;
  <span class="keywordtype">char</span> host_ccsid[32 + 1] = {0};
  iconv_t cvt;

  sprintf(host_ccsid,
          <span class="stringliteral">"IBMCCSID%05d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"</span>,
          get_job_ccsid());
  cvt = iconv_open(host_ccsid, UTF8_CCSID);

  iconv(cvt,
        &amp;source,
        &amp;source_length,
        &amp;dest,
        &amp;result_length
        );

  iconv_close(cvt);
}

<span class="keywordtype">void</span> enq_request(
                 _SYSPTR q,
                 <span class="keyword">const</span> <span class="keywordtype">char</span> *key,
                 <span class="keywordtype">char</span> *sql
                 ) {

  _ENQ_Msg_Prefix_T *prefix;
  request_t *request = &amp;_r;
  <span class="keywordtype">char</span> text[16] = {0};

  prefix = (_ENQ_Msg_Prefix_T*)malloc(ENQ_PREFIX_LEN);
  memset(prefix, 0, ENQ_PREFIX_LEN);
  prefix-&gt;Msg_Len = TEXTLEN;
  memcpy(prefix-&gt;Msg, key, KEYLEN);

  request-&gt;sql_len = strlen(sql);
  request-&gt;sql = sql;
  memcpy(text, &amp;request, 16);

  _ENQ(&amp;q, prefix, text);

  free(prefix);
}

<span class="keywordtype">int</span> deq_reply(_SYSPTR q, <span class="keyword">const</span> <span class="keywordtype">char</span>* key) {

  deq_prefix_t prefix;
  reply_t reply;

  prefix.acc_state_mod[0] = 0xF8; <span class="comment">// 1111,1000; key realtion=EQ, deq infinitely</span>
  memcpy(prefix.key_in, key, KEYLEN);

  _DEQWAIT(&amp;prefix, &amp;reply, &amp;q);

  <span class="keywordflow">return</span> reply.sqlcod;
}

<span class="keywordtype">int</span> resolve_queues(
                   _SYSPTR *request_q,
                   _SYSPTR *reply_q
                   ) {

  <span class="keywordtype">int</span> resolved = -1;
  <span class="keyword">volatile</span> <span class="keywordtype">int</span> ca = 0;

<span class="preprocessor"># pragma exception_handler(end, ca, _C1_OBJECT_NOT_FOUND, \</span>
<span class="preprocessor">                           _C2_ALL, _CTLA_HANDLE)</span>
<span class="preprocessor"></span>  *request_q = rslvsp(0x0A02, REQUEST_Q, <span class="stringliteral">""</span>, 0x0000);
  *reply_q = rslvsp(0x0A02, REPLY_Q, <span class="stringliteral">""</span>, 0x0000);
  resolved = 0;

<span class="preprocessor"># pragma disable_handler</span>
<span class="preprocessor"></span>
 end:
  <span class="keywordflow">return</span> resolved;
}

<span class="comment">/* eof - isqlsvr.c */</span>
</pre></div><p>
Create *SRVPGM ISQLSVR <div class="fragment"><pre class="fragment"><span class="comment">/* Compile module ISQLSVR */</span>
CRTCMOD MODULE(LSBIN/ISQLSVR) SRCSTMF(isqlsvr.c) INCDIR('.')

<span class="comment">/* Create *SRVPGM ISQLSVR */</span>
CRTSRVPGM LSBIN/ISQLSVR MODULE(*LIBL/ISQLSVR) EXPORT(*ALL)
</pre></div><h3><a class="anchor" name="en_ss_using_q_usage_demo_java_3">
6.6.3. Run Java Class isql</a></h3>
To run a Java program on i5/OS, one should use CL command JAVA or RUNJVA, or use QShell command java.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/* Clear physical file PF16 */</span>
CLRPFM PF16

<span class="comment">/* Submit the server job */</span>
SBMJOB CMD(CALL ISQLSVR2)

<span class="comment">/* Chnage current directory to where isql.class and</span>
<span class="comment">   isqlsvr.class reside in */</span>
CHGCURDIR <span class="stringliteral">'/home/ljl/tmp'</span>

<span class="comment">/* Run java class isql */</span>
JAVA CLASS(isql) PARM('delete from pf16')
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">SQL statement succeeded with SQLCOD 100</span>
<span class="comment">Java program completed</span>
<span class="comment">*/</span>

<span class="comment">/* Execute an insert statement */</span>
JAVA CLASS(isql) PARM('insert into pf16 values(''20081212'', ''冬天'',''Friday'')')
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">SQL statement succeeded with SQLCOD 0</span>
<span class="comment">Java program completed</span>
<span class="comment">*/</span>

<span class="comment">/* Check physical file PF16 */</span>
RUNQRY *N PF16
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">Line   ....+....1....+....2....+....3....+.</span>
<span class="comment">       RQ        NAME              REMARK  </span>
<span class="comment">000001 20081212  冬天              Friday  </span>
<span class="comment"> ********  End of report  ********   </span>
<span class="comment">*/</span>
</pre></div><h2><a class="anchor" name="en_sect_using_q_appendices">
Appendice</a></h2>
<b>List of appendice</b> <br>
<ul>
<li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_1">Appendix 1. Enqueue USRQ Q11 for 1000 times</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_3">Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_4">Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a></li><li><a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_6">Appendix 6 Reference</a></li></ul>
<h3><a class="anchor" name="en_ss_using_q_appendix_1">
Appendix 1. Enqueue USRQ Q11 for 1000 times</a></h3>
Create USRQ Q11 of type FIFO, with entry length 64. <div class="fragment"><pre class="fragment">CALL PGM(QUSCRTUQ) PARM(
  'Q11       LSBIN'        <span class="comment">/* queue name: LSBIN/Q11 */</span>
  'USRQ'                   <span class="comment">/* extended attribute    */</span>
  'F'                      <span class="comment">/* queue type: keyed     */</span>
  X'00000000'              <span class="comment">/* key length: 0         */</span>
  X'00000040'              <span class="comment">/* max entry length: 64  */</span>
  X'00010000'              <span class="comment">/* initial number of messages: 65536  */</span>
  X'00001000'              <span class="comment">/* extend number of messages: 4096    */</span>
  '*EXCLUDE'               <span class="comment">/* public authority                   */</span>
  'FIFO USRQ: entry length = 64'  <span class="comment">/* text description            */</span>
)
</pre></div><p>
MI program that enqueues USRQ Q11 for 1000 times, <a href="src/enq11.mi">enq11.mi</a> <div class="fragment"><pre class="fragment">
dcl sysptr q auto                ; 
dcl dd message-prefix char(4) auto;
  dcl dd prefix-msglen bin(4) def(message-prefix) pos(1);

dcl dd message <span class="keywordtype">char</span>(64) auto init("is usrq more faster?") ;
dcl spcptr .message auto init(message) ; 

entry * ext;

dcl dd index bin(4) auto init(0) ; 

        cpybla rslv-option-obj-type, x"0A02";
        cpyblap rslv-option-obj-name, "Q11", " ";
        rslvsp q, rslv-option-<span class="keywordtype">short</span>, *, x'0000';

        <span class="comment">/* enq */</span>
        cpynv prefix-msglen, 64;
        cpynv index, 0          ; 
enq-loop:
        addn(s) index, 1        ;
        cmpnv(b) index, 1000 / hi(end-loop) ; 
        enq q, message-prefix, .message;

        b enq-loop              ; 
end-loop:       

        rtx *;

%include ptrres.mi              ; 

pend;

<span class="comment">/* eof - enq11.mi */</span>
</pre></div><p>
ILE RPG program <a href="src/renq11.rpgle">renq11.rpgle</a> calls <a href="src/enq11.mi">enq11.mi</a> and compute time used on 1000 times of enqueue operation. <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file renq11.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * call PGM ENQ11 for 1000 times</span>
<span class="comment">      */</span>

     d b               s               z
     d e               s               z
     d ind             s             10i 0
     d dur             s             15p 0

     c                   eval      b = %timestamp()
     c                   call      'ENQ11'
     c                   eval      e = %timestamp()
     c                   eval      dur = %diff(e : b : *ms)

     c     'microseconds'dsply                   dur
     c                   seton                                          lr
     <span class="comment">/* eof - renq11.rpgle */</span>
</pre></div><p>
Run RENQ11 for 10 times <div class="fragment"><pre class="fragment">DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">The average time of 10 times of execution</span>
<span class="comment">is 4000 micro-seconds(0.004s).</span>
<span class="comment">*/</span>
</pre></div><p>
Use CL command <a href="../q/page_dspqd.html">DSPQD</a> provided by <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> to check USRQ Q11. <div class="fragment"><pre class="fragment">DSPQD Q(LSBIN/Q11) QTYPE(*USRQ)
</pre></div> Output of DSPQD <div class="fragment"><pre class="fragment">Current maximum number of             
  messages . . . . . . . . . :   65536
Current number of messages            
  enqueued . . . . . . . . . :   10000
Extension value  . . . . . . :   4096 
Key length . . . . . . . . . :   0    
Maximum size of message to be         
  enqueued . . . . . . . . . :   64   
Maximum number of extends  . :   35
Current number of extends  . :   0   
Initial number of messages . :   65536
</pre></div> The output of command DSPQD shows that after running RENQ11 for 10 times there're 10000 messages currently on Q11, and Q11 has never been extended.<h3><a class="anchor" name="en_ss_using_q_appendix_2">
Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a></h3>
Create DTAQ Q12 of type FIFO, with entry length 64. <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/Q12)       <span class="comment">/* queue name         */</span>
        MAXLEN(64)            <span class="comment">/* entry length: 64   */</span>
        SEQ(*FIFO)            <span class="comment">/* queue type: keyed  */</span>
        SIZE(*MAX16MB 65536)  <span class="comment">/* initial number of messages: 65536 */</span>
        TEXT('FIFO DTAQ: entry length=64')
</pre></div><p>
ILE RPG program <a href="src/renq12.rpgle">renq12.rpgle</a> enqueues DTAQ Q12 for 1000 times and compute time used on 1000 times of enqueue operation. <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file renq12.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * enqueue DTAQ Q12 for 1000 times</span>
<span class="comment">      */</span>

     d b               s               z
     d e               s               z
     d ind             s             10i 0
     d dur             s             15p 0

     c                   eval      b = %timestamp()
     c                   for       ind = 1 to 1000  by 1
     c                   call      'QSNDDTAQ'
     c                   parm      'Q12'         qname            10
     c                   parm      'LSBIN'       qlib             10
     c                   parm      64            entlen            5 0
     c                   parm      *all'1'       ent              64
     c                   endfor
     c                   eval      e = %timestamp()
     c                   eval      dur = %diff(e : b : *ms)

     c     'microseconds'dsply                   dur
     c                   seton                                          lr
     <span class="comment">/* eof */</span>
</pre></div><p>
Run RENQ12 for 10 times <div class="fragment"><pre class="fragment">DSPLY  microseconds             17000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             14000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">The average time of 10 times of execution</span>
<span class="comment">is 15100 micro-seconds(0.0151s)</span>
<span class="comment">*/</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_appendix_3">
Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a></h3>
Clear DTAQ Q12 with the QCLRDTAQ API <div class="fragment"><pre class="fragment">CALL PGM(QCLRDTAQ) PARM('Q12' 'LSBIN')
</pre></div><p>
Start journaling DTAQ Q12 <div class="fragment"><pre class="fragment">STRJRNOBJ OBJ(LSBIN/Q12) OBJTYPE(*DTAQ) JRN(LSBIN/JRN01)
</pre></div><p>
Run RENQ12 metioned in <a class="el" href="page_using_q_en.html#en_ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a> for 10 times <div class="fragment"><pre class="fragment">DSPLY  microseconds            4066000
DSPLY  microseconds            4019000
DSPLY  microseconds            4145000
DSPLY  microseconds            4018000
DSPLY  microseconds            4007000
DSPLY  microseconds            4206000
DSPLY  microseconds            4031000
DSPLY  microseconds            4042000
DSPLY  microseconds            4023000
DSPLY  microseconds            4042000
<span class="comment">/*</span>
<span class="comment">Result:</span>
<span class="comment">The average time of 10 times of execution</span>
<span class="comment">is 4059900 micro-seconds(4.0599s)</span>
<span class="comment">*/</span>
</pre></div><h3><a class="anchor" name="en_ss_using_q_appendix_4">
Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a></h3>
<ul>
<li>QB - Start data queue journaling</li><li>QC - Data queue cleared, no key</li><li>QD - Data queue deleted</li><li>QE - End data queue journaling</li><li>QI - Queue in use at abnormal end</li><li>QJ - Data queue cleared, has key</li><li>QK - Send data queue entry, has key</li><li>QL - Receive data queue entry, has key</li><li>QM - Data queue moved</li><li>QN - Data queue renamed</li><li>QR - Receive data queue entry, no key</li><li>QS - Send data queue entry, no key</li><li>QX - Start of save-while-active for data queue</li><li>QY - Data queue saved</li><li>QZ - Data queue restored</li><li>VE - Internal entry</li><li>VQ - Internal entry</li></ul>
<h3><a class="anchor" name="en_ss_using_q_appendix_5">
Appendix 5 A Joblog Saver Program</a></h3>
As a complementary introduction to section <a class="el" href="page_using_q_en.html#en_ss_using_q_usage_demo_outputq">6.2. Data Queue Support on Output Queues</a>, here we introduce a Joblog Saver program. The Joblog Saver program copies the content of a spooled file on output queue QEZJOBLOG to a physical file each time a spooled file on the output queue reaches RDY status and then delete the spooled file in order to reclaim resources such as jobs in OUTQ status.<p>
<b>Create DTAQ JOBLOGNTF to associated with output queue QEZJOBLOG</b><br>
 <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/JOBLOGNTF)
        MAXLEN(128)           <span class="comment">/* receive notification of type '01' */</span>
        SIZE(*MAX2GB)
        AUTORCL(*YES)
        TEXT('i watch joblogs')
</pre></div><p>
<b>Create physical file JOBLOG</b><br>
 <div class="fragment"><pre class="fragment">CRTPF FILE(LSBIN/JOBLOG) RCDLEN(132) IGCDTA(*YES)
</pre></div><p>
<b>Assosiate DTAQ JOBLOGNTF with output queue QEZJOBLOG</b><br>
 <div class="fragment"><pre class="fragment">CHGOUTQ OUTQ(QEZJOBLOG) DTAQ(LSBIN/JOBLOGNTF)
</pre></div><p>
<b>Write the Joblog Saver Program</b><br>
 Source code of ILE RPG program <a href="src/savjoblog.rpgle">savjoblog.rpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file savjoblog.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * @remark 需要退出时，向DTAQ JOBLOGNTF入列个QUIT</span>
<span class="comment">      *          e.g. CALL PGM(QSNDDTAQ) PARM('JOBLOGNTF'</span>
<span class="comment">      *                 'LSBIN' X'00010F' 'QUIT')</span>
<span class="comment">      *</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     <span class="comment">/*</span>
<span class="comment">      * dequeue a notification message from DTAQ JOBLOGNTF</span>
<span class="comment">      *</span>
<span class="comment">      * @return *on if okey, *off if notified to quit.</span>
<span class="comment">      */</span>
     d deq_notify      pr              n
     <span class="comment">/*</span>
<span class="comment">      * copy joblog to PF JOBLOG;</span>
<span class="comment">      * delete spooled file.</span>
<span class="comment">      */</span>
     d wrk_with_splf   pr

     <span class="comment">/* Notification information */</span>
     d notify          ds           128    qualified
     d   func_code                   10a
     d   rec_type                     2a
     d   job_id                      26a
     d   splf_name                   10a
     d   splf_num                    10i 0

      /free

          dow deq_notify();
              wrk_with_splf();
          enddo;

          *inlr = *on;
      /end-free

     <span class="comment">/* deq_notify() */</span>
     p deq_notify      b
     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm('QRCVDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   qentrylen                    5p 0
     d   qentry                     128a
     d   timeout                      5p 0

     d qname           s             10a   inz('JOBLOGNTF')
     d qlib            s             10a   inz('LSBIN')
     d qentrylen       s              5p 0 inz(128)
     d timeout         s              5p 0 inz(-1)
     d quit            c                   'QUIT'

     d deq_notify      pi              n

      /free

          qrcvdtaq( qname
                   : qlib
                   : qentrylen
                   : notify
                   : timeout );

          if %subst(notify.func_code : 1 : 4) = quit;
              return *off;
          endif;

          return *on;
      /end-free
     p deq_notify      e

     p wrk_with_splf   b
     <span class="comment">/* prototype of API QCMDEXC */</span>
     d qcmdexc         pr                  extpgm('QCMDEXC')
     d   cmdstr                     128    options(*varsize)
     d   cmdlen                      15p 5

     d cmd             s            128a
     d len             s             15p 5
     d jid             s             28a

      /free

          jid = %subst(notify.job_id:21:6)
                + '/'
                + %trim(%subst(notify.job_id:11:10))
                + '/'
                + %trim(%subst(notify.job_id: 1:10));

          monitor;

          <span class="comment">// copy spooled file to PF JOBLOG</span>
          cmd = 'CPYSPLF FILE('
                + %trim(notify.splf_name)
                + ') TOFILE(LSBIN/JOBLOG) JOB('
                + %trim(jid)
                + ') SPLNBR('
                + %<span class="keywordtype">char</span>(notify.splf_num)
                + ') MBROPT(*ADD)';
          len = %len(%trim(cmd));
          qcmdexc(cmd : len);

          <span class="comment">// delete spooled file</span>
          cmd = 'DLTSPLF FILE('
                + %trim(notify.splf_name)
                + ') JOB('
                + %trim(jid)
                + ') SPLNBR('
                + %<span class="keywordtype">char</span>(notify.splf_num)
                + ') ';
          len = %len(%trim(cmd));
          qcmdexc(cmd : len);

          on-error;
          endmon;

      /end-free
     p wrk_with_splf   e
     <span class="comment">/* eof */</span>
</pre></div><p>
<b>Test the Joblog Saver Program</b><br>
 Submit the Joblog Saver job <div class="fragment"><pre class="fragment">SBMJOB CMD(CALL PGM(LSBIN/SAVJOBLOG)) JOB(JOBLOGSVR)
</pre></div><p>
Make a spooled file on output queue QEZJOBLOG. <div class="fragment"><pre class="fragment">SBMJOB CMD(DLYJOB DLY(3)) JOB(MAKEJOBLOG) LOG(*JOBD *JOBD *SECLVL)
</pre></div> Check physical file JOBLOG <div class="fragment"><pre class="fragment">RUNQRY *N JOBLOG
<span class="comment">/* Contents of physical file JOBLOG */</span>
  5722SS1 V5R2M0 020719                           Job Log                             810      09/05/19 14:24:35          Page    1
   Job name . . . . . . . . . . :   MAKEJOBLOG      User  . . . . . . :   LJL          Number . . . . . . . . . . . :   254693
   Job description  . . . . . . :   LJL_DAILY       Library . . . . . :   QGPL
 MSGID      TYPE                    SEV  DATE      TIME             FROM PGM     LIBRARY     INST     TO PGM      LIBRARY     INST
 CPF1124    Information             00   09/05/19  14:24:32.615208  QWTPIIPP     QSYS        05D4     *EXT                    *N
                                      Message . . . . :   Job 254693/LJL/MAKEJOBLOG started on 09/05/19 at 14:24:32
                                        in subsystem QBATCH in QSYS. Job entered system on 09/05/19 at 14:24:32.
 CPI1125    Information             00   09/05/19  14:24:32.619792  QWTPCRJA     QSYS        0108     *EXT                    *N
                                      Message . . . . :   Job 254693/LJL/MAKEJOBLOG submitted.
                                      Cause . . . . . :   Job 254693/LJL/MAKEJOBLOG submitted to job queue QBATCH in
                                        QGPL from job 254687/LJL/GREENTEA. Job 254693/LJL/MAKEJOBLOG was started
                                        <span class="keyword">using</span> the Submit Job (SBMJOB) command with the following job attributes:
                                        JOBPTY(5) OUTPTY(5) PRTTXT() RTGDTA(QCMDB) SYSLIBL(QSYS       QSYS2
                                        QHLPSYS    QUSRSYS) CURLIB(LSBIN) INLLIBL(QGPL       QTEMP      LSBIN
                                        LJLCP      ATS        XTXRUN     MN         I5TOOLKIT) LOG(4 00 *SECLVL)
<span class="comment">/* .... ... */</span>
</pre></div><p>
Notify the Joblog Saver job to quit. <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('JOBLOGNTF' 'LSBIN' X'00010F' 'QUIT')
</pre></div><h3><a class="anchor" name="en_ss_using_q_appendix_6">
Appendix 6 Reference</a></h3>
<ul>
<li><a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/obj1.htm">Object APIs</a></li><li><a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apiref/MIpgmg.htm">Machine interface programming</a></li><li>The open source project <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> maintains queue tools such as <a href="../q/page_dspqd.html">DSPQD</a> and <a href="../q/page_dspqmsg.html">DSPQMSG</a>. For documents and articles of the project, please refer to the <a href="http://i5toolkit.sourceforge.net/">project homepage</a>.</li></ul>
<h2><a class="anchor" name="en_sect_using_q_about_me">
About the Author</a></h2>
Hi, i'm Junlei Li(李君磊) from Tianjin, China. Strictly speaking, i am a new comer to i5/OS or OS/400 with only 3 or 4 years of experience of programming on this platform. I cannot say for sure i like this OS or not, but there is one thing i never doubted that this OS is designed to be so sophisticated and with many design concepts ahead of the times.<p>
In the open source project <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> i maintain, more than a half of the source code is written in MI. I have to appreciate Mr. Leif Svalgaard for his excellent articles about MI programming on <a href="http://archive.midrange.com/mi400/index.htm">midrange.com</a>.<p>
Other useful web sites for me include:<ul>
<li><a href="http://code400.com/">code400.com</a></li><li><a href="http://www.mcpressonline.com">www.mcpressonline.com</a></li></ul>
<p>
I'm available at <a href="mailto:junleili-cn@users.sourceforge.net">junleili-cn@users.sourceforge.net</a>. Any comments and suggestions are always welcome :) </div>
<hr size="1">

<a href="http://sourceforge.net/donate/index.php?group_id=254578"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> </a>

<address style="text-align: right;"><small>Generated on Tue May 10 19:55:08 2011 for i5/OS Programmer's Toolkit: Articles by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9  </small></address>
</body>
</html>
