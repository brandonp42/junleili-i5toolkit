<HTML>
  <HEAD>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <TITLE>i5/OS Programmer's Toolkit - MI/EMI Programmer's Guide</TITLE>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="doxygen.css" rel="stylesheet" type="text/css">
    <link href="docs.css" rel="stylesheet" type="text/css">

    <table width="100%" border="0" cellspacing="0" cellpadding="0">
      <tr>
        <td align="left">
          <a href="http://sourceforge.net/donate/index.php?group_id=254578"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> </a>
        </td>
        <td align="right">
          <a href="http://sourceforge.net/projects/i5toolkit"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=254578&amp;type=13" width="120" height="30" alt="Get i5/OS Programmer's Toolkit at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a>
        </td>

      </tr>
    </table>

  </HEAD>
  <body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="page_using_q_cn">使用i5/OS的Queue Objects </a></h1><dl class="version" compact><dt><b>Version:</b></dt><dd>0.1 </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>2009-06-20 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>李君磊</dd></dl>
Queue object是i5/OS上原生的，最常用，最易用，最灵活的IPC方式。 这里我们对Queue Object的重要属性，以及Data Queue和User Queue的操作进行了总结， 同时提供了基于Queue Object的若干有趣且实用的应用实例。这些实例包括：<ul>
<li><a href="page_using_q_cn.html#ss_using_q_appendix_5">Joblog Saver Program</a><br>
 用于将Output Queue QEZJOBLOG中的spooled file实时地存入数据文件，并清除spooled file。 参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_outputq">6.2. Output Queue的Data Queue支持</a> 及 <a class="el" href="page_using_q_cn.html#ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a>。</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority">6.3. 通过keyed queue objects实现基于优先级的通讯</a></li><li>ISQL/RUNSQL<br>
 两个执行SQL语句的CL命令，分别用于交互执行以及在 CL程序或REXX脚本中执行。RUNSQL返回标识SQL语句执行结果的SQL CODE， CL程序或REXX脚本可以依据SQL CODE决定执行SQL语句后的程序逻辑，或 进行提交/回滚。参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync">6.4. 通过i5/OS queue object模拟同步调用</a>。</li><li>ISQL2/RUNSQL2<br>
 对ISQL/RUNSQL的改进，不限制SQL语句长度。 参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer">6.5. 通过i5/OS queue object传递变长数据</a>。</li><li>Java版本的ISQL<br>
 演示了Java程序通过JNI方法在User Queue上传递指针， 与主机语言程序交互的过程。参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java">6.6. Java和i5/OS Queue object</a>。</li></ul>
<p>
<b>这里的内容</b><ul>
<li><a class="el" href="page_using_q_cn.html#sect_using_q_shuyu">1. 术语及缩略语</a></li><li><a class="el" href="page_using_q_cn.html#sect_using_q_intro">2. 对i5/OS Queue Object的介绍</a></li><li><a class="el" href="page_using_q_cn.html#sect_using_q_diffs">3. DTAQ与USRQ的区别</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_domain">3.1. Object Domain</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_journal">3.2. 是否可以启用日志</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_operation">3.3. 操作接口</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_weight">3.4. 操作效率</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_senderid">3.5. DTAQ message可以包含Sender ID</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#sect_using_q_dtaq_howtos">4. Data Queue操作示例</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt">4.1. 创建一个DTAQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_1">4.1.1. 创建一个FIFO或LIFO类型的DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_2">4.1.2. 创建一个Keyed DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_3">4.1.3. 创建一个包含发送作业标识的DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_4">4.1.4. 关于CRTDTAQ命令的MAXLEN参数</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_5">4.1.5. 关于CRTDTAQ命令的SIZE参数</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_dlt">4.2. 删除一个DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq">4.3. 入列一个DTAQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq_1">4.3.1. 入列一个FIFO或LIFO类型的DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq_2">4.3.2. 入列一个Keyed DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq_3">4.3.3. 入列一个Keyed DTAQ</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq">4.4. 出列一个DTAQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq_1">4.4.1. 出列FIFO/LIFO DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq_2">4.4.2. 出列Keyed DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq_3">4.4.3. 出列Keyed DTAQ并保留被出列entry</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_clr">4.5. 清空一个DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_matqat">4.6. 获取DTAQ属性</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_matmsg">4.7. 获取Data queue上的消息</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#sect_using_q_usrq_howtos">5. User Queue操作示例</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt">5.1. 创建一个USRQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt_1">5.1.1. USRQ上最大可容纳的消息数</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt_2">5.1.2. USRQ的Domain属性</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt_3">5.1.3. 关于参数Number of queue extensions</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_dlt">5.2. 删除一个USRQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_enq">5.3. 入列一个USRQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_deq">5.4. 出列一个USRQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_deq_1">5.4.1.使用不等待方式执行DEQ指令</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_deq_2">5.4.2. 使用等待方式执行DEQ指令</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_clr">5.5. 清空USRQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_matqat">5.6. 获取USRQ属性</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_matqmsg">5.7. 获取USRQ上的消息</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#sect_using_q_usage_demo">6. Queue Object应用实例</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_byibm">6.1. IBM提供的USRQ示例: Creating a Batch Machine</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_outputq">6.2. Output Queue的Data Queue支持</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority">6.3. 通过keyed queue objects实现基于优先级的通讯</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority_1">6.3.1. 创建DTAQ Q27</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority_2">6.3.2. 编写客户程序</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority_3">6.3.3. 编写服务程序</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync">6.4. 通过i5/OS queue object模拟同步调用</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_1">6.4.1. 创建DTAQ ISQL, ISQLR</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_2">6.4.2. 编写CL命令ISQL</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_3">6.4.3. 编写CL命令处理程序ISQL</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_4">6.4.4. 编写服务程序ISQLSRV</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_5">6.4.5. 执行服务程序ISQLSRV和客户ISQL</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_6">6.4.6. 为CL命令ISQL编写一个返回SQLCOD的版本RUNSQL</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer">6.5. 通过i5/OS queue object传递变长数据</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_1">6.5.1. 创建USRQ ISQL2, ISQLR2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_2">6.5.2. 编写CL命令ISQL2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_3">6.5.3. 编写CL命令处理程序ISQLCPP2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_4">6.5.4. 编写服务程序ISQLSVR2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_5">6.5.5. 编写由CL程序或REXX脚本调用的CL命令RUNSQL2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_6">6.5.6. 执行服务程序ISQLSVR2和客户ISQL2</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java">6.6. Java和i5/OS Queue object</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java_1">6.6.1. 编写Java程序isql.java, isqlsvr.java</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java_2">6.6.2. 编写JNI方法</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java_3">6.6.3. 执行Java类isql</a></li></ul>
</li></ul>
</li><li><a class="el" href="page_using_q_cn.html#sect_using_q_appendices">附录</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_1">Appendix 1. Enqueue USRQ Q11 for 1000 times</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_3">Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_4">Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_6">Appendix 6 参考信息</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#sect_using_q_about_me">关于作者</a></li></ul>
<h2><a class="anchor" name="sect_using_q_shuyu">
1. 术语及缩略语</a></h2>
本文中的部分术语<ul>
<li>MI<br>
 在i5/OS的前身S/38引入的TIMI(Technology Indepent Machine Interface)， 简称MI(Machine interface)。作为一个机器接口层，MI隔离了应用程序 与MI以下的硬件相关的软件环境和实际硬件，实现了一个OS级别的"虚拟机"。 关于MI的详细介绍，可以参考 Fortress Rochester: The Inside Story of the IBM ISeries, by Frank G. Soltis, ISBN 1583040838, 9781583040836。</li><li>MI Object Type<br>
 在不同场合，又被称为internal object type。与应用层面使用的*FILE，*DTAQ等external object type，有着一对一，或多对一 的关系。例如job queue(*JOBQ)对应着MI object中的independent index object；又如file object(*FILE)，由4种MI object构成： space object, cursor object, data space object, data space index object。 MI object type的完整列表可以参考MI指令<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/RSLVSP.htm?resultof=%22%72%73%6c%76%73%70%22%20">Resolve System Pointer (RSLVSP)</a></li><li>IPC<br>
 Inter-process communicatioin.</li><li>Queue Object Types<br>
<ul>
<li>FIFO, queue entries are received in a first-in first-out sequence.</li><li>LIFO, queue entries are received in a last-in first-out sequence.</li><li>Keyed, queue entries are received by key. A key is a prefix added to an entry by its sender.</li></ul>
</li></ul>
<p>
本文中使用的缩略语<ul>
<li>DTAQ, Data Queue</li><li>USRQ, User Queue</li><li>OUTQ, Output Queue</li></ul>
<h2><a class="anchor" name="sect_using_q_intro">
2. 对i5/OS Queue Object的介绍</a></h2>
作为一种MI Object，Queue object可以供多个作业插入和读取数据；Queue object的system object type为 hex 0A。 对Queue的插入操作称为Enqueue(入列)，对Queue的读取操作称为Dequeue(出列)。 被入列到一个Queue上的数据，称为Queue Entry或Queue Message。 任意对一个Queue有权限的作业都可以向Queue上入列数据或由Queue里出列数据。 对Queue的入列和出列可以基于Key Value(键值)，或者基于Queue Entry 的到达顺序，此时，出列操作又分为FIFO(先入先出)和LIFO(后入先出)。<p>
在i5/OS上，通过CL命令和编程接口可以操作Queue objects有: <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td></td><td>External Object Type </td><td>System(MI) Object Type/Subtype  </td></tr>
<tr>
<td>Data Queue </td><td>*DTAQ </td><td>hex 0A01  </td></tr>
<tr>
<td>User Queue </td><td>*USRQ </td><td>hex 0A02  </td></tr>
</table>
下面，我们将data queue简称为DTAQ，将user queue简称为USRQ。<p>
此外，每个i5/OS作业还在时时刻刻地使用着一个Queue Object，即包含在PCS (Process Control Space)中的QMIRQ，一个作业在每次发出I/O操作请求后， 由QMIRQ接收I/O操作的结束通知。<p>
Queue object的主要属性:<ul>
<li>Queue中可以存放的最大Queue Message数</li><li>Queue Message最大长度(上限为64K字节)</li><li>仅允许容纳固定数量Queue Message，还是可以扩展</li><li>对于允许扩展的Queue object，每次扩展的Queue message数</li><li>Queue object的初始message数</li><li>是否自动回收存储，如果是，则当queue message数降为0时， queue object占用过的额外存储将被回收至仅包含初始message数的尺寸</li><li>是否基于键值出列(即类别为Keyed)</li><li>如果不基于键值出列，Queue message出列的顺序：FIFO或LIFO</li><li>键值长度，如果基于键值出列</li><li>由queue object deqeue的message是否可以包含指针</li></ul>
<p>
每个Queue message包含两个部分，message prefix和message text；message prefix中包含 着message text长度以及键值数据。值得注意的是，尽管在入列时，我们可以指定小于 最大queue message长度的message text，但入列后message text实际占用的存储还是等于 Queue Message最大长度。这就意味着，如果为了兼容多种长度相差很多的数据格式，而指 定冗余的queue message最大长度来存放多种数据格式的数据，将导致存储的浪费。<p>
应用程序请求入列一个queue object时，必须提供message prefix和message text。当 queue object中没有可用存储空间时，依赖于queue object的是否可扩展属性，queue object 被扩展或引发一个"queue full"异常(MCH3802)。<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>当使用QSNDDTAQ 入列 data queue时，当data queue满了时，QSNDDTAQ会引发CPF950A。</dd></dl>
应用程序请求由一个queue object 出列 message时，如果message text包含指针， 如果允许message text包含指针属性为真，则指针上的保护tag(标记)被保留；否则， message text中指针上的保护tag将被清除，出列后message text中包含的指针将不 再可用。如果queue message的键值包含指针，出列后键值中指针的保护tag也会 被清除，出列后指针不再可用。<p>
由一个queue object 出列 message时，如果queue object中没有符合条件的meesage时， 应用程序可以选择是否等待，如果选择等待，可以指定永远等待或指定超时值，等待超时 时，会引发 dequeue time-out 异常(MCH5801)。 <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>对于data queue，指定QRCVDTAQ API的"Wait time"参数为0，表示不等待； 对于user queue，通过使用DEQ指令的branch-form或indicator-form来实现不等待。<p>
使用QRCVDTAQ 出列 data queue时，当等待超时，不会引发异常。要判断 是否超时，只能在对QRCVDTAQ调用后，依据存放message text数据的内容判断 是出列到了message，还是出列超时。</dd></dl>
可以备份或恢复DTAQ和USRQ，但是由于queue object是i5/OS的用于进行IPC 的，备份和恢复将仅针对于queue object描述信息，而不包含queue object的数据；因此，被恢复的queue object总是空的； 此外，恢复一个queue object时，如果目的queue object 已经存在，将导致恢复失败。<h2><a class="anchor" name="sect_using_q_diffs">
3. DTAQ与USRQ的区别</a></h2>
同样作为i5/OS上的queue object，DTAQ与USRQ具有相同的object属性， 相同的system(MI) object type hex 0A，仅仅是subtype不同， DTAQ为hex 01，USRQ为hex 02；那么二者之间的区别是什么。 这里将由以下几方面就DTAQ与USRQ的区别进行说明：<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_domain">3.1. Object Domain</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_journal">3.2. 是否可以启用日志</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_operation">3.3. 操作接口</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_weight">3.4. 操作效率</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_diffs_senderid">3.5. DTAQ message可以包含Sender ID</a></li></ul>
<h3><a class="anchor" name="ss_using_q_diffs_domain">
3.1. Object Domain</a></h3>
i5/OS向用户暴露的DTAQ创建接口是CL命令CRTDTAQ，该命令创建的 DTAQ object总是属于System Domain的，处于User State的进程 无法直接访问，必须通过API或CL命令访问。<p>
i5/OS向用户暴露的DTAQ创建接口是API QUSCRTUQ，该API允许用户 创建System Domain或User Domain的USRQ。参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt_2">5.1.2. USRQ的Domain属性</a>。 然而，作为一个System Domain object，创建的USRQ仅仅在Security Level 30及以下才可以被用户程序通过 MI指令访问。<h3><a class="anchor" name="ss_using_q_diffs_journal">
3.2. 是否可以启用日志</a></h3>
可以对一个DTAQ object 启用日志，而USRQ则不行。 对DTAQ启用日志使得基于DTAQ的IPC过程具备了运行时刻的可观察性。 通过日志，可以记录DTAQ的入列操作信息容，出列操作信息以及对 DTAQ的删除，重命名的等操作。 这为调试基于DTAQ进行的IPC应用提供了便利。同时要注意的是， 由于不可能备份恢复Queue object的数据内容，因此， 日志中记录对DTAQ的入列，出列操作的journal entires 不可以用于Apply Journaled Changes(APYJRNCHG)或 Remove Journaled Changes(RMVJRNCHG)。<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>DTAQ操作可能的journal entry type参考 <a class="el" href="page_using_q_cn.html#ss_using_q_appendix_4">Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a></dd></dl>
由下面的示例，可以看到，对DTAQ启用日志后，入列，出列 操作会在日志中留下哪些记录:<ul>
<li>创建DTAQ Q13，类型为FIFO，entry长度64 <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/Q13) MAXLEN(64)
</pre></div></li></ul>
<p>
<ul>
<li>对DTAQ Q13启用日志，注意对DTAQ object启用日志时，不可以使用参数IMAGES(*BOTH) <div class="fragment"><pre class="fragment">STRJRNOBJ OBJ(LSBIN/Q13) OBJTYPE(*DTAQ) JRN(JRN01) IMAGES(*AFTER)
</pre></div></li></ul>
<p>
<ul>
<li>对DTAQ Q13进行enqeue，出列操作 <div class="fragment"><pre class="fragment"><span class="comment">/* 入列 */</span>
CALL PGM(QSNDDTAQ) PARM('Q13' 'LSBIN' X'00010F' 'AAAAAAAAAA')
CALL PGM(QSNDDTAQ) PARM('Q13' 'LSBIN' X'00020F' 'BBBBBBB CCCCCCC')
</pre></div> 使用CL命令 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>的 <a href="../q/page_dspqmsg.html">DSPQMSG</a> 可以看到当前DTAQ Q13上有2条message <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>序号 </td><td>入列时间 </td><td>Message Text  </td></tr>
<tr>
<td>1 </td><td>2009-05-18-11.27.58.619412 </td><td>'AAAAAAAAAA'  </td></tr>
<tr>
<td>2 </td><td>2009-05-18-11.28.23.033237 </td><td>'BBBBBBB CCCCCCC'  </td></tr>
</table>
<div class="fragment"><pre class="fragment"> - 出列DTAQ Q13
CALL PGM(QRCVDTAQ) PARM('Q13' 'LSBIN' X'00020F' '' X'00001D')
</pre></div></li></ul>
<p>
<ul>
<li>查看日志中与Q13相关的日志内容 <div class="fragment"><pre class="fragment"><span class="comment">/* 查看journal code为Q(DTAQ操作)的journa entires */</span>
DSPJRN JRN(LSBIN/JRN01) JRNCDE((Q))
</pre></div> DSPJRN命令输出 <div class="fragment"><pre class="fragment">         11075   Q     QS   Q13         LSBIN       REDLIGHT    11:27:58
         11076   Q     QS   Q13         LSBIN       REDLIGHT    11:28:23
         11077   Q     QR   Q13         LSBIN       REDLIGHT    12:25:22
</pre></div><ul>
<li>查看入列操作对应的journal entries(journal entry type为'QS')。<ul>
<li>入列操作journal entries中包含入列的数据内容； <div class="fragment"><pre class="fragment">                            Display Journal Entry                      
                                                                       
Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN
Member . . . . . . . :                                                 
Incomplete data  . . :   No              Minimized entry data :   No   
Sequence . . . . . . :   11075                                         
Code . . . . . . . . :   Q  - Data queue operation                     
Type . . . . . . . . :   QS - Send data queue entry, no key            
                                                                       
            Entry specific data                                        
Column      *...+....1....+....2....+....3....+....4....+....5         
00001      <span class="stringliteral">' K   1.                           N             AA'</span>        
00051      <span class="stringliteral">'AAAAAAAA'</span>

                            Display Journal Entry                      
                                                                       
Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN
Member . . . . . . . :                                                 
Incomplete data  . . :   No              Minimized entry data :   No   
Sequence . . . . . . :   11076                                         
Code . . . . . . . . :   Q  - Data queue operation                     
Type . . . . . . . . :   QS - Send data queue entry, no key            
                                                                       
            Entry specific data                                        
Column      *...+....1....+....2....+....3....+....4....+....5         
00001      <span class="stringliteral">' K E! !                           N             BB'</span>        
00051      <span class="stringliteral">'BBBBB CCCCCCC     '</span>                                        
</pre></div></li><li>使用功能键F10，可以看到进行入列操作的作业标识，及时间。 <div class="fragment"><pre class="fragment">                         Display Journal Entry Details                       
                                                                             
 Journal  . . . . . . :   JRN01           Library  . . . . . . :   LSBIN     
                                                                             
 Sequence . . . . . . :   11075                                              
 Code . . . . . . . . :   Q  - Data queue operation                          
 Type . . . . . . . . :   QS - Send data queue entry, no key                 
                                                                             
 Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN     
 Member . . . . . . . :                   Flag . . . . . . . . :   0         
 Date . . . . . . . . :   09/05/18        Time . . . . . . . . :   11:27:58  
                                          Ref Constraint . . . :   No        
 Count/RRN  . . . . . :   0                                                  
 Job  . . . . . . . . :   254281/LJL/REDLIGHT                                
 Commit cycle ID  . . :   0                                                  
 User profile . . . . :   LJL             Program  . . . . . . :   QCMD      
 Ignore APY/RMV . . . :   No                Library  . . . . . :     *OMITTED
 Trigger  . . . . . . :   No                ASP device . . . . :     *OMITTED
</pre></div></li></ul>
</li><li>查看出列操作对应的journal entries(journal entry type为'QR')。<ul>
<li>使用功能键F10，可以看到进行出列操作的作业标识，及时间。 <div class="fragment"><pre class="fragment">                         Display Journal Entry Details                       
                                                                             
 Journal  . . . . . . :   JRN01           Library  . . . . . . :   LSBIN     
                                                                             
 Sequence . . . . . . :   11077                                              
 Code . . . . . . . . :   Q  - Data queue operation                          
 Type . . . . . . . . :   QR - Rcv data queue entry, no key                  
                                                                             
 Object . . . . . . . :   Q13             Library  . . . . . . :   LSBIN     
 Member . . . . . . . :                   Flag . . . . . . . . :   0         
 Date . . . . . . . . :   09/05/18        Time . . . . . . . . :   12:25:22  
                                          Ref Constraint . . . :   No        
 Count/RRN  . . . . . :   0                                                  
 Job  . . . . . . . . :   254281/LJL/REDLIGHT                                
 Commit cycle ID  . . :   0                                                  
 User profile . . . . :   LJL             Program  . . . . . . :   QCMD      
 Ignore APY/RMV . . . :   No                Library  . . . . . :     *OMITTED
 Trigger  . . . . . . :   No                ASP device . . . . :     *OMITTED
</pre></div></li></ul>
</li></ul>
</li></ul>
<h3><a class="anchor" name="ss_using_q_diffs_operation">
3.3. 操作接口</a></h3>
对于DTAQ和USRQ，i5/OS分别由CL命令，API，和MI指令三个层面提供了操作接口； 下表中将CL命令，API，MI指令分别简写为CL，API，MI： <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>操作 </td><td>Data Queue </td><td>User Queue  </td></tr>
<tr>
<td>创建 </td><td>CL - CRTDTAQ </td><td>API - QUSCRTUQ  </td></tr>
<tr>
<td>删除 </td><td>CL - DLTDTAQ </td><td>CL - DLTUSRQ; API - QUSDLTUQ  </td></tr>
<tr>
<td>入列 </td><td>API - QSNDDTAQ </td><td>MI - ENQ  </td></tr>
<tr>
<td>出列 </td><td>API - QRCVDTAQ </td><td>MI - DEQ  </td></tr>
<tr>
<td>清空 </td><td>API - QCLRDTAQ </td><td>~  </td></tr>
<tr>
<td>获取queue属性 </td><td>API - QMHQRDQD </td><td>MI - MATQAT  </td></tr>
<tr>
<td>获取messages </td><td>API - QMHRDQM </td><td>MI - MATQMSG  </td></tr>
</table>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>"获取messages"指读取当前queue object上的全部或部分消息，该操作并不删除queue messages。</dd></dl>
<h3><a class="anchor" name="ss_using_q_diffs_weight">
3.4. 操作效率</a></h3>
在Information Center等IBM官方文档中没有找到关于DTAQ，USRQ性能对比 的资料，以下仅仅是通过实例，对DTAQ，USRQ的操作效率存在差异这一事实 进行说明。 开始之前，需要提及的一点是，对于可扩展的queue object来说， 扩展queue object是一个耗时的过程， 因此是否需要避免queue object扩展，是在设计使用queue object 进行IPC的应用时，必须考虑的一个问题。 在下面的统计过程中， 我们测试使用的DTAQ及USRQ的初始消息数都给得比较大，以避免在 测试过程中发生扩展，影响统计的准确性。<p>
下面就1000次入列操作分别对以下3种情况进行时间统计，时间单位为1/1000000秒:<ul>
<li>case 1: 入列FIFO USRQ，entry length为64；</li><li>case 2: 入列FIFO DTAQ，entry length为64，DTAQ当前未启用日志；</li><li>case 3: 入列FIFO DTAQ，entry length为64，DTAQ当前已启用日志；</li></ul>
<p>
<table border="1" cellspacing="3" cellpadding="3">
<caption align="bottom">"1000次入列操作时间统计"</caption>
<tr bgcolor="Silver">
<td>操作 </td><td>时间(us,micro-seconds) </td><td>命令/源码  </td></tr>
<tr>
<td>case 1 </td><td>4000 </td><td><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_1">Appendix 1. Enqueue USRQ Q11 for 1000 times</a>  </td></tr>
<tr>
<td>case 2 </td><td>151000 </td><td><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a>  </td></tr>
<tr>
<td>case 3 </td><td>40599000 </td><td><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_3">Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a>  </td></tr>
</table>
<p>
尽管以上统计仅仅是对两个具有相同queue属性的DTAQ，USRQ的入列操作得出的，不具备普遍意义。 但足以说明对DTAQ与USRQ操作的效率差异。而以上统计中，启用日志 前后，入列 DTAQ的效率对比，说明了对DTAQ启用日志带来的效率损失。 对于严重依赖DTAQ完成大数据量IPC的应用系统，应该将这种效率损失计入考虑。<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>此外，创建DTAQ时，如果指定参数FORCE(*YES)(Force to auxiliary storage)，则入列, 出列 操作将消耗更多时间。</dd></dl>
<h3><a class="anchor" name="ss_using_q_diffs_senderid">
3.5. DTAQ message可以包含Sender ID</a></h3>
DTAQ可以在每个queue message中包含入列作业信息(在CRTDTAQ命令文档中称为sender ID)，USRQ如果要实现功能， 需要入列的应用程序通过编码，在message text中添加作业信息。<p>
使一个DTAQ包含入列作业信息，需要在使用CRTDTAQ命令时指定SENDERID(*YES)参数，如： <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/Q14) MAXLEN(64) SENDERID(*YES) TEXT('with sender''s info')
</pre></div><p>
那么所谓sender ID在queue message中是什么样子呢? 入列上面创建的DTAQ Q14，然后使用CL命令 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>的 <a href="../q/page_dspqmsg.html">DSPQMSG</a> 就可以看到: <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('Q14' 'LSBIN' X'00011F' 'ABCDE *^_^*')
DSPQMSG Q(LSBIN/Q14) QTYPE(*DTAQ)
</pre></div> <div class="fragment"><pre class="fragment">                                Queue Message                            
                                                            System:   810
Queue  . . . . . . . :   Q14             Attribute  . . . . . :          
  Library  . . . . . :     LSBIN         Owner  . . . . . . . :   LJL    
Object ASP number  . :   1               Object Domain  . . . :   System 
Type . . . . . . . . :   *DTAQ           Key length . . . . . :   0      
                                         Key length . . . . . :   100    
                                         Number . . . . . . . :   1      
                                                                         
        -------------------Character data-------------------             
Column   *...+....1....+....2....+....3....+....4....+....5              
000001  <span class="stringliteral">'REDLIGHT  LJL       254281LJL       ABCDE *^_^*   '</span>             
000051  <span class="stringliteral">'                                                  '</span>             
</pre></div> 可以看到，所谓sender id就是附加在message text前面的26字节的作业标识， 和10字节的作业当前用户名。 其中，26字节作业标识的构成为：10字节作业名称，10字节USRPRF名称，和 6字节作业号。<h2><a class="anchor" name="sect_using_q_dtaq_howtos">
4. Data Queue操作示例</a></h2>
这里的内容<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt">4.1. 创建一个DTAQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_1">4.1.1. 创建一个FIFO或LIFO类型的DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_2">4.1.2. 创建一个Keyed DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_3">4.1.3. 创建一个包含发送作业标识的DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_4">4.1.4. 关于CRTDTAQ命令的MAXLEN参数</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_crt_5">4.1.5. 关于CRTDTAQ命令的SIZE参数</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_dlt">4.2. 删除一个DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq">4.3. 入列一个DTAQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq_1">4.3.1. 入列一个FIFO或LIFO类型的DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq_2">4.3.2. 入列一个Keyed DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_enq_3">4.3.3. 入列一个Keyed DTAQ</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq">4.4. 出列一个DTAQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq_1">4.4.1. 出列FIFO/LIFO DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq_2">4.4.2. 出列Keyed DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_deq_3">4.4.3. 出列Keyed DTAQ并保留被出列entry</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_clr">4.5. 清空一个DTAQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_matqat">4.6. 获取DTAQ属性</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_dtaq_howtos_matmsg">4.7. 获取Data queue上的消息</a></li></ul>
<h3><a class="anchor" name="ss_using_q_dtaq_howtos_crt">
4.1. 创建一个DTAQ</a></h3>
<h3><a class="anchor" name="ss_using_q_dtaq_howtos_crt_1">
4.1.1. 创建一个FIFO或LIFO类型的DTAQ</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q21) MAXLEN(64) SEQ(*FIFO) TEXT('FIFO, entry length=64')
CRTDTAQ DTAQ(Q22) MAXLEN(64) SEQ(*LIFO) TEXT('LIFO, entry length=64')
</pre></div> 向LIFO DTAQ Q22入列几条message，使用 <a href="../q/page_dspqmsg.html">DSPQMSG</a> 命令可以看到，LIFO中消息 是按到达顺序降序存放的。 <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('Q22' 'LSBIN' X'00003F' 'abc')
CALL PGM(QSNDDTAQ) PARM('Q22' 'LSBIN' X'00003F' 'def')
DSPQMSG Q22
<span class="comment">/* 结果 */</span>
                Time                        Message
Opt     Number  enqueued                    Key    
             1  2009-05-19-16.36.49.641679         
             2  2009-05-19-16.36.40.429570         
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_crt_2">
4.1.2. 创建一个Keyed DTAQ</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q23) MAXLEN(64) SEQ(*KEYED) KEYLEN(8) TEXT('keyed, key length = 8')
</pre></div> 向Keyed DTAQ Q23入列几条消息，使用 <a href="../q/page_dspqmsg.html">DSPQMSG</a> 命令查看 <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('Q23' 'LSBIN' X'00003F' 'abc' X'008F' '00000005')
CALL PGM(QSNDDTAQ) PARM('Q23' 'LSBIN' X'00003F' 'def' X'008F' '00000002')
CALL PGM(QSNDDTAQ) PARM('Q23' 'LSBIN' X'00003F' 'ghi' X'008F' '00000003')

DSPQMSG Q(Q23)
<span class="comment">/* 结果 */</span>
                Time                        Message 
Opt     Number  enqueued                    Key     
             1  2009-05-19-16.48.14.771519  00000002
             2  2009-05-19-16.48.38.547735  00000003
             3  2009-05-19-16.48.04.499240  00000005
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_crt_3">
4.1.3. 创建一个包含发送作业标识的DTAQ</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q24) MAXLEN(64) SENDERID(*YES)
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_crt_4">
4.1.4. 关于CRTDTAQ命令的MAXLEN参数</a></h3>
MAXLEN参数指DTAQ entry的最大长度，上限是64512。 如 <a class="el" href="page_using_q_cn.html#sect_using_q_intro">2. 对i5/OS Queue Object的介绍</a> 中提到的， 虽然在入列时，可以指定小于MAXLEN的message text长度，但 实际存储时每条message text所占用的存储仍是MAXLEN指定的 字节数。因此，如果为了通过DTAQ交换变长数据，而指定冗余 的MAXLEN参数，将导致存储的浪费，DTAQ可容纳entry数降低， 以及操作效率降低。要实现变长数据的交换，请参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer">6.5. 通过i5/OS queue object传递变长数据</a><h3><a class="anchor" name="ss_using_q_dtaq_howtos_crt_5">
4.1.5. 关于CRTDTAQ命令的SIZE参数</a></h3>
SIZE参数包含两个元素：Maximum number of entries，和Initial number of entries。 需要注意的是：<ul>
<li>Maximum number of entries可以指定具体的最大entry数，但 必須大于等Initial number of entries；实际创建的DTAQ允许的 最大entry数住住略大于使用CRTDTAQ命令时指定的；</li><li>Maximum number of entries有两个special value：*MAX16MB，和*MAX2GB； 这两个special value是指DTAQ所占用的存储空间上限，而不是最大允许 的entry数；实际的最大允许entry数，会由entry长度，是否包含发送 作业标识信息，对按键值出列的DTAQ的键值长度有关； 要取得实际创建的DTAQ的最大允许entry数，应使用 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>的 <a href="../q/page_dspqd.html">DSPQD</a> 命令查看。</li><li>Initial number of entries指DTAQ创建时，预先为queue entries分配的存储空间， 该属性对于DTAQ而言有两方面的意义：<ul>
<li>使用DTAQ创建时预先分配的存储空间，避免了在运行时刻扩展DTAQ， 会带来更好的入列操作效率；</li><li>如果同时指定Automatic reclaim(AUTORCL)参数为*YES，即允许 DTAQ中entry数降为0时，自动回收存储，则DTAQ存储空间将被 回收至可容纳Initial number of entries指定的entry数的尺寸。</li></ul>
</li></ul>
<h3><a class="anchor" name="ss_using_q_dtaq_howtos_dlt">
4.2. 删除一个DTAQ</a></h3>
删除一个DTAQ，使用CL命令DLTDTAQ，如: <div class="fragment"><pre class="fragment">DLTDTAQ LSBIN/Q21
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_enq">
4.3. 入列一个DTAQ</a></h3>
入列一个DTAQ需要使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qsnddtaq.htm">Send to a Data Queue (QSNDDTAQ)</a> API。<h3><a class="anchor" name="ss_using_q_dtaq_howtos_enq_1">
4.3.1. 入列一个FIFO或LIFO类型的DTAQ</a></h3>
<div class="fragment"><pre class="fragment">call qsnddtaq parm(          
     <span class="stringliteral">'Q21'</span>         <span class="comment">/* char(10)，DTAQ名称 */</span>  
     <span class="stringliteral">'LSBIN'</span>       <span class="comment">/* char(10)，库名 */</span>
     X<span class="stringliteral">'00003F'</span>     <span class="comment">/* pkd(5,0)，入列message text长度 */</span> 
     <span class="stringliteral">'ABC'</span>         <span class="comment">/* char(*)，message text */</span>          
     )                       
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_enq_2">
4.3.2. 入列一个Keyed DTAQ</a></h3>
<div class="fragment"><pre class="fragment">call qsnddtaq parm(      
     <span class="stringliteral">'Q23'</span>         <span class="comment">/* char(10)，DTAQ名称 */</span>  
     <span class="stringliteral">'LSBIN'</span>       <span class="comment">/* char(10)，库名 */</span>
     X<span class="stringliteral">'00003F'</span>     <span class="comment">/* pkd(5,0)，入列message text长度 */</span> 
     <span class="stringliteral">'abc'</span>         <span class="comment">/* char(*)，message text */</span>          
     x<span class="stringliteral">'008F'</span>       <span class="comment">/* pkd(3,0)，键值长度 */</span>
     <span class="stringliteral">'00000001'</span>    <span class="comment">/* char(*)，键值内容 */</span>
     )                   
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_enq_3">
4.3.3. 入列一个Keyed DTAQ</a></h3>
ILE RPG程序<a href="src/r101.rpgle">r101.rpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r101.rpgle</span>
<span class="comment">      * enqueue DTAQ Q23(keyed, key length=8, entry length=64)</span>
<span class="comment">      */</span>

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm(<span class="stringliteral">'QSNDDTAQ'</span>)
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       64a   options(*varsize)
     d   key_len                      3p 0
     d   key                          8a   options(*varsize)

     d qname           s             10a   inz('Q23')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0 inz(64)
     d entry           s             64a
     d key_len         s              3p 0 inz(8)
     d key             s              8a

      /free
          entry = 'abc';
          key = '00000002';
          qsnddtaq(qname
                   : qlib
                   : entry_len
                   : entry
                   : key_len
                   : key );

          *inlr = *on;
      /end-free
     <span class="comment">/* eof */</span>
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_deq">
4.4. 出列一个DTAQ</a></h3>
出列一个DTAQ需要使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qrcvdtaq.htm">Receive Data Queue (QRCVDTAQ)</a> API。<h3><a class="anchor" name="ss_using_q_dtaq_howtos_deq_1">
4.4.1. 出列FIFO/LIFO DTAQ</a></h3>
OPM CL程序<a href="src/cl101.clp">cl101.clp</a> 以无期限等待方式出列FIFO DTAQ Q21 <div class="fragment"><pre class="fragment">             <span class="comment">/************************************************/</span>
             <span class="comment">/* @FILE CL101.CLP                              */</span>
             <span class="comment">/* DEQUEUE FIFO DTAQ Q21                        */</span>
             <span class="comment">/************************************************/</span>
             PGM
             DCL        VAR(&amp;QNAM) TYPE(*CHAR) LEN(10) VALUE('Q21')
             DCL        VAR(&amp;QLIB) TYPE(*CHAR) LEN(10) VALUE('LSBIN')
             DCL        VAR(&amp;ENTLEN) TYPE(*DEC) LEN(5 0) <span class="comment">/* length +</span>
<span class="comment">                          of dequeued data */</span>
             DCL        VAR(&amp;ENTRY) TYPE(*CHAR) LEN(64)
             DCL        VAR(&amp;TIMEOUT) TYPE(*DEC) LEN(5 0) VALUE(-1) +
                          <span class="comment">/* dequeue infinittely */</span>
             DCL        VAR(&amp;MSG) TYPE(*CHAR) LEN(32) VALUE('entry +
                          dequeued:')

             CALL       PGM(QRCVDTAQ) PARM(&amp;QNAM &amp;QLIB &amp;ENTLEN +
                          &amp;ENTRY &amp;TIMEOUT)
             CHGVAR     VAR(%SST(&amp;MSG 17 16)) VALUE(&amp;ENTRY)
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&amp;MSG)

             ENDPGM
             <span class="comment">/* EOF - CL101.CLP */</span>
</pre></div><p>
OPM CL程序<a href="src/cl105.clp">cl105.clp</a> 以指定超时值等待方式出列FIFO DTAQ Q21 <div class="fragment"><pre class="fragment">             <span class="comment">/************************************************/</span>
             <span class="comment">/* @FILE CL101.CLP                              */</span>
             <span class="comment">/* DEQUEUE FIFO DTAQ Q21 WITH TIMEOUT           */</span>
             <span class="comment">/************************************************/</span>
             PGM
             DCL        VAR(&amp;QNAM) TYPE(*CHAR) LEN(10) VALUE('Q21')
             DCL        VAR(&amp;QLIB) TYPE(*CHAR) LEN(10) VALUE('LSBIN')
             DCL        VAR(&amp;ENTLEN) TYPE(*DEC) LEN(5 0) <span class="comment">/* length +</span>
<span class="comment">                          of dequeued data */</span>
             DCL        VAR(&amp;ENTRY) TYPE(*CHAR) LEN(64)
             DCL        VAR(&amp;TIMEOUT) TYPE(*DEC) LEN(5 0) VALUE(5) +
                          <span class="comment">/* time-out value = 5s */</span>
             DCL        VAR(&amp;MSG) TYPE(*CHAR) LEN(32) VALUE('entry +
                          dequeued:')

             CALL       PGM(QRCVDTAQ) PARM(&amp;QNAM &amp;QLIB &amp;ENTLEN +
                          &amp;ENTRY &amp;TIMEOUT)
             IF         COND(&amp;ENTLEN *EQ 0) THEN(DO)
             CHGVAR     VAR(&amp;MSG) VALUE('Dequeue timed-out')
             GOTO       CMDLBL(SENDMSG)
             ENDDO
             CHGVAR     VAR(%SST(&amp;MSG 17 16)) VALUE(&amp;ENTRY)
 SENDMSG:    SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&amp;MSG)

             ENDPGM
             <span class="comment">/* EOF - CL101.CLP */</span>
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_deq_2">
4.4.2. 出列Keyed DTAQ</a></h3>
DTAQ Q23，类型为Keyed，entry长度64，key长度8，不含发送作业 标识信息。OPM CL程序<a href="src/cl102.clp">cl102.clp</a>出列DTAQ Q23中 键值大于'00000001'的entry。 <div class="fragment"><pre class="fragment">             <span class="comment">/************************************************/</span>
             <span class="comment">/* @FILE CL102.CLP                              */</span>
             <span class="comment">/* DEQUEUE KEYED DTAQ Q23                       */</span>
             <span class="comment">/************************************************/</span>
             PGM
             DCL        VAR(&amp;QNAM) TYPE(*CHAR) LEN(10) VALUE('Q23')
             DCL        VAR(&amp;QLIB) TYPE(*CHAR) LEN(10) VALUE('LSBIN')
             DCL        VAR(&amp;ENTLEN) TYPE(*DEC) LEN(5 0)
             DCL        VAR(&amp;ENTRY) TYPE(*CHAR) LEN(64)
             DCL        VAR(&amp;TIMEOUT) TYPE(*DEC) LEN(5 0) VALUE(-1) +
                          <span class="comment">/* dequeue infinittely */</span>
             DCL        VAR(&amp;KEYORDER) TYPE(*CHAR) LEN(2) +
                          VALUE('GT') <span class="comment">/* dequeue queue entries +</span>
<span class="comment">                          whose key value aregreater than variable +</span>
<span class="comment">                          &amp;KEY */</span>
             DCL        VAR(&amp;KEYLEN) TYPE(*DEC) LEN(3 0) VALUE(8)
             DCL        VAR(&amp;KEY) TYPE(*CHAR) LEN(8) VALUE('00000001')
             DCL        VAR(&amp;SNDINFOLEN) TYPE(*DEC) LEN(3 0) +
                          VALUE(0) <span class="comment">/* no sender info */</span>
             DCL        VAR(&amp;SNDINFO) TYPE(*CHAR) LEN(1)
             DCL        VAR(&amp;MSG) TYPE(*CHAR) LEN(96) +
                          VALUE('key:         ; message text: ')

             CALL       PGM(QRCVDTAQ) PARM(&amp;QNAM &amp;QLIB &amp;ENTLEN +
                          &amp;ENTRY &amp;TIMEOUT &amp;KEYORDER &amp;KEYLEN &amp;KEY +
                          &amp;SNDINFOLEN &amp;SNDINFO)
             CHGVAR     VAR(%SST(&amp;MSG 6 8)) VALUE(&amp;KEY)
             CHGVAR     VAR(%SST(&amp;MSG 30 64)) VALUE(&amp;ENTRY)
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&amp;MSG)

             ENDPGM
             <span class="comment">/* EOF - CL102.CLP */</span>
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_deq_3">
4.4.3. 出列Keyed DTAQ并保留被出列entry</a></h3>
DTAQ Q23，类型为Keyed，entry长度64，key长度8，不含发送作业 标识信息。ILE RPG程序<a href="src/r102.rpgle">rl102.rpgle</a>出列DTAQ Q23中 键值大于'00000001'的entry，并保留DTAQ中的entry。 <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r102.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * DTAQ Q23，类型为基于键值出列，entry长度64，key长度8，</span>
<span class="comment">      * 不含发送作业标识信息。</span>
<span class="comment">      *</span>
<span class="comment">      * 出列DTAQ Q23中键值大于'00000001'的entry，并保留DTAQ中的entry。</span>
<span class="comment">      */</span>

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm(<span class="stringliteral">'QRCVDTAQ'</span>)
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       64a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          8a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     d qname           s             10a   inz('Q23')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0
     d entry           s             64a
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('GT')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(8)
     d key             s              8a   inz('00000001')
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d remove_msg      s             10a   inz('*NO')                           <span class="comment">/* do NOT remove message from DTAQ */</span>
     d receiver_len    s              5p 0 inz(64)
     d ec              ds                  likeds(qusec_t)
     d msg             s             16a

      /free
          ec.bytes_in = 256;
          qrcvdtaq(  qname
                   : qlib
                   : entry_len
                   : entry
                   : timeout
                   : key_order
                   : key_len
                   : key
                   : sender_info_len
                   : sender_info
                   : remove_msg
                   : receiver_len
                   : ec );

           msg = %subst(entry : 1 : 16);
           dsply key '*EXT' msg;

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r102.rpgle */</span>
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>API QRCVDTAQ的参数9，键值数据是一个输入/输出参数，在发起调用 时表示输入的键值比较条件，在调用返回时，内容为出列到的message 的键值数据内容。</dd></dl>
<h3><a class="anchor" name="ss_using_q_dtaq_howtos_clr">
4.5. 清空一个DTAQ</a></h3>
清空一个DTAQ需要使用API <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qclrdtaq.htm">Clear Data Queue (QCLRDTAQ)</a> ，如: <div class="fragment"><pre class="fragment">CALL PGM(QCLRDTAQ) PARM('Q21' 'LSBIN')
</pre></div><h3><a class="anchor" name="ss_using_q_dtaq_howtos_matqat">
4.6. 获取DTAQ属性</a></h3>
获取DTAQ属性需要使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qmhqrdqd.htm">Retrieve Data Queue Description (QMHQRDQD)</a> API。 QMHQRDQD支持两种属性 格式，RDQD0100和RDQD0200，前者用于描述普通DTAQ，后者用于描述 DDM DTAQ。下面示例中的ILE RPG程序 <a href="src/r103.rpgle">r103.rpgle</a> 使用QMHQRDQD获取DTAQ Q23的属性。<p>
<div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r103.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * retrieve attribtutes of a DTAQ</span>
<span class="comment">      * Keyed DTAQ Q23 with entry length 64, key length 8,</span>
<span class="comment">      * does not include sender's ID</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     <span class="comment">/* receiver structure in format RDQD0100 */</span>
     d rdqd0100_t      ds           112    qualified
     d   bytes_...
     d     returned                  10i 0                                      <span class="comment">/* length of attribute data returned */</span>
     d   bytes_...
     d     available                 10i 0                                      <span class="comment">/* length DTAQ attribute data */</span>
     d   entry_len                   10i 0                                      <span class="comment">/* DTAQ entry length */</span>
     d   key_len                     10i 0                                      <span class="comment">/* DTAQ key length */</span>
     d   sequence                     1a                                        <span class="comment">/* DTAQ type:        */</span>
     d                                                                          <span class="comment">/*   - 'F', FIIO     */</span>
     d                                                                          <span class="comment">/*   - 'K', Keyed    */</span>
     d                                                                          <span class="comment">/*   - 'L', LIFO     */</span>
     d   include_...
     d    sender_info                 1a                                        <span class="comment">/* include sender info or not: Y/N */</span>
     d   force_to_stg                 1a                                        <span class="comment">/* force to storage: Y/N */</span>
     d   text                        50a                                        <span class="comment">/* text description */</span>
     d   ddm_dtaq                     1a                                        <span class="comment">/* is q DDM DTAQ:    */</span>
     d                                                                          <span class="comment">/*   - '0', no       */</span>
     d                                                                          <span class="comment">/*   - '1', yes      */</span>
     d   auto_reclaim                 1a                                        <span class="comment">/* automatic reclaim storage */</span>
     d                                                                          <span class="comment">/*   - '0', no       */</span>
     d                                                                          <span class="comment">/*   - '1', yes      */</span>
     d   reserved                     1a
     d   num_messages                10i 0                                      <span class="comment">/* messages currently on the DTAQ */</span>
     d   entries_...
     d     allocated                 10i 0                                      <span class="comment">/* entries currently allocated */</span>
     d   qname                       10a
     d   qlib                        10a
     d   max_messages                10i 0                                      <span class="comment">/* maximum number of messages */</span>
     d   init_...
     d     messages                  10i 0                                      <span class="comment">/* initial number of messages */</span>

     <span class="comment">/* prototype of API QMHQRDQD */</span>
     d qmhqrdqd        pr                  extpgm('QMHQRDQD')
     d   dtaq_attr                         likeds(rdqd0100_t)                   <span class="comment">/* receiver data */</span>
     d   receiver_len                10i 0                                      <span class="comment">/* length of receiver data */</span>
     d   format_name                  8a                                        <span class="comment">/* format name               */</span>
     d                                                                          <span class="comment">/*   - RDQD0100, normal DTAQ */</span>
     d                                                                          <span class="comment">/*   - RDQD0200, DDM DTAQ    */</span>
     d   qname_lib                   20a                                        <span class="comment">/* DTAQ name/library, e.g.   */</span>
     d                                                                          <span class="comment">/*   'Q23       LSBIN     '  */</span>

     d do_report       pr

     d dtaq_attr       ds                  likeds(rdqd0100_t)
     d len             s             10i 0 inz(112)
     d format          s              8a   inz('RDQD0100')
     d qname_lib       s             20a   inz('Q23       LSBIN')

      /free

          qmhqrdqd(  dtaq_attr
                   : len
                   : format
                   : qname_lib );

          do_report();

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - main procedure */</span>

     p do_report       b

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of QMHSNDPM */</span>
     d qmhsndpm        pr                  extpgm('QMHSNDPM')
     d   msgid                        7a
     d   msgf                        20a
     d   msgdata                    128a   options(*varsize)
     d   msgdata_len                 10i 0
     d   msgtype                     10a
     d   callstack_...
     d     entry                     10a
     d   callstack_...
     d     counter                   10i 0
     d   msgkey                       4a
     d   ec                                likeds(qusec_t)

     d msgid           s              7a   inz('CPF9898')
     d msgf            s             20a   inz('QCPFMSG   QSYS')
     d msgdata         s            128a
     d msgdata_len     s             10i 0
     d msgtype         s             10a   inz('*INFO')
     d callstack_...
     d   entry         s             10a   inz('*PGMBDY')
     d callstack_...
     d   counter       s             10i 0 inz(1)
     d msgkey          s              4a
     d ec              ds                  likeds(qusec_t)
     d msg             s            128a

      /free

          ec.bytes_in = 256;

          <span class="comment">// report DTAQ entry length</span>
          msgdata = 'Entry length: ' + %<span class="keywordtype">char</span>(dtaq_attr.entry_len);
          msgdata_len = %len(%trim(msgdata));
          qmhsndpm(  msgid
                   : msgf
                   : msgdata
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

          <span class="comment">// report DTAQ key length</span>
          msgdata = 'Key length: ' + %<span class="keywordtype">char</span>(dtaq_attr.key_len);
          msgdata_len = %len(%trim(msgdata));
          qmhsndpm(  msgid
                   : msgf
                   : msgdata
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

          <span class="comment">// report more DTAQ attributes</span>
          <span class="comment">// ... ...</span>

      /end-free
     p do_report       e

     <span class="comment">/* eof - r103.rpgle */</span>
</pre></div><p>
更多示例请参考 <a href="../q/page_dspqd.html">DSPQD</a> 源码 <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qattr.mi?view=markup">qattr.mi</a> 中的internal entry point display-ddmq-attr(line 361)，和 display-dtaq-attr(line 396)。<h3><a class="anchor" name="ss_using_q_dtaq_howtos_matmsg">
4.7. 获取Data queue上的消息</a></h3>
获取DTAQ上的消息需要使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/qmhrdqm.htm">Retrieve Data Queue Message (QMHRDQM)</a> API。请参考 <a href="../q/page_dspqmsg.html">DSPQMSG</a> 源码 <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qmsg.mi?view=markup">qmsg.mi</a> 中：<ul>
<li>internal entry point mat-keyed-q-msg(line 451)，读取Keyed DTAQ上的消息</li><li>internal entry point mat-nonkeyed-q-msg(line 580)，读取FIFO或LIFO DTAQ上的消息</li></ul>
<p>
在使用QMHRDQM时需要注意的是:<ul>
<li>API QMHRDQM不能用于操作DDM DTAQ；</li><li>由于获取DTAQ中全部或部分消息所需要的存储不确定，因此通常对 QMHRDQM进行两次调用，第一次取得需要分配的存储大小， 实际分配用于接收DTAQ消息的存储后，再进行第二次调用，真正 读取DTAQ上的消息。</li></ul>
<h2><a class="anchor" name="sect_using_q_usrq_howtos">
5. User Queue操作示例</a></h2>
<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt">5.1. 创建一个USRQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt_1">5.1.1. USRQ上最大可容纳的消息数</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt_2">5.1.2. USRQ的Domain属性</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_crt_3">5.1.3. 关于参数Number of queue extensions</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_dlt">5.2. 删除一个USRQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_enq">5.3. 入列一个USRQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_deq">5.4. 出列一个USRQ</a><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_deq_1">5.4.1.使用不等待方式执行DEQ指令</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_deq_2">5.4.2. 使用等待方式执行DEQ指令</a></li></ul>
</li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_clr">5.5. 清空USRQ</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_matqat">5.6. 获取USRQ属性</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usrq_howtos_matqmsg">5.7. 获取USRQ上的消息</a></li></ul>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_crt">
5.1. 创建一个USRQ</a></h3>
创建一个USRQ需要使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/quscrtuq.htm">Create User Queue (QUSCRTUQ)</a> API。<p>
QUSCRTUQ参数如下所示:<ul>
<li>Required Parameter Group:<ul>
<li>1 Qualified user queue name, Input, Char(20)</li><li>2 Extended attribute, Input, Char(10)</li><li>3 Queue type, Input, Char(1)</li><li>4 Key length, Input, Binary(4)</li><li>5 Maximum message size, Input, Binary(4)</li><li>6 Initial number of messages, Input, Binary(4)</li><li>7 Additional number of messages, Input, Binary(4)</li><li>8 Public authority, Input, Char(10)</li><li>9 Text description, Input, Char(50)</li></ul>
</li><li>Optional Parameter Group 1:<ul>
<li>10 Replace, Input, Char(10)</li><li>11 Error code, I/O, Char(*)</li></ul>
</li><li>Optional Parameter Group 2:<ul>
<li>12 Domain, Input, Char(10)</li><li>13 Pointers, Input, Char(10)</li></ul>
</li></ul>
<p>
<ul>
<li>Optional Parameter Group 3:<ul>
<li>14 Number of queue extensions, Input, Binary(4)</li><li>15 Reclaim storage, Input, Char(1)</li></ul>
</li></ul>
<p>
关于API QUSCRTUQ的详细文档请参考 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/quscrtuq.htm">Create User Queue (QUSCRTUQ) API</a><h3><a class="anchor" name="ss_using_q_usrq_howtos_crt_1">
5.1.1. USRQ上最大可容纳的消息数</a></h3>
参数<em>Initial number of messages</em>(INIT_MSGS) <em>Additional number of messages</em>(EXT_MSGS) 和<em>Number of queue extensions</em>(NUM_EXTENDS) 一起决定了一个USRQ上最大可容纳的消息数(MAX_MSGS)。<br>
 <div class="fragment"><pre class="fragment">MAX_MSGS = INIT_MSGS + EXT_MSGS * NUM_EXTENDS
<span class="comment">/*</span>
<span class="comment">例如:</span>
<span class="comment">    INIT_MSGS = 1</span>
<span class="comment">    EXT_MSGS = 2</span>
<span class="comment">    NUM_EXTENDS = 1</span>
<span class="comment">则</span>
<span class="comment">    MAX_MSGS = 1 + 2 * 1 = 3</span>
<span class="comment">即USRQ可容纳的最大消息数为3，当试图向USRQ入列第4条消息时</span>
<span class="comment">将引发MCH3802(hex 2602)异常。</span>
<span class="comment">   */</span>
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>通常，机器将对实际创建的USRQ的最大可容纳消息数进行 微小的修改。要取得精确的最大消息数可以使用 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>中的 CL命令 <a href="../q/page_dspqd.html">DSPQD</a> 。</dd></dl>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_crt_2">
5.1.2. USRQ的Domain属性</a></h3>
参数<em>Domain</em>与系统值QALWUSRDMN决定了QUSCRTUQ创建的USRQ的Domain属性。 <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>QALWUSRDMN System Value </td><td>Destination Library </td><td>Optional Domain Parameter </td><td>Domain of Created Object  </td></tr>
<tr>
<td>*ALL </td><td>Any </td><td>*DEFAULT </td><td>User domain  </td></tr>
<tr>
<td>*ALL </td><td>Any </td><td>*SYSTEM </td><td>System domain  </td></tr>
<tr>
<td>*ALL </td><td>Any </td><td>*USER </td><td>User domain  </td></tr>
<tr>
<td>QTEMP </td><td>QTEMP </td><td>*DEFAULT </td><td>User domain  </td></tr>
<tr>
<td>QTEMP </td><td>QTEMP </td><td>*SYSTEM </td><td>System domain  </td></tr>
<tr>
<td>QTEMP </td><td>QTEMP </td><td>*USER </td><td>User domain  </td></tr>
<tr>
<td>Does not contain library name </td><td>Library name </td><td>*DEFAULT </td><td>System domain  </td></tr>
<tr>
<td>Does not contain library name </td><td>Library name </td><td>*SYSTEM </td><td>System domain  </td></tr>
<tr>
<td>Does not contain library name </td><td>Library name </td><td>*USER </td><td>None; error is returned  </td></tr>
</table>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_crt_3">
5.1.3. 关于参数Number of queue extensions</a></h3>
参数<em>Number of queue extensions</em>决定了USRQ的最大扩展 次数。Information Center V5R2, V5R4中 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/quscrtuq.htm">API QUSCRTUQ</a> 文档中的说明是: <div class="fragment"><pre class="fragment">Number of queue extensions
    INPUT; BINARY(4)
    The maximum number of extensions allowed for the user queue.
    A value of -1 indicates that the maximum number of extensions
    will be chosen by the machine.
    If this parameter is not specified, 0 is assumed.
</pre></div> 但在V5R2上的实验结果是，<em>Number of queue extensions</em> 指定 -1 或不指定时，USRQ的最大扩展次数都是由机器决定的。 参考下面示例可见，两种情况下USRQ的`Choose maximum number of extends`属性 和`Maximum number of extends`属性完全相同：<ul>
<li>创建USRQ，指定Number of queue extensions参数为-1 <div class="fragment"><pre class="fragment">       <span class="comment">/* 创建USRQ，指定Number of queue extensions参数为-1 */</span>
       CALL PGM(QUSCRTUQ) PARM(
            'Q34       LSBIN'   <span class="comment">/* USRQ name */</span>
            'QQ'                <span class="comment">/* extended attribute */</span>
            'K'                 <span class="comment">/* queue type */</span>
            X'00000008'         <span class="comment">/* key length */</span>
            X'00000040'         <span class="comment">/* entry length */</span>
            X'00000001'         <span class="comment">/* initial number of messages */</span>
            X'00000002'         <span class="comment">/* number of messages per extension */</span>
            '*EXCLUDE'          <span class="comment">/* public authority */</span>
            '`Number of queue extensions`parameter  = -1' <span class="comment">/* text description */</span>
            '*YES'                                        <span class="comment">/* replace */</span>
            X'0000002000000000000000000000000000000000000000000000000000000000' <span class="comment">/* error code structure */</span>
            '*USER'             <span class="comment">/* object domain */</span>
            '*YES'              <span class="comment">/* contains poniter */</span>
            X'FFFFFFFF'         <span class="comment">/* number of queue extensions */</span>
            '0')                <span class="comment">/* auto-reclaim storage */</span>
       <span class="comment">/*</span>
<span class="comment">          使用DSPQD命令检查USRQ的`Choose maximum number of extends`属性</span>
<span class="comment">          和`Maximum number of extends`属性</span>
<span class="comment">        */</span>
       DSPQD Q(Q34) QTYPE(*USRQ)
       <span class="comment">/* 结果如下 */</span>
       Queue attributes:                                         
         Message content  . . . . . :   Contains scalar data only
         Queue type . . . . . . . . :   Keyed                    
         Queue overflow action  . . :   Extend queue             
         Choose maximum number of                                
           extends  . . . . . . . . :   Machine   <span class="comment">/* 由机器决定最大扩展次数 */</span>
         Reclaim storage  . . . . . :   0                           
       
       ... ...
       
       Maximum number of extends  . :   87380     <span class="comment">/* 机器决定的最大扩展次数 */</span>
</pre></div></li><li>创建USRQ，不指定Number of queue extensions参数 <div class="fragment"><pre class="fragment">       <span class="comment">/* 创建USRQ，不指定Number of queue extensions参数 */</span>
       CALL PGM(QUSCRTUQ) PARM('Q34       LSBIN' 'QQ' 'K'
           X'00000008' X'00000040' X'00000001' X'00000002'
           '*EXCLUDE' 'Do NOT specify `Number of queue extensions` parameter')
    
       <span class="comment">/*</span>
<span class="comment">          使用DSPQD命令检查USRQ的`Choose maximum number of extends`属性</span>
<span class="comment">          和`Maximum number of extends`属性</span>
<span class="comment">        */</span>
       DSPQD Q(Q34) QTYPE(*USRQ)
       <span class="comment">/* 结果如下 */</span>
       Queue attributes:                                         
         Message content  . . . . . :   Contains scalar data only
         Queue type . . . . . . . . :   Keyed                    
         Queue overflow action  . . :   Extend queue             
         Choose maximum number of                                
           extends  . . . . . . . . :   Machine   <span class="comment">/* 由机器决定最大扩展次数 */</span>
         Reclaim storage  . . . . . :   0                           
       
       ... ...
       
       Maximum number of extends  . :   87380     <span class="comment">/* 机器决定的最大扩展次数 */</span>
</pre></div></li></ul>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_dlt">
5.2. 删除一个USRQ</a></h3>
删除一个USRQ可以使用CL命令DLTUSRQ或API QUSDLTUQ，如: <div class="fragment"><pre class="fragment"><span class="comment">/* CL命令DLTUSRQ */</span>
DLTUSRQ USRQ(LSBIN/Q31)
<span class="comment">/* API QUSCLTUQ */</span>
CALL PGM(QUSDLTUQ) PARM('Q34       LSBIN'
    X'0000002000000000000000000000000000000000000000000000000000000000')
</pre></div><h3><a class="anchor" name="ss_using_q_usrq_howtos_enq">
5.3. 入列一个USRQ</a></h3>
入列一个USRQ需要使用MI指令 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/ENQ.htm">ENQ</a> 。下面通过两个示例程序说明使用 ILE HLL或直接使用MI完成对USRQ的入列。<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>必须注意的是，使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/ENQ.htm">ENQ</a> 指令时，参数3 message text必須是对齐到16字节边界的。</dd></dl>
ILE RPG程序 <a href="src/r104.rpgle">r104.rpgle</a> 使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/RSLVSP.htm">RSLVSP</a> 指令取得USRQ objet Q31的system pointer，然后使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/ENQ.htm">ENQ</a> 指令入列USRQ Q31。 <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r104.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * enqueue USRQ Q31</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     <span class="comment">/* my protoype */</span>
     d i_main          pr                  extpgm('R104')
     d   p_key                        8a
     d   p_text                      64a

     d q               s               *
     d option          ds            34    qualified
     d   type                         2a   inz(x'0A02')                         <span class="comment">/* USRQ's MI object type: hex 0A02 */</span>
     d   name                        30a   inz('Q31')                           <span class="comment">/* USRQ name */</span>
     d   auth                         2a   inz(x'0000')
     <span class="comment">/* prototype of MI instruction RSLVSP */</span>
     d rslvsp          pr                  extproc('_RSLVSP2')
     d   syp                           *
     d   option                        *   value
     <span class="comment">/* prototype of MI instruction ENQ */</span>
     d enq             pr                  extproc('_ENQ')
     d   q                             *
     d   prefix                        *   value
     d   text                          *   value

     d prefix          ds                  qualified                            <span class="comment">/* message prefix */</span>
     d   text_len                    10i 0                                      <span class="comment">/* length of message text */</span>
     d   key                          8a   inz('00000001')                      <span class="comment">/* key data */</span>
     d text            s             64a   inz('hi, i''m rpg program R104:p')   <span class="comment">/* message text */</span>

     d i_main          pi
     d   p_key                        8a
     d   p_text                      64a

      /free

          rslvsp(q : %addr(option));

          prefix.key = p_key;
          text = p_text;
          enq(q : %addr(prefix) : %addr(text));

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r104.rpgle */</span>
</pre></div><p>
与<a href="src/r104.rpgle">r104.rpgle</a>实现相同功能的MI程序 <a href="src/enq31.mi">enq31.mi</a> <div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * @file enq31.mi</span>
<span class="comment"> *</span>
<span class="comment"> * enqueue USRQ Q31(keyed, key length = 8, entry lenght=64)</span>
<span class="comment"> *</span>
<span class="comment"> * usage example: CALL ENQ31 PARM('00000003' 'ABCDE...')</span>
<span class="comment"> */</span>

dcl sysptr q <span class="keyword">auto</span> init(<span class="stringliteral">"Q34"</span>, ctx(<span class="stringliteral">"LSBIN"</span>), type(q, 02)) ; 
dcl dd message-prefix char(9) auto ;
        dcl dd prefix-msglen bin(4) def(message-prefix) pos(1);
        dcl dd prefix-key <span class="keywordtype">char</span>(5) def(message-prefix) pos(5) ; 

dcl spcptr .key parm                ; 
dcl spcptr .text parm                ; 
dcl ol pl-main(.key, .text) parm ext        ; 

dcl dd key <span class="keywordtype">char</span>(8) bas(.key)    ; 
dcl dd text <span class="keywordtype">char</span>(64) bas(.text) ; 

dcl dd msg <span class="keywordtype">char</span>(64) auto bdry(16) ;
dcl spcptr msg-ptr auto init(msg) ; 

entry *(pl-main) ext;

        <span class="comment">/* enq */</span>
        cpynv prefix-msglen, 64;
        cpybla prefix-key, key  ;
        cpybla msg, text        ; 
        enq q, message-prefix, msg-ptr ; 

        rtx *;

pend;
<span class="comment">/* eof - enq31.mi */</span>
</pre></div><h3><a class="anchor" name="ss_using_q_usrq_howtos_deq">
5.4. 出列一个USRQ</a></h3>
出列一个USRQ需要使用MI指令 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a> 。 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a> 指令操作数列表如下:<ul>
<li>operand 1, message prefix</li><li>operand 2, message text</li><li>operand 3, system pointer to the queue object</li></ul>
<p>
其中operand 1 <em>message prefix</em> 格式如下: <div class="fragment"><pre class="fragment">Offset  
Dec   Hex   Field Name                                      Data Type and Length
0   0   Timestamp of enqueue of message     Char(8) ++
8   8   Dequeue wait time-out value                     Char(8) +
          (ignored <span class="keywordflow">if</span> branch options specified) 
16  10  Size of message dequeued                  Bin(4) ++
          (The maximum allowable size of a queue message
                is 64 K bytes.)
20  14  Access state modification option indicator  Char(1) +
                and message selection criteria  
20  14  Access state modification option when entering Dequeue wait   Bit 0 +
                0 =   Access state is not modified
                1 =   Access state is modified
20  14  Access state modification option when leaving Dequeue wait  Bit 1 +
                0 =   Access state is not modified
                1 =   Access state is modified
20  14  Multiprogramming level option                             Bit 2 +
                0 =   Leave current MPL <span class="keyword">set</span> at Dequeue wait
                1 =   Remain in current MPL <span class="keyword">set</span> at Dequeue wait
20  14  Time-out option                                                 Bit 3 +
                0 =   Wait <span class="keywordflow">for</span> specified time, then signal time-out exception
                1 =   Wait indefinitely
20  14  Actual key to input key relationship                            Bits 4-7 +
          (<span class="keywordflow">for</span> keyed queue)
                0010 =  Greater than
                0100 =  Less than
                0110 =  Not equal
                1000 =  Equal
                1010 =  Greater than or equal
                1100 =  Less than or equal
21  15  Search key (ignored <span class="keywordflow">for</span> FIFO/LIFO queues but  Char(key length) +
                must be present <span class="keywordflow">for</span> FIFO/LIFO queues with
                nonzero key length values)  
  *   Message key                                     Char(key length) ++
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>以上参数中使用'+'标识的为输入参数，使用'++'标识的为输出参数。 <p>
关于DEQ的详细文档，请参考<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">Dequeue (DEQ)</a></dd></dl>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_deq_1">
5.4.1.使用不等待方式执行DEQ指令</a></h3>
执行<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>指令可以使用等待或不等待两种方式。 USRQ上没有符合条件的message时，使用不等待方式执行<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>指令，不会导致当前 线程进入等待状态。使用不等待方式执行<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>指令的方法是，使用<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>指令的 branch form或indicator form，例如: <div class="fragment"><pre class="fragment">dcl sysptr q <span class="keyword">auto</span> init(<span class="stringliteral">"Q31"</span>, ctx(<span class="stringliteral">"LSBIN"</span>), type(q, 02)) ; 
dcl dd prefix char(37) auto     ;
dcl spcptr prefix-ptr auto init(prefix) ;
dcl spc prefix-t bas(prefix-ptr) ; 
        dcl dd time-enqueued <span class="keywordtype">char</span>(8) dir ; <span class="comment">/* output */</span>
        dcl dd timeout <span class="keywordtype">char</span>(8) dir ;
        dcl dd text-len bin(4) dir ;       <span class="comment">/* output */</span>
        dcl dd access-state-option <span class="keywordtype">char</span>(1) dir ;
        dcl dd search-key <span class="keywordtype">char</span>(8) ;
        dcl dd returned-key <span class="keywordtype">char</span>(8) ;      <span class="comment">/* output */</span>
dcl dd text <span class="keywordtype">char</span>(64) auto bdry(16) ;
dcl spcptr text-ptr auto init(text) ; 

entry * ext                     ; 

brk "DEQB"                      ; 
        <span class="comment">/* binary:      11000010 */</span>
        <span class="comment">/* dequeue messages whose keys are greater than search-key */</span>
        cpybla access-state-option, x"1202" ;
        cpybla search-key, "00000001" ; 
        deq(b) prefix, text-ptr, q / neq(not-found), eq(found) ; 
        
found:      <span class="comment">/* when a queue message dequeued, control flow will be branched here */</span>

not-found:  <span class="comment">/* when no queue message dequeued, control flow will be branched here */</span>

brk "DEQI"                        ;
dcl dd ind-found <span class="keywordtype">char</span>(1) auto   ; 
dcl dd ind-not-found <span class="keywordtype">char</span>(1) auto   ;
        deq(i) prefix, text-ptr, q / neq(ind-not-found), eq(ind-found) ;
        <span class="comment">/* when a queue message is dequeued, ind-found = '1', ind-not-found = '0' */</span>
        <span class="comment">/* when no queue message is dequeued, ind-found = '0', ind-not-found = '1' */</span>

        rtx *                   ; 
pend                                ; 
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>更多示例请参考 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> 中用于清空USRQ的工具程序<a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/clrusrq.mi?view=markup">clrusrq.mi</a>， 该程序使用<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>指令的branch form进行不等待出列。</dd></dl>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_deq_2">
5.4.2. 使用等待方式执行DEQ指令</a></h3>
使用等待方式执行DEQ指令时，可以指一个确定的超时时间，或无限期等待。<p>
要无限期等待需要将<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>指令的操作数1(<em>message prefix</em>)的输入参数 <em>Access state modification option when entering Dequeue wait</em>的 bit 3 <em>Time-out option</em>置为1(bit 0指最高位)，如: <div class="fragment"><pre class="fragment">dcl dd prefix char(37) auto     ;
dcl spcptr prefix-ptr auto init(prefix) ;
dcl spc prefix-t bas(prefix-ptr) ; 
        dcl dd time-enqueued <span class="keywordtype">char</span>(8) dir ; <span class="comment">/* output */</span>
        dcl dd timeout <span class="keywordtype">char</span>(8) dir ;
        dcl dd text-len bin(4) dir ;       <span class="comment">/* output */</span>
        dcl dd access-state-option <span class="keywordtype">char</span>(1) dir ;

        <span class="comment">/* set 'Time-out option' */</span>
        setbts access-state-option, 3;
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>更多示例请参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer">6.5. 通过i5/OS queue object传递变长数据</a> 中的ILE RPG服务程序 <a href="src/isqlsvr2.sqlrpgle">isqlsvr2.sqlrpgle</a></dd></dl>
要指定超时时间，需要将<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/DEQ.htm">DEQ</a>指令的操作数1(<em>message prefix</em>)的输入参数 <em>Access state modification option when entering Dequeue wait</em>的 bit 3 <em>Time-out option</em>置为0(bit 0指最高位)，并在参数<em>Dequeue wait time-out value</em> 中指定以系统时钟表示的超时时间，如: <div class="fragment"><pre class="fragment">dcl dd prefix char(37) auto     ;
dcl spcptr prefix-ptr auto init(prefix) ;
dcl spc prefix-t bas(prefix-ptr) ; 
        dcl dd time-enqueued <span class="keywordtype">char</span>(8) dir ; <span class="comment">/* output */</span>
        dcl dd timeout <span class="keywordtype">char</span>(8) dir ;
        dcl dd text-len bin(4) dir ;       <span class="comment">/* output */</span>
        dcl dd access-state-option <span class="keywordtype">char</span>(1) dir ;

dcl dd seconds bin(4) auto init(7) ; <span class="comment">/* 7 seconds */</span>
        mult(s) seconds, 125000 ; 
        cpybtrls timeout, seconds, 17 ; <span class="comment">/* copy seconds to timeout aligning from the left; shift 17 bits to the right */</span>

        <span class="comment">/* clear 'Time-out option' */</span>
        clrbts access-state-option, 3;
</pre></div> 当超时时间溢出，DEQ指令将引发<em>Dequeue Time-Out</em>异常(hex 3A01, MCH5801)。 <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>如果指定<em>Time-out option</em>为0，则当前作业的默认超时时间将被采用。 <p>
注意系统时钟使用8字节表示，其中高49位每增1表示8个1/1000000秒。</dd></dl>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_clr">
5.5. 清空USRQ</a></h3>
IBM没有提供清空USERQ的CL命令或API，可以使用 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> 提供的工具程序 <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/clrusrq.mi?view=markup">clrusrq.mi</a>。 调用说明: <div class="fragment"><pre class="fragment">CALL CLRUSRQ PARM(usrq_name)
</pre></div><h3><a class="anchor" name="ss_using_q_usrq_howtos_matqat">
5.6. 获取USRQ属性</a></h3>
获取USRQ属性需要使用MI指令 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQAT.htm">MATQAT</a> 。<ul>
<li>使用<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQAT.htm">MATQAT</a>指令的示例请参考 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> 中获取Queue Object属性的MI源文件 <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qattr.mi?view=markup">qattr.mi</a></li><li>该指令的详细文档请参考 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQAT.htm">Materialize Queue Attributes (MATQAT)</a></li></ul>
<h3><a class="anchor" name="ss_using_q_usrq_howtos_matqmsg">
5.7. 获取USRQ上的消息</a></h3>
获取USRQ上的消息需要使用MI指令 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQMSG.htm">MATQMSG</a> 。<ul>
<li>使用<a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQMSG.htm">MATQMSG</a>指令的示例请参考 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> 中获取Queue Object上消息的MI源文件 <a href="http://i5toolkit.svn.sourceforge.net/viewvc/i5toolkit/q/qmsg.mi?view=markup">qmsg.mi</a></li><li>该指令的详细文档请参考 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzatk/MATQMSG.htm">Materialize Queue Messages (MATQMSG)</a></li></ul>
<h2><a class="anchor" name="sect_using_q_usage_demo">
6. Queue Object应用实例</a></h2>
<b>这里的实例</b><ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_byibm">6.1. IBM提供的USRQ示例: Creating a Batch Machine</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_outputq">6.2. Output Queue的Data Queue支持</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority">6.3. 通过keyed queue objects实现基于优先级的通讯</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync">6.4. 通过i5/OS queue object模拟同步调用</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer">6.5. 通过i5/OS queue object传递变长数据</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java">6.6. Java和i5/OS Queue object</a></li></ul>
<h3><a class="anchor" name="ss_using_q_usage_demo_byibm">
6.1. IBM提供的USRQ示例: Creating a Batch Machine</a></h3>
在Information Center中，IBM提供了一个最基本USRQ的使用示例， <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apiref/apiexcremac.htm">Creating a Batch Machine</a>。 这个示例中，Client程序(1个或多个)与Server程序 通过一个USRQ交互，USRQ类型为FIFO，entry长度100字节；client将用户交互输入的CL命令 作为message text发送到USRQ；server程序循环由USRQ出列client发送的命令，使用API QCMDEXC 执行client的CL命令，直到某一个client发送的命令字串为'quit'或'QUIT'。<h3><a class="anchor" name="ss_using_q_usage_demo_outputq">
6.2. Output Queue的Data Queue支持</a></h3>
<b>en title</b> Data Queue Support on Output Queues<p>
i5/OS的每个Output Queue(简称OUTQ)可以可选地关联一个Data Queue，以便当OUTQ 上的一个spooled file到达READY状态时，向DTAQ上发送一个通知message。 将一个DTAQ关联到一个OUTQ，可以通过在使用CRTOUTQ或CHGOUTQ命令时，指定DTAQ参数； 或者通过添加一个系统级别的环境变量QIBM_NOTIFY_CRTSPLF。这种机制为用户应用 程序管理OUTQ上的spooled file提供了便利。<p>
这里我们通过实验检查由通知DTAQ上可以得到哪些信息。额外地，作为补充说明， 附录 <a class="el" href="page_using_q_cn.html#ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a> 中的示例程序，将OUTQ QEZJOBLOG中的spooled file实时地存入数据文件，并在 保存后删除。<p>
<b>创建DTAQ</b><br>
 需要注意的是:<ul>
<li>DTAQ类型应该是FIFO或LILO的；</li><li>发送到DTAQ中的通知信息有两种记录格式，'01'，'02'；前者要求128字节的queue entry长度，后者要求至少144字节的queue entry长度；</li><li>用户QSPL需要对DTAQ有*USE权限，对DTAQ所在库有*EXECUTE权限； <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/SPLF)
        MAXLEN(144)     <span class="comment">/* to receive type '02' notifications */</span>
        SEQ(*FIFO)
        SIZE(*MAX2GB)
        TEXT('Notification Queue for Spooled Files')
</pre></div></li></ul>
<p>
<b>添加环境变量QIBM_NOTIFY_CRTSPLF</b><br>
 如果希望环境变量只影响当前交互作业，使用参数LEVEL(*JOB)；如果 希望环境变量影响当前系统，使用参数LEVEL(*SYS)。 <div class="fragment"><pre class="fragment">ADDENVVAR ENVVAR(QIBM_NOTIFY_CRTSPLF)
          VALUE('*DTAQ LSBIN/SPLF')
          LEVEL(*SYS)     <span class="comment">/* take system wide effects */</span>
</pre></div><p>
<b>检查DTAQ中得到的通知数据</b><br>
 随便编译一个RPG程序，以便生成一个spooled file； 使用 <a href="../q/page_dspqmsg.html">DSPQMSG</a> 命令，分别查看spooled file通知entry的字符形式的十六进制形式内容， <div class="fragment"><pre class="fragment"><span class="comment">/* DSPQMSG */</span>
DSPQMSG Q(LSBIN/SPLF)

<span class="comment">/* character format */</span>
        -------------------Character data-------------------
Column   *...+....1....+....2....+....3....+....4....+....5 
000001  <span class="stringliteral">'*SPOOL    02REDLIGHT  LJL       254395AAA         '</span>
000051  <span class="stringliteral">' QPRINT    QGPL      REDLIGHT  LJL       254395  '</span>
000101  <span class="stringliteral">'                   S65FAA4B  1090518164906       '</span>

<span class="comment">/* hexadecimal format */</span>
        ------------------Hexadecimal data------------------
Column   * . . . + . . . . 1 . . . . + . . . . 2 . . . . +  
000001  <span class="stringliteral">'5CE2D7D6D6D340404040F0F2D9C5C4D3C9C7C8E34040D3D1D3'</span>
000026  <span class="stringliteral">'40404040404040F2F5F4F3F9F5C1C1C1404040404040400000'</span>
000051  <span class="stringliteral">'0001D8D7D9C9D5E340404040D8C7D7D3404040404040D9C5C4'</span>
000076  <span class="stringliteral">'D3C9C7C8E34040D3D1D340404040404040F2F5F4F3F9F54040'</span>
000101  <span class="stringliteral">'4040404040404040000000000000000000000003E2F6F5C6C1'</span>
000126  <span class="stringliteral">'C1F4C24040F1F0F9F0F5F1F8F1F6F4F9F0F600            '</span>
</pre></div> 可以看到，入列到通知DTAQ的记录类别为'02'的数据的格式如下： <table border="1" cellspacing="3" cellpadding="3">
<caption align="bottom">Format of notification type '02'</caption>
<tr bgcolor="silver">
<td>偏移(Decimal) </td><td>偏移(Hexadecimal) </td><td>数据类型/长度 </td><td>含义 </td><td>以上示例中的值  </td></tr>
<tr>
<td>0 </td><td>0 </td><td>char(10) </td><td>功能码。总是'*SPOOL' </td><td>'*SPOOL '  </td></tr>
<tr>
<td>10 </td><td>A </td><td>char(2) </td><td>记录类别。'02' </td><td>'02'  </td></tr>
<tr>
<td>12 </td><td>C </td><td>char(26) </td><td>作业标识。10字节作业名称，10字节USRPRF名称，和6字节作业号 </td><td>'REDLIGHT LJL 254395'  </td></tr>
<tr>
<td>38 </td><td>26 </td><td>char(10) </td><td>Spooled file名称 </td><td>'AAA '  </td></tr>
<tr>
<td>48 </td><td>30 </td><td>binary(4) </td><td>Spooled file序号 </td><td>x'00000001'  </td></tr>
<tr>
<td>52 </td><td>34 </td><td>char(20) </td><td>Output queue名称 </td><td>'QPRINT QGPL '  </td></tr>
<tr>
<td>72 </td><td>48 </td><td>char(26) </td><td>作业标识 </td><td>'REDLIGHT LJL 254395'  </td></tr>
<tr>
<td>98 </td><td>62 </td><td>char(10) </td><td>用户数据 </td><td>' '  </td></tr>
<tr>
<td>108 </td><td>6C </td><td>binary(4) </td><td>保留 </td><td>x'00000000'  </td></tr>
<tr>
<td>112 </td><td></td><td>char(8) </td><td>产出spooled file的线程ID </td><td>x'0000000000000003'  </td></tr>
<tr>
<td>120 </td><td>78 </td><td>char(10) </td><td>产出spooled file的机器名 </td><td>'S65FAA4B '  </td></tr>
<tr>
<td>130 </td><td>82 </td><td>char(7) </td><td>Spooled file创建日期。格式为CYYMMDD </td><td>'1090518'  </td></tr>
<tr>
<td>137 </td><td>89 </td><td>char(6) </td><td>Spooled file创建时间 </td><td>'164906'  </td></tr>
<tr>
<td>143 </td><td>8F </td><td>char(1) </td><td>保留 </td><td>x'00'  </td></tr>
</table>
<p>
作为接收通知的用户应用程序，在出列到以上通知信息后，要使用CL命令(如CPYSPLF, DLTSPLF)或Spooled File API(如Open Spooled File (QSPOPNSP) API)操作目的Spooled File时， 可以通过通知信息中以下参数唯一确定一个Spooled File：<ul>
<li><em>Spooled file名称</em></li><li><em>Spooled file序号</em></li><li><em>作业标识</em></li><li><em>产出spooled file的机器名</em></li><li><em>Spooled file创建日期</em></li><li><em>Spooled file创建时间</em></li></ul>
<p>
通常使用前三个参数即可。<h3><a class="anchor" name="ss_using_q_usage_demo_priority">
6.3. 通过keyed queue objects实现基于优先级的通讯</a></h3>
在各种各样的通讯模型中，通讯内容的优先级是一个常见的概念，基于优先级的通讯允许 具备高优先级的请求得到优先处理，以便在服务端存在负载压力时，确保时间关键的业务 在时限内被处理。在i5/OS上，我们可以借助Keyed Queue Object实现 基于优先级的通讯。<p>
下面的示例中，假设的客户程序与服务程序通过一个Keyed DTAQ通讯， DTAQ的键值表示消息的优先级，客户程序使用字符形式的'00'至'99'标识自己发送给 服务程序的消息的优先级，'00'为优先级最高，'99'为最低。服务程序出列 DTAQ中键值大于等于'00'的所有消息，优先级高的(键值小的)消息将先被出列并处理。<p>
示例中涉及的组件:<ul>
<li>DTAQ Q27：类型为keyed，键值长度2，entry长度16</li><li>客户程序：ILE RPG程序<a href="src/r105.rpgle">r105.rpgle</a></li><li>服务程序：ILE RPG程序<a href="src/r106.rpgle">r106.rpgle</a></li></ul>
<p>
这里的内容:<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority_1">6.3.1. 创建DTAQ Q27</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority_2">6.3.2. 编写客户程序</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_priority_3">6.3.3. 编写服务程序</a></li></ul>
<h3><a class="anchor" name="ss_using_q_usage_demo_priority_1">
6.3.1. 创建DTAQ Q27</a></h3>
<div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(Q27)
        MAXLEN(16)  <span class="comment">/* entry length = 16 */</span>
        SEQ(*KEYED) <span class="comment">/* DTAQ type: keyed */</span>
        KEYLEN(2)   <span class="comment">/* key length = 2 */</span>
        TEXT('for priority-based IPC')
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_priority_2">
6.3.2. 编写客户程序</a></h3>
ILE RPG程序<a href="src/r105.rpgle">r105.rpgle</a>输入参数为:<ul>
<li>priority, char(2)，请求优先级</li><li>delay, pkd(2,0)，服务程序执行DLYJOB的时间，单位为秒</li><li>msg, char(14)，供服务程序显示的消息 <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r105.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * enqueue DTAQ Q27</span>
<span class="comment">      *</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     d i_main          pr                  extpgm('R105')
     d   priority                     2a
     d   delay                        2p 0
     d   msg                         14a

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm('QSNDDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       16a   options(*varsize)
     d   key_len                      3p 0 options(*nopass)
     d   key                          2a   options(*nopass:*varsize)

     d qname           s             10a   inz('Q27')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0 inz(16)
     d key_len         s              3p 0 inz(2)

     <span class="comment">/* queue entry format, used both by the client and the server */</span>
     d q_format        ds                  qualified
     d   dly_time                     2p 0                                      <span class="comment">/* how long to    */</span>
     d   msg                         14a                                        <span class="comment">/* greeting words */</span>

     d i_main          pi
     d   priority                     2a
     d   delay                        2p 0
     d   msg                         14a

      /free

          q_format.dly_time = delay;
          q_format.msg      = msg;
          qsnddtaq(  qname
                   : qlib
                   : entry_len
                   : q_format
                   : key_len
                   : priority );

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r105.rpgle */</span>
</pre></div></li></ul>
<p>
调用示例: <div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment">调用R105，参数如下:</span>
<span class="comment"> - priority: '01'</span>
<span class="comment"> - delay: 15, hex 015F</span>
<span class="comment"> - msg: 'morning :p'</span>
<span class="comment">*/</span>
CALL PGM(R105) PARM('01' X'015F' 'morning :p')

<span class="comment">/* 使用DSPQMSG命令查看入列到DTAQ的message */</span>
DSPQMSG Q(Q27) QTYPE(*DTAQ)
<span class="comment">/*</span>
<span class="comment">/* 键值数据 */</span>
        -------------------Character data-------------------
Column   *...+....1....+....2....+....3....+....4....+....5 
000001  '01                                                '

<span class="comment">/* message text的 hex 表示 */</span>
        ------------------Hexadecimal data------------------
Column   * . . . + . . . . 1 . . . . + . . . . 2 . . . . +  
000001  '015F94969995899587407A9740404040                  '
*/
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_priority_3">
6.3.3. 编写服务程序</a></h3>
ILE RPG程序<a href="src/r106.rpgle">r106.rpgle</a>循环由 DTAQ Q27出列键值大于等于'00'的entry，键值小的entry将先被出列， 从而实现按优先级出列的功能。 <a href="src/r106.rpgle">r106.rpgle</a>出列到一个entry后， 按客户程序<a href="src/r105.rpgle">r105.rpgle</a> 在请求信息中指定的延时时间调用DLYJOB命令，之后， 显示客户程序请求的优先级，及请求内容。<p>
<div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file r106.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * deq R106</span>
<span class="comment">      *</span>
<span class="comment">      * queue message format</span>
<span class="comment">      *  - delay, pkd(2,0), delay time</span>
<span class="comment">      *  - msg, char(14), message from the client</span>
<span class="comment">      */</span>
     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm(<span class="stringliteral">'QRCVDTAQ'</span>)
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                       64a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          8a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     <span class="comment">/* queue entry format, used both by the client and the server */</span>
     d q_format        ds                  qualified
     d   dly_time                     2p 0                                      <span class="comment">/* how long to    */</span>
     d   msg                         14a                                        <span class="comment">/* greeting words */</span>

     d qname           s             10a   inz('Q27')
     d qlib            s             10a   inz('LSBIN')
     d entry_len       s              5p 0 inz(16)
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('GE')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(2)
     d key             s              2a   inz('00')
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d priority        s             16a

     d qcmdexc         pr                  extpgm('QCMDEXC')
     d   cmd                         64a   options(*varsize)
     d   cmdlen                      15p 5

     d dlyjob_cmd      s             64a
     d len             s             15p 5

     d QUIT_CMDS       c                   'q Q qu QU quit QUITT'
     d KEY_ARG         c                   '01'

      /free

          dow '1';

              key = KEY_ARG;
              <span class="comment">// deq DTAQ Q27</span>
              qrcvdtaq(  qname
                       : qlib
                       : entry_len
                       : q_format
                       : timeout
                       : key_order
                       : key_len
                       : key
                       : sender_info_len
                       : sender_info );

              <span class="comment">// should i quit?</span>
              if %scan( %trim(q_format.msg) : QUIT_CMDS ) &gt; 0;
                  priority = 'Priority: 100';
                  q_format.msg = 'see you :)';
                  dsply priority '' q_format.msg;
                  leave;
              endif;

              <span class="comment">// delay job</span>
              dlyjob_cmd = 'DLYJOB ' + %<span class="keywordtype">char</span>(q_format.dly_time);
              len = %len(%trim(dlyjob_cmd));
              qcmdexc(dlyjob_cmd : len);

              <span class="comment">// display message</span>
              priority = 'Priority: ' + key;
              dsply priority '' q_format.msg;

          enddo;

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - r106.rpgle */</span>
</pre></div><p>
现在执行服务程序和客户程序 <div class="fragment"><pre class="fragment"><span class="comment">/* 提交服务作业 */</span>
SBMJOB CMD(CALL R106)

<span class="comment">/* 调用客户程序4次 */</span>
CALL PGM(R105) PARM('99' X'015F' 'see you')
CALL PGM(R105) PARM('03' X'001F' 'Third')
CALL PGM(R105) PARM('02' X'001F' 'Second')
CALL PGM(R105) PARM('01' X'001F' 'First')

<span class="comment">/* 到message queue QSYSOPR里检查并回复服务程序的消息 */</span>
First
  Reply . . :   a
Second
  Reply . . :   a
Third
  Reply . . :   a
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_sync">
6.4. 通过i5/OS queue object模拟同步调用</a></h3>
在前面看到的基于queue的IPC实例中，请求发起程序通过queue发送完请求后 就继续执行自身所在线程的后续程序逻辑，无法等待请求处理结束， 也无法取得请求处理的结果。这种通讯方式在某些情况下是不可接受的， 例如，客户程序的多个请求间存在时序关系时，即特定类型的请求必须在其他类型 的请求处理完之后才可以发起。此外，请求的处理结果，在某些场合对 客户程序也是关键的，如某类型的请求执行失败后，客户程序就应该 放弃继续发送后续请求。<p>
要解决上面的两个问题，可以使用queue object模拟同步调用。 这种通讯模型的具体的实现方法有多种，而基本的共性是，请求发起程序 在通过入列queue object发送完请求后，通过出列另一个 queue object等待请求处理程序完成请求处理，并反馈处理结果。<p>
作为示例，我们实现以下的一种模拟同步调用模型<ul>
<li>客户程序与服务程序使用一对Keyed DTAQ通讯；</li><li>客户程序发起请求时，使用UUID(GUID)作为键值入列请求DTAQ， 通过message text传递请求参数；然后以等待方式出列响应DTAQ中 键值等于请求键值的entry</li><li>服务程序出列到请求DTAQ上的任意请求后，依据请求参数进行处理， 处理结束后，使用请求entry键值中的UUID作为键值，将处理 结果参数作为对请求发起程序的响应，入列响应DTAQ；</li></ul>
<p>
以下介绍中，实现一个基于CL命令形式的客户程序ISQL，和服务它的 服务程序ISQLSVR。ISQL向请求DTAQ ISQL入列以UUID为键值的请求entry， entry内容为待执行的SQL语句；入列请求后， ISQL由响应DTAQ ISQLR以等待方式出列ISQLSVR的响应；ISQLSVR由请求DTAQ ISQL出列ISQL的 请求，执行SQL语句，使用出列时得到请求entry键值中包含的UUID作 为键值，将SQL code作为响应信息入列到响应DTAQ ISQLR；ISQL依据出列 到的SQL code，提示用户SQL语句执行是否成功。<p>
ISQL示例中的组件如下:<ul>
<li>请求DTAQ ISQL；</li><li>响应DTAQ ISQLR；</li><li>CL命令ISQL，接收用户输入，执行命令处理程序ISQL；</li><li>CL命令RUNSQL，返回SQLCOD参数，供CL程序和REXX脚本调用；</li><li>CL命令处理程序ISQLCPP，ILE RPG程序，接收命令参数，入列请求DTAQ ISQL，然后 由响应DTAQ ISQLR出列服务程序ISQLSVR的响应；</li><li>服务程序ISQLSVR，ILE SQLRPG程序，由请求DTAQ ISQL出列客户程序请求， 执行SQL语句，通过入列响应DTAQ ISQLR返回SQL code作为响应；</li></ul>
<p>
这里的内容:<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_1">6.4.1. 创建DTAQ ISQL, ISQLR</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_2">6.4.2. 编写CL命令ISQL</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_3">6.4.3. 编写CL命令处理程序ISQL</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_4">6.4.4. 编写服务程序ISQLSRV</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_5">6.4.5. 执行服务程序ISQLSRV和客户ISQL</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync_6">6.4.6. 为CL命令ISQL编写一个返回SQLCOD的版本RUNSQL</a></li></ul>
<h3><a class="anchor" name="ss_using_q_usage_demo_sync_1">
6.4.1. 创建DTAQ ISQL, ISQLR</a></h3>
DTAQ ISQL<ul>
<li>类型为keyed</li><li>键值长度16，用于存放16字节的UUID</li><li>entry长度256 <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>SQL statement </td><td>char(256) </td><td>SQL statement string  </td></tr>
<tr>
<td>256 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
DTAQ ISQLR<ul>
<li>类型为keyed</li><li>键值长度16，用于存放16字节的UUID</li><li>entry长度4 <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>SQL code </td><td>bin(4) </td><td>SQL code  </td></tr>
<tr>
<td>4 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
创建DTAQ的CL命令 <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/ISQL) MAXLEN(256) SEQ(*KEYED) KEYLEN(16) TEXT('Request Data Queue for ISQL')
CRTDTAQ DTAQ(LSBIN/ISQLR) MAXLEN(4) SEQ(*KEYED) KEYLEN(16) TEXT('Reply Data Queue for ISQL')
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_sync_2">
6.4.2. 编写CL命令ISQL</a></h3>
CL命令源码 <a href="src/isql.cmd">isql.cmd</a> 如下 <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE ISQL.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(256) MIN(1) +
                          INLPMTLEN(50) PROMPT('SQL statement')
<span class="comment">/* EOF */</span>
</pre></div><p>
编译CL命令ISQL <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/ISQL) PGM(*LIBL/ISQLCPP) SRCFILE(LS2008/DEC)
  SRCMBR(*CMD) TEXT('i can sql')
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_sync_3">
6.4.3. 编写CL命令处理程序ISQL</a></h3>
ILE RPG程序 <a href="src/isqlcpp.rpgle">isqlcpp.rpgle</a> 如下 <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlcpp.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * commmand processing program for CL command ISQL</span>
<span class="comment">      */</span>

     h dftactgrp(*no)

     d i_main          pr                  extpgm('ISQLCPP')
     d   sql                        256a
     d   sqlcod                      10i 0 options(*nopass)

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* input checking procedure */</span>
     d input_check     pr              n

     <span class="comment">/*</span>
<span class="comment">      * do_request</span>
<span class="comment">      *  - send SQL request to server program ISQLSVR</span>
<span class="comment">      *  - receive the SQLCOD returned by ISQLSVR</span>
<span class="comment">      *  - report result message to the user</span>
<span class="comment">      *</span>
<span class="comment">      * @pre sql</span>
<span class="comment">      * @return sqlcod</span>
<span class="comment">      */</span>
     d do_request      pr            10i 0

     <span class="comment">/* send message to interactive user */</span>
     d sendmsg         pr
     d   msg                        256a

     d i_main          pi
     d   sql                        256a
     d   sqlcod                      10i 0 options(*nopass)

     d msg             s            256a
     d rtn             s             10i 0

      /free

          if input_check();
              rtn = do_request();
          endif;

          sendmsg(msg);

          <span class="comment">// return SQLCOD to the caller when parameter sqlcod is specified</span>
          if %parms() &gt; 1;
              sqlcod = rtn;
          endif;

          *inlr = *on;
      /end-free
     <span class="comment">/* eof - i_main() */</span>

     <span class="comment">/* procedure input_check() */</span>
     p input_check     b
     d input_check     pi              n

      /free
          if sql = *blanks;
              msg = 'Empty SQL statement';
              return *off;
          endif;

          return *on;
      /end-free
     p input_check     e

     <span class="comment">/* procedure do_request() */</span>
     p do_request      b

     d q_entry         ds                  qualified
     d   sql                        256a
     d   sqlcod                      10i 0
     d   ch_sqlcod                    4a   overlay(sqlcod)

     d uuid_template   ds                  qualified
     d   bytes_in                    10u 0 inz(32)
     d   bytes_out                   10u 0
     d   reserved                     8a   inz(x'0000000000000000')
     d   uuid                        16a

     d genuuid         pr                  extproc('_GENUUID')
     d   template                      *   value

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm('QSNDDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm('QRCVDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     d qname           s             10a
     d qlib            s             10a   inz('*LIBL')
     d entry_len       s              5p 0
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('EQ')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(16)
     d key             s             16a
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d ec              ds                  likeds(qusec_t)

     d do_request      pi            10i 0
      /free

          <span class="comment">// generate UUID</span>
          genuuid(%addr(uuid_template));

          <span class="comment">// enqueue DTAQ ISQL</span>
          entry_len = 256;
          qname = 'ISQL';
          q_entry.sql = sql;
          qsnddtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.sql
                   : key_len
                   : uuid_template.uuid );

          <span class="comment">// dequeue DTAQ ISQL</span>
          clear ec;
          ec.bytes_in = 256;
          qname = 'ISQLR';
          entry_len = 4;
          qrcvdtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.ch_sqlcod
                   : timeout
                   : key_order
                   : key_len
                   : uuid_template.uuid
                   : sender_info_len
                   : sender_info );
          if ec.bytes_out &lt;&gt; 0;
              msg = 'QRCVDTAQ() failed with exception ID: '
                       + ec.exid;
              return -9999;
          endif;

          <span class="comment">// set msg according to returned SQLCOD</span>
          if q_entry.sqlcod &lt; 0;
              msg = 'SQL statement failed with SQLCOD '
                       + %<span class="keywordtype">char</span>(q_entry.sqlcod);
          elseif q_entry.sqlcod &gt; 0;
              msg = 'SQL statement succeeded with SQLCOD '
                       + %<span class="keywordtype">char</span>(q_entry.sqlcod);
          else;
              msg = 'SQL statement succeeded';
          endif;

          return q_entry.sqlcod;
      /end-free
     p do_request      e

     <span class="comment">/* procedure sendmsg() */</span>
     p sendmsg         b

     <span class="comment">/* prototype of QMHSNDPM */</span>
     d qmhsndpm        pr                  extpgm('QMHSNDPM')
     d   msgid                        7a
     d   msgf                        20a
     d   msgdata                    512a   options(*varsize)
     d   msgdata_len                 10i 0
     d   msgtype                     10a
     d   callstack_...
     d     entry                     10a
     d   callstack_...
     d     counter                   10i 0
     d   msgkey                       4a
     d   ec                                likeds(qusec_t)

     d sendmsg         pi
     d   msg                        256a

     d msgid           s              7a   inz('CPF9898')
     d msgf            s             20a   inz('QCPFMSG   QSYS')
     d msgdata_len     s             10i 0
     d msgtype         s             10a   inz('*INFO')
     d callstack_...
     d   entry         s             10a   inz('*PGMBDY')
     d callstack_...
     d   counter       s             10i 0 inz(1)
     d msgkey          s              4a
     d ec              ds                  likeds(qusec_t)

     d cmd             s            512a
     d len             s             15p 5

      /free

          ec.bytes_in = 256;

          msgdata_len = %len(%trim(msg));
          qmhsndpm(  msgid
                   : msgf
                   : msg
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

      /end-free
     p sendmsg         e

     <span class="comment">/* eof - isqlcpp.rpgle */</span>
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_sync_4">
6.4.4. 编写服务程序ISQLSRV</a></h3>
ILE SQLRPG程序 <a href="src/isqlsvr.sqlrpgle">isqlsvr.sqlrpgle</a> 如下 <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlsvr.sqlrpgle</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from DTAQ ISQL</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      */</span>
     <span class="comment">/* to use activation group scope commitment control */</span>
     h dftactgrp(*no) actgrp('ISQLSVR')

     <span class="comment">/*</span>
<span class="comment">      * procedure server_client</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from DTAQ ISQL</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      *</span>
<span class="comment">      * @return boolean, *off if the main procedure should quit.</span>
<span class="comment">      */</span>
     d serve_client    pr              n

     <span class="comment">/*</span>
<span class="comment">      * procedure run_sql()</span>
<span class="comment">      *</span>
<span class="comment">      * @return SQLCOD</span>
<span class="comment">      */</span>
     d run_sql         pr            10i 0
     d   sql                        256a   options(*varsize)

      /free

          dow serve_client();
          enddo;

          *inlr = *on;
      /end-free
     p serve_client    b

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/* prototype of API QSNDDTAQ */</span>
     d qsnddtaq        pr                  extpgm('QSNDDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)

     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm('QRCVDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   entry_len                    5p 0
     d   entry                        1a   options(*varsize)
     d   timeout                      5p 0
     d   key_order                    2a   options(*nopass)                     <span class="comment">/* optional parameter group 1 */</span>
     d   key_len                      3p 0 options(*nopass)
     d   key                          1a   options(*nopass:*varsize)            <span class="comment">/* input/output parameter */</span>
     d   sender_info...
     d     _len                       3p 0 options(*nopass)
     d   sender_info                  1a   options(*nopass:*varsize)
     d   remove_msg                  10a   options(*nopass)                     <span class="comment">/* optional parameter group 2 */</span>
     d   receiver_len                 5p 0 options(*nopass)
     d   ec                                likeds(qusec_t)
     d                                     options(*nopass)

     d qname           s             10a
     d qlib            s             10a   inz('*LIBL')
     d entry_len       s              5p 0
     d timeout         s              5p 0 inz(-1)                              <span class="comment">/* dequeue infinitely */</span>
     d key_order       s              2a   inz('GE')                            <span class="comment">/* key order: &gt;= parameter @key */</span>
     d key_len         s              3p 0 inz(16)
     d key             s             16a
     d sender_info...
     d   _len          s              3p 0 inz(0)                               <span class="comment">/* no sender info */</span>
     d sender_info     s              1a
     d ec              ds                  likeds(qusec_t)

     d q_entry         ds                  qualified
     d   sql                        256a
     d   sqlcod                      10i 0
     d   ch_sqlcod                    4a   overlay(sqlcod)

     d uuid            s             16a
     d msg             s             26a
     d rtn             s              1a
     d QUIT_CMDS       c                   'q Q qu QU quit QUITT'
     d KEY_ARG         c                   x'00000000000000000000000000000000'

     d serve_client    pi              n
      /free

          rtn = *on;

          <span class="comment">// dequeue client request from DTAQ ISQL</span>
          clear ec;
          ec.bytes_in = 256;
          qname = 'ISQL';
          entry_len = 256;
          uuid = KEY_ARG;
          qrcvdtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.sql
                   : timeout
                   : key_order
                   : key_len
                   : uuid
                   : sender_info_len
                   : sender_info );
          if ec.bytes_out &lt;&gt; 0;
              <span class="comment">// error handling</span>
              msg = 'QRCVDTAQ failed: '
                       + ec.exid;
              dsply 'Error' '' msg;
              return *off;
          endif;

          <span class="comment">// should i quit?</span>
          if %scan(%trim(q_entry.sql) : QUIT_CMDS) &gt; 0;
              rtn = *off;
          else;
              <span class="comment">// run sql statement</span>
              q_entry.sqlcod = run_sql(q_entry.sql);
          endif;

          <span class="comment">// enqueue reply to DTAQ ISQLR</span>
          entry_len = 4;
          qname = 'ISQLR';
          qsnddtaq(  qname
                   : qlib
                   : entry_len
                   : q_entry.ch_sqlcod
                   : key_len
                   : uuid );

          return rtn;
      /end-free
     p serve_client    e

     p run_sql         b
     d run_sql         pi            10i 0
     d   sql                        256a   options(*varsize)

     c/exec sql prepare stmt from :sql
     c/end-exec
     c                   if        sqlcod &lt; 0
     c                   return    sqlcod
     c                   endif
     c/exec sql execute stmt
     c/end-exec

     c                   return    sqlcod
     p run_sql         e
     <span class="comment">/* eof - isqlsvr.sqlrpgle</span>
</pre></div><p>
编译<a href="src/isqlsvr.sqlrpgle">isqlsvr.sqlrpgle</a> <div class="fragment"><pre class="fragment">CRTSQLRPGI OBJ(LSBIN/ISQLSVR) SRCFILE(LS2008/DEC)
           SRCMBR(*OBJ) COMMIT(*CS)
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>为了启用激活组级别事务控制，编译SQLRPG程序ISQLSVR时，指定了参数COMMMIT(*CS)。</dd></dl>
<h3><a class="anchor" name="ss_using_q_usage_demo_sync_5">
6.4.5. 执行服务程序ISQLSRV和客户ISQL</a></h3>
提交服务程序作业 <div class="fragment"><pre class="fragment">SBMJOB CMD(CALL PGM(ISQLSVR))
</pre></div><p>
清空要使用SQL操作的物理文件 <div class="fragment"><pre class="fragment">CLRPFM FILE(PF16)
</pre></div><p>
使用ISQL命令执行删除物理文件PF16的操作 <div class="fragment"><pre class="fragment">ISQL SQL(<span class="stringliteral">'delete from pf16'</span>)
<span class="comment">/*</span>
<span class="comment">结果</span>
<span class="comment">SQL statement succeeded wich SQLCOD 100.</span>
<span class="comment">*/</span>
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>由于服务程序ISQLSVR使用了事务控制，因此需要对物理文件PF16启用日志。</dd></dl>
使用ISQL命令执行删除物理文件PF16的操作 <div class="fragment"><pre class="fragment">ISQL SQL(<span class="stringliteral">'insert into pf16 values('</span><span class="stringliteral">'Field 1'</span><span class="stringliteral">', '</span><span class="stringliteral">'Field 2'</span><span class="stringliteral">', '</span><span class="stringliteral">'Field 3'</span><span class="charliteral">')'</span>)
<span class="comment">/*</span>
<span class="comment">结果</span>
<span class="comment">SQL statement succeeded.</span>
<span class="comment">*/</span>
</pre></div><p>
使用DSPJOB命令查看服务程序作业的事务控制信息 <div class="fragment"><pre class="fragment">DSPJOB JOB(257356/LJL/LJL_DAILY) OPTION(*CMTCTL)
</pre></div> 可以看到当前服务程序作业已启用activiation group level的事务控制 <div class="fragment"><pre class="fragment">        Commitment                           
Opt     Definition     Text                  
        ISQLSVR        Activation-group-level
</pre></div> 且该事务控制下，有一条未提交(pending)记录 <div class="fragment"><pre class="fragment">Job:   LJL_DAILY      User:   LJL            Number:   257356         
                                                                      
Commitment definition  . . . . . . . . :   ISQLSVR                    
                                                                      
                                    -------------Changes--------------
File        Library     Member          Commit    Rollback     Pending
PF16        LSBIN       PF16                 0           0           0
                        PF16                 0           0           1
</pre></div><p>
使用ISQL命令提交事务控制 <div class="fragment"><pre class="fragment">ISQL SQL(<span class="stringliteral">'commit'</span>)
<span class="comment">/*</span>
<span class="comment">结果</span>
<span class="comment">SQL statement succeeded.</span>
<span class="comment">*/</span>
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_sync_6">
6.4.6. 为CL命令ISQL编写一个返回SQLCOD的版本RUNSQL</a></h3>
目的是，当在CL程序或REXX脚本中使用该命令时，通过判断返回的SQLCOD可以决定后续程序逻辑。 <a href="src/runsql.cmd">runsql.cmd</a> <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE RUNSQL.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(256) MIN(1) +
                          INLPMTLEN(50) PROMPT('SQL statement')
             PARM       KWD(SQLCOD) TYPE(*CHAR) LEN(4) RTNVAL(*YES) +
                          MIN(1) PROMPT('SQLCOD returned')
<span class="comment">/* EOF */</span>
</pre></div><p>
编译CL命令RUNSQL <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/RUNSQL) PGM(*LIBL/ISQLCPP) SRCFILE(LS2008/DEC)
       ALLOW(*BPGM *IPGM *BREXX *IREXX)
</pre></div><p>
使用CL命令RUNSQL的示例OPM CL程序 <a href="src/cl103.clp">cl103.clp</a> <div class="fragment"><pre class="fragment">             <span class="comment">/* @FILE CL103.CLP */</span>
PGM
             DCL        VAR(&amp;SQLCOD) TYPE(*CHAR) LEN(4)
 RUN_SQL:    RUNSQL     SQL('delete from pf16') SQLCOD(&amp;SQLCOD) <span class="comment">/* +</span>
<span class="comment">                          clear PF16 */</span>
             RUNSQL     SQL('insert into PF16 values(''A'', ''B'', +
                          ''C'')') SQLCOD(&amp;SQLCOD) <span class="comment">/* insert new +</span>
<span class="comment">                          records */</span>
             IF         COND(%BIN(&amp;SQLCOD) *LT 0) THEN(DO)
             SNDPGMMSG  MSG('SQL operations failed.') +
                          TOMSGQ(*TOPGMQ) MSGTYPE(*INFO)
             RUNSQL     SQL('rollback') SQLCOD(&amp;SQLCOD) <span class="comment">/* rollbak +</span>
<span class="comment">                          when insert operation failed */</span>
             GOTO       CMDLBL(END)
             ENDDO

             RUNSQL     SQL('commit') SQLCOD(&amp;SQLCOD) <span class="comment">/* commit */</span>

 END:        ENDPGM
<span class="comment">/* EOF - CL103.CLP */</span>
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>在以上的示例中，请求SQL语句的长度受到了请求DTAQ entry长度 的限制，最长为256字节。要解除对SQL语句长度的限制，请参考 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer">6.5. 通过i5/OS queue object传递变长数据</a>。</dd></dl>
<h3><a class="anchor" name="ss_using_q_usage_demo_pointer">
6.5. 通过i5/OS queue object传递变长数据</a></h3>
在 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync">6.4. 通过i5/OS queue object模拟同步调用</a> 中 ISQL 的示例中， 请求SQL语句的长度受到了请求DTAQ entry长度 的限制，最长为256字节； 虽然增加请求DTAQ ISQL的 entry 长度，可以允许传递更长的 SQL 语句， 但很难决定究竟多长才够，而对DTAQ而言，允许的最大entry长度也仅有64K字节； 同时，指定过份冗余的DTAQ entry 长度，对存储和性能都是一种浪费。 显然，要解决这里遇到的问题，需要传递变长数据。<p>
那么，如何基于queue object传递变长数据呢? 答案在于指针。 在 <a class="el" href="page_using_q_cn.html#sect_using_q_intro">2. 对i5/OS Queue Object的介绍</a> 中介绍Queue object的主要属性时， 已经提到，如果queue object的允许message包含指针属性为真， 则可以通过一个queue object传递MI指针。 在MI指针类型中，Space Pointer(下面简称为SPCPTR)，用于描述各种存储的寻址属性 (自动存储，静态存储和堆存储)。 作为一个i5/OS MI指针, SPCPTR包含了MI指针的通用属性(如指针类型, 标记位)及SPCPTR的专有属性(如在space object中的偏移)。 SPCPT对等于i5/OS HLL(高级语言)中 指向自动存储，静态存储和堆存储的HLL指针， 如ILE RPG中的pionter类型，或C语言中的void *, char *，等等。 通过在一个允许message包含指针属性的queue object上传递SPCPTR， 可以让出列queue object的程序访问入列程序内部分配的变长数据， 从而达到基于queue object传递变长数据的目的。<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>这里一个不可避免的前提，当然是，出列queue object的程序 使用入列程序分配的存储时，入列程序必须保证存储未被 释放。 <p>
包含指针的结构必须对齐到16字节 <p>
IBM没有提供创建一个允许queue message包含指针的DTAQ 的接口；因此，需要在queue object上传递指针时，我们 只能选择USRQ(user queue)。 <p>
SPCPTR并不是唯一可以由queue object传递的指针类型， 在queue object传递哪些指针类型，取决于软件的系统架构， 例如，可以通过在queue object上传递指向可执行的program object 的system pointer实现运行时刻的业务逻辑变更；如何 善用这项技术，规避负面影响，取决于作为软件设计者的你。</dd></dl>
这里，我们对 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_sync">6.4. 通过i5/OS queue object模拟同步调用</a> 中 ISQL/ISQLSVR 程序 进行优化，通过在USRQ上传递变长数据而解除对SQL语句长度的限制。 优化后的客户程序和CL命令名称为ISQL2，优化后的服务程序名称为 ISQLSVR2。<p>
<b>ISQL2组件</b><br>
<ul>
<li>请求USRQ: ISQL2</li><li>响应USRQ: ISQLR2</li><li>CL命令ISQL2，接收用户输入，执行命令处理程序ISQL；</li><li>CL命令RUNSQL2，返回SQLCOD参数，供CL程序和REXX脚本调用；</li><li>CL命令处理程序ISQLCPP2，ILE RPG程序，接收命令参数， 将指向存放SQL语句变量的指针入列请求USRQ ISQL2，然后 由响应USRQ ISQLR2出列服务程序ISQLSVR2的响应；</li><li>服务程序ISQLSVR2，ILE SQLRPG程序，由请求USRQ ISQL2出列 客户程序传递的指向存放SQL语句变量的指针，取得SQL语句内容， 执行SQL语句，通过入列响应USRQ ISQLR2返回SQL code作为响应；</li></ul>
<p>
这里的内容:<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_1">6.5.1. 创建USRQ ISQL2, ISQLR2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_2">6.5.2. 编写CL命令ISQL2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_3">6.5.3. 编写CL命令处理程序ISQLCPP2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_4">6.5.4. 编写服务程序ISQLSVR2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_5">6.5.5. 编写由CL程序或REXX脚本调用的CL命令RUNSQL2</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer_6">6.5.6. 执行服务程序ISQLSVR2和客户ISQL2</a></li></ul>
<h3><a class="anchor" name="ss_using_q_usage_demo_pointer_1">
6.5.1. 创建USRQ ISQL2, ISQLR2</a></h3>
请求USRQ ISQL2<ul>
<li>类型为keyed</li><li>键值长度16，用于存放16字节的UUID</li><li>entry长度16，格式为 <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>Pointer to SQL statement </td><td>SPCPTR </td><td>Pointer to SQL statement data  </td></tr>
<tr>
<td>16 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
DTAQ ISQLR2<ul>
<li>类型为keyed</li><li>键值长度16，用于存放16字节的UUID</li><li>entry长度4，格式为 <table border="1" cellspacing="3" cellpadding="3">
<tr bgcolor="silver">
<td>Offset </td><td>Parameter Name </td><td>Data Type </td><td>Meaning  </td></tr>
<tr>
<td>0 </td><td>SQL code </td><td>bin(4) </td><td>SQL code  </td></tr>
<tr>
<td>4 </td><td>-- end -- </td><td></td><td></td></tr>
</table>
</li></ul>
<p>
创建USRQ的CL命令 <div class="fragment"><pre class="fragment"><span class="comment">/* 请求USRQ ISQL2 */</span>
CALL PGM(QUSCRTUQ) PARM(
     'ISQL2     LSBIN'   <span class="comment">/* USRQ name */</span>
     'QQ'                <span class="comment">/* extended attribute */</span>
     'K'                 <span class="comment">/* queue type */</span>
     X'00000010'         <span class="comment">/* key length */</span>
     X'00000010'         <span class="comment">/* entry length */</span>
     X'00000010'         <span class="comment">/* initial number of messages */</span>
     X'00000010'         <span class="comment">/* number of messages per extension */</span>
     '*EXCLUDE'          <span class="comment">/* public authority */</span>
     'ISQL request queue. key length = 16, entry length = 16' <span class="comment">/* text description */</span>
     '*YES'              <span class="comment">/* replace */</span>
     X'0000002000000000000000000000000000000000000000000000000000000000' <span class="comment">/* error code structure */</span>
     '*USER'             <span class="comment">/* object domain */</span>
     '*YES')             <span class="comment">/* contains poniter */</span>

<span class="comment">/* 响应USRQ ISQLR2 */</span>
CALL PGM(QUSCRTUQ) PARM(
     'ISQLR2    LSBIN'   <span class="comment">/* USRQ name */</span>
     'QQ'                <span class="comment">/* extended attribute */</span>
     'K'                 <span class="comment">/* queue type */</span>
     X'00000010'         <span class="comment">/* key length */</span>
     X'00000004'         <span class="comment">/* entry length */</span>
     X'00000010'         <span class="comment">/* initial number of messages */</span>
     X'00000010'         <span class="comment">/* number of messages per extension */</span>
     '*EXCLUDE'          <span class="comment">/* public authority */</span>
     'ISQL reply queue. key length = 16, entry length = 4') <span class="comment">/* text description */</span>
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_pointer_2">
6.5.2. 编写CL命令ISQL2</a></h3>
CL命令源码 <a href="src/isql2.cmd">isql2.cmd</a> 如下 <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE ISQL.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(256) MIN(1) +
                          INLPMTLEN(50) PROMPT('SQL statement')
<span class="comment">/* EOF */</span>
</pre></div><p>
编译CL命令ISQL2 <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/ISQL2) PGM(*LIBL/ISQLCPP2) SRCFILE(LS2008/DEC)
       SRCMBR(*CMD) TEXT('i can sql too :p')
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_pointer_3">
6.5.3. 编写CL命令处理程序ISQLCPP2</a></h3>
ILE RPG程序 <a href="src/isqlcpp2.rpgle">isqlcpp2.rpgle</a> 如下 <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlcpp2.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     d sql_param_t     ds                  qualified
     d   sql_len                     10i 0
     d   sql                      32767a

     d i_main          pr                  extpgm('ISQLCPP2')
     d   sql_parm                          likeds(sql_param_t)
     d   sqlcod                      10i 0 options(*nopass)

     <span class="comment">/* structure Qus_EC_t */</span>
     d qusec_t         ds           256    qualified
     d   bytes_in                    10i 0
     d   bytes_out                   10i 0
     d   exid                         7a
     d   reserved                     1a
     d   ex_data                    240a

     <span class="comment">/*</span>
<span class="comment">      * do_request</span>
<span class="comment">      *  - send SQL request to server program ISQLSVR2</span>
<span class="comment">      *  - receive the SQLCOD returned by ISQLSVR2</span>
<span class="comment">      *  - report result message to the user</span>
<span class="comment">      *</span>
<span class="comment">      * @pre sql</span>
<span class="comment">      * @return sqlcod</span>
<span class="comment">      */</span>
     d do_request      pr            10i 0

     <span class="comment">/* send message to interactive user */</span>
     d sendmsg         pr
     d   msg                        256a

     <span class="comment">/*</span>
<span class="comment">      * prototype of procedure resolve_qs</span>
<span class="comment">      * @return boolean, *on if both the request USRQ and the reply</span>
<span class="comment">      *         USRQ are resolved.</span>
<span class="comment">      */</span>
     d resolve_qs      pr              n

     <span class="comment">/* request USRQ ISQL2 */</span>
     d request_q       s               *

     <span class="comment">/* reply USRQ ISQLR2 */</span>
     d reply_q         s               *

     d msg             s            256a
     d rtn             s             10i 0

     d i_main          pi
     d   sql_parm                          likeds(sql_param_t)
     d   sqlcod                      10i 0 options(*nopass)

      /free

          <span class="comment">// resolve request q, reply q</span>
          if resolve_qs();
              rtn = do_request();
          endif;

          sendmsg(msg);

          <span class="comment">// return SQLCOD to the caller when parameter sqlcod is specified</span>
          if %parms() &gt; 1;
              sqlcod = rtn;
          endif;

          *inlr = *on;
      /end-free

     <span class="comment">/* procedure resolve_qs() */</span>
     p resolve_qs      b
     <span class="comment">/* prototype of MI instruction RSLVSP */</span>
     d rslvsp          pr                  extproc('_RSLVSP2')
     d   syp                           *
     d   option                        *   value

     d resolve_option  ds            34    qualified
     d   type                         2a   inz(x'0A02')
     d   name                        30a
     d   auth                         2a   inz(x'0000')

     d rtn             s               n

     d resolve_qs      pi              n
      /free

          rtn = *on;

          <span class="comment">// resolve request q, reply q</span>
          monitor;   <span class="comment">// monitor MCH3401</span>
              resolve_option.name = 'ISQL2';
              rslvsp(request_q : %addr(resolve_option));
              resolve_option.name = 'ISQLR2';
              rslvsp(reply_q : %addr(resolve_option));
          on-error;
              msg = 'Failed to resolve request user queue' +
                    ' or reply user queue';
              rtn = *off;
          endmon;

          return rtn;
      /end-free
     p resolve_qs      e

     <span class="comment">/* procedure do_request() */</span>
     p do_request      b

     d uuid_template   ds                  qualified
     d   bytes_in                    10u 0 inz(32)
     d   bytes_out                   10u 0
     d   reserved                     8a   inz(x'0000000000000000')
     d   uuid                        16a

     d genuuid         pr                  extproc('_GENUUID')
     d   template                      *   value

     <span class="comment">/* prototype of MI instruction ENQ */</span>
     d enq             pr                  extproc('_ENQ')
     d   q                             *
     d   prefix                        *   value
     d   text                          *   value

     <span class="comment">/* prototype of MI instruction DEQ */</span>
     d deq             pr                  extproc('_DEQWAIT')
     d   prefix                        *   value
     d   text                          *   value
     d   q                             *

     <span class="comment">/* enq prefix */</span>
     d enq_prefix      ds            20    qualified
     d   text_len                    10i 0
     d   key                         16a

     <span class="comment">/* deq prefix */</span>
     d deq_prefix      ds            53    qualified
     d   enqueue_time                 8a
     d   timeout                      8a
     d   text_len                    10i 0
     d   acc_sts_mod                  1a   inz(x'D8')                           <span class="comment">/* deq infinitely */</span>
     d   key_in                      16a
     d   key_out                     16a

     <span class="comment">/* request data */</span>
     d request         ds                  qualified
     d   sql_len                     10u 0
     d   reserved                     8a                                        <span class="comment">/* align to 16 bytes boundary */</span>
     d   sql_ptr                       *
     d request_ptr     s               *   inz(%addr(request))

     <span class="comment">/* reply message from ISQLSVR2 */</span>
     d reply           ds            16    qualified
     d   sqlcod                      10i 0

     d do_request      pi            10i 0

      /free

          <span class="comment">// generate UUID</span>
          genuuid(%addr(uuid_template));

          <span class="comment">// enqueue SQL statement to USRQ ISQL2</span>
          enq_prefix.text_len = 16;
          enq_prefix.key = uuid_template.uuid;
          request.sql_len = sql_parm.sql_len;
          request.sql_ptr = %addr(sql_parm.sql);
          enq(request_q : %addr(enq_prefix) : %addr(request_ptr));

          <span class="comment">// dequeue SQLCOD from USRQ ISQLR2</span>
          deq_prefix.key_in = uuid_template.uuid;
          deq(%addr(deq_prefix) : %addr(reply) : reply_q);

          <span class="comment">// set msg according to returned SQLCOD</span>
          if reply.sqlcod &lt; 0;
              msg = 'SQL statement failed with SQLCOD '
                       + %<span class="keywordtype">char</span>(reply.sqlcod);
          elseif reply.sqlcod &gt; 0;
              msg = 'SQL statement succeeded with SQLCOD '
                       + %<span class="keywordtype">char</span>(reply.sqlcod);
          else;
              msg = 'SQL statement succeeded';
          endif;

          return reply.sqlcod;
      /end-free
     p do_request      e

     <span class="comment">/* procedure sendmsg() */</span>
     p sendmsg         b

     <span class="comment">/* prototype of QMHSNDPM */</span>
     d qmhsndpm        pr                  extpgm('QMHSNDPM')
     d   msgid                        7a
     d   msgf                        20a
     d   msgdata                    512a   options(*varsize)
     d   msgdata_len                 10i 0
     d   msgtype                     10a
     d   callstack_...
     d     entry                     10a
     d   callstack_...
     d     counter                   10i 0
     d   msgkey                       4a
     d   ec                                likeds(qusec_t)

     d msgid           s              7a   inz('CPF9898')
     d msgf            s             20a   inz('QCPFMSG   QSYS')
     d msgdata_len     s             10i 0
     d msgtype         s             10a   inz('*INFO')
     d callstack_...
     d   entry         s             10a   inz('*PGMBDY')
     d callstack_...
     d   counter       s             10i 0 inz(1)
     d msgkey          s              4a
     d ec              ds                  likeds(qusec_t)

     d cmd             s            512a
     d len             s             15p 5

     d sendmsg         pi
     d   msg                        256a

      /free

          clear ec;
          ec.bytes_in = 256;

          msgdata_len = %len(%trim(msg));
          qmhsndpm(  msgid
                   : msgf
                   : msg
                   : msgdata_len
                   : msgtype
                   : callstack_entry
                   : callstack_counter
                   : msgkey
                   : ec );

      /end-free
     p sendmsg         e

     <span class="comment">/* eof - isqlcpp2.rpgle */</span>
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_pointer_4">
6.5.4. 编写服务程序ISQLSVR2</a></h3>
ILE SQLRPG程序 <a href="src/isqlsvr2.sqlrpgle">isqlsvr2.sqlrpgle</a> 如下 <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file isqlsvr.sqlrpgle</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from USRQ ISQL2</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      */</span>
     <span class="comment">/* to use activation group scope commitment control */</span>
     h dftactgrp(*no) actgrp('ISQLSVR2')

     <span class="comment">/*</span>
<span class="comment">      * prototype of procedure resolve_qs</span>
<span class="comment">      * @return boolean, *on if both the request USRQ and the reply</span>
<span class="comment">      *         USRQ are resolved.</span>
<span class="comment">      */</span>
     d resolve_qs      pr              n

     <span class="comment">/*</span>
<span class="comment">      * procedure server_client</span>
<span class="comment">      *</span>
<span class="comment">      * - dequeue SQL request from USRQ ISQL2</span>
<span class="comment">      * - process SQL statement</span>
<span class="comment">      * - reply client with SQLCOD</span>
<span class="comment">      *</span>
<span class="comment">      * @return boolean, *off if the main procedure should quit.</span>
<span class="comment">      */</span>
     d serve_client    pr              n

     <span class="comment">/*</span>
<span class="comment">      * procedure run_sql()</span>
<span class="comment">      *</span>
<span class="comment">      * @return SQLCOD</span>
<span class="comment">      */</span>
     d run_sql         pr            10i 0
     d   the_sql                   5000a   options(*varsize)

     <span class="comment">/* request USRQ ISQL2 */</span>
     d request_q       s               *
     <span class="comment">/* reply USRQ ISQLR2 */</span>
     d reply_q         s               *
     d msg             s             26a

      /free

          <span class="comment">// resolve request q and reply q</span>
          if not resolve_qs();
              msg = 'Failed to resolve user queues';
              dsply '' '' msg;
              *inlr = *on;
              return;
          endif;

          <span class="comment">// serves client</span>
          dow serve_client();
          enddo;

          *inlr = *on;
      /end-free

     <span class="comment">/* procedure resolve_qs() */</span>
     p resolve_qs      b
     <span class="comment">/* prototype of MI instruction RSLVSP */</span>
     d rslvsp          pr                  extproc('_RSLVSP2')
     d   syp                           *
     d   option                        *   value

     d resolve_option  ds            34    qualified
     d   type                         2a   inz(x'0A02')
     d   name                        30a
     d   auth                         2a   inz(x'0000')

     d rtn             s               n

     d resolve_qs      pi              n
      /free

          rtn = *on;

          <span class="comment">// resolve request q, reply q</span>
          monitor;
              resolve_option.name = 'ISQL2';
              rslvsp(request_q : %addr(resolve_option));
              resolve_option.name = 'ISQLR2';
              rslvsp(reply_q : %addr(resolve_option));
          on-error;
              msg = 'Failed to resolve request user queue' +
                    ' or reply user queue';
              rtn = *off;
          endmon;

          return rtn;
      /end-free
     p resolve_qs      e

     p serve_client    b
     <span class="comment">/* prototype of MI instruction ENQ */</span>
     d enq             pr                  extproc('_ENQ')
     d   q                             *
     d   prefix                        *   value
     d   text                          *   value

     <span class="comment">/* prototype of MI instruction DEQ */</span>
     d deq             pr                  extproc('_DEQWAIT')
     d   prefix                        *   value
     d   text                          *   value
     d   q                             *

     <span class="comment">/* enq prefix */</span>
     d enq_prefix      ds            20    qualified
     d   text_len                    10i 0
     d   key                         16a

     <span class="comment">/* deq prefix */</span>
     d deq_prefix      ds            53    qualified
     d   enqueue_time                 8a
     d   timeout                      8a
     d   text_len                    10i 0
     d   acc_sts_mod                  1a   inz(x'DA')                           <span class="comment">/* deq infinitely, key relation:'GE' */</span>
     d   key_in                      16a
     d   key_out                     16a

     <span class="comment">/* request data */</span>
     d request         ds                  qualified
     d                                     based(request_ptr)
     d   sql_len                     10u 0
     d   reserved                     8a                                        <span class="comment">/* align to 16 bytes boundary */</span>
     d   sql_ptr                       *
     d request_ptr     s               *
     d sql_str         ds                  based(request.sql_ptr)
     d                                     qualified
     d   <span class="keywordtype">string</span>                   32767a

     <span class="comment">/* reply message to ISQLCPP2 */</span>
     d reply           ds            16    qualified
     d   sqlcod                      10i 0

     d quit_cmd        s              4a
     d rtn             s               n
     d QUIT_CMDS       c                   'q Q qu QU quit QUITT'
     d MIN_KEY_VALUE   c                   x'00000000000000000000000000000000'  <span class="comment">/* 16 bytes */</span>
     d sql             s          32767a

     d serve_client    pi              n

      /free

          rtn = *on;

          <span class="comment">// dequeue client's request from USRQ ISQL2</span>
          deq_prefix.text_len = 16;
          deq_prefix.key_in = MIN_KEY_VALUE;
          deq(%addr(deq_prefix) : %addr(request_ptr) : request_q);

          <span class="comment">// run sql statement</span>
          sql = %subst(sql_str.<span class="keywordtype">string</span> : 1 : request.sql_len);
          quit_cmd = %subst(sql : 1 : 4);
          if %scan(%trim(quit_cmd) : QUIT_CMDS) &gt; 0;
              rtn = *off;
          else;
              reply.sqlcod = run_sql(sql);
          endif;

          <span class="comment">// enqueue reply message to USRQ ISQLR2</span>
          enq_prefix.text_len = 4;
          enq_prefix.key = deq_prefix.key_out;
          enq(reply_q : %addr(enq_prefix) : %addr(reply));

          return rtn;
      /end-free
     p serve_client    e

     p run_sql         b
     d run_sql         pi            10i 0
     d   the_sql                   5000a   options(*varsize)

     c/exec sql prepare stmt from :the_sql
     c/end-exec
     c                   if        sqlcod &lt; 0
     c                   return    sqlcod
     c                   endif
     c/exec sql execute stmt
     c/end-exec

     c                   return    sqlcod
     p run_sql         e

     <span class="comment">/* eof - isqlsrv2.sqlrpgle */</span>
</pre></div><p>
编译<a href="src/isqlsvr2.sqlrpgle">isqlsvr2.sqlrpgle</a> <div class="fragment"><pre class="fragment">CRTSQLRPGI OBJ(LSBIN/ISQLSVR2) SRCFILE(LS2008/DEC)
           SRCMBR(*OBJ) COMMIT(*CS)
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>为了启用激活组级别事务控制，编译SQLRPG程序ISQLSVR时，指定了参数COMMMIT(*CS)。</dd></dl>
<h3><a class="anchor" name="ss_using_q_usage_demo_pointer_5">
6.5.5. 编写由CL程序或REXX脚本调用的CL命令RUNSQL2</a></h3>
CL命令RUNSQL2源码<a href="src/runsql2.cmd">runsql2.cmd</a> <div class="fragment"><pre class="fragment"><span class="comment">/* @FILE RUNSQL2.CMD */</span>

             CMD        PROMPT(<span class="stringliteral">'Run SQL statement'</span>)
             PARM       KWD(SQL) TYPE(*CHAR) LEN(5000) MIN(1) +
                          VARY(*YES *INT4) INLPMTLEN(50) +
                          PROMPT('SQL statement')
             PARM       KWD(SQLCOD) TYPE(*CHAR) LEN(4) RTNVAL(*YES) +
                          MIN(1) PROMPT('SQLCOD returned')
<span class="comment">/* EOF */</span>
</pre></div><p>
编译CL命令RUNSQL2 <div class="fragment"><pre class="fragment">CRTCMD CMD(LSBIN/RUNSQL2) PGM(*LIBL/ISQLCPP2) SRCFILE(LS2008/DEC)
       ALLOW(*BPGM *IPGM *BREXX *IREXX)
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_pointer_6">
6.5.6. 执行服务程序ISQLSVR2和客户ISQL2</a></h3>
编写使用CL命令RUNSQL2的CL程序 <a href="src/cl104.clp">cl104.clp</a> <div class="fragment"><pre class="fragment">             <span class="comment">/* @FILE CL104.CLP */</span>
PGM
             DCL        VAR(&amp;SQLCOD) TYPE(*CHAR) LEN(4)
 RUN_SQL:    RUNSQL2    SQL('delete from pf16') SQLCOD(&amp;SQLCOD) <span class="comment">/* +</span>
<span class="comment">                          clear PF16 */</span>
             RUNSQL2    SQL('insert into PF16 values(''A'', ''B'', +
                          ''C'')') SQLCOD(&amp;SQLCOD) <span class="comment">/* insert new +</span>
<span class="comment">                          records */</span>
             IF         COND(%BIN(&amp;SQLCOD) *LT 0) THEN(DO)
             SNDPGMMSG  MSG('SQL operations failed.') +
                          TOMSGQ(*TOPGMQ) MSGTYPE(*INFO)
             RUNSQL2    SQL('rollback') SQLCOD(&amp;SQLCOD) <span class="comment">/* rollbak +</span>
<span class="comment">                          when insert operation failed */</span>
             GOTO       CMDLBL(END)
             ENDDO

             RUNSQL2    SQL('commit') SQLCOD(&amp;SQLCOD) <span class="comment">/* commit */</span>

 END:        ENDPGM
<span class="comment">/* EOF - CL104.CLP */</span>
</pre></div> 编译OPM CL程序CL104 <div class="fragment"><pre class="fragment">CRTCLPGM PGM(LSBIN/CL104) SRCFILE(LS2008/DEC) LOG(*YES)
</pre></div><p>
分别使用CL命令ISQL2，调用CL104操作物理文件PF16 <div class="fragment"><pre class="fragment"><span class="comment">/* 提交服务程序作业 */</span>
SBMJOB CMD(CALL PGM(ISQLSVR2))

<span class="comment">/* 清空PF16 */</span>
ISQL2 SQL('delete from pf16')
ISQL2 SQL('commit')

<span class="comment">/* 执行CL104 */</span>
CALL CL104                                                          
   400 - RUNSQL2 SQL('delete from pf16') SQLCOD(&amp;SQLCOD)            
SQL statement succeeded wich SQLCOD 100.                            
   600 - RUNSQL2 SQL('insert into PF16 values(''A'', ''B'', ''C'')')
  SQLCOD(&amp;SQLCOD)                                                   
SQL statement succeeded.                                            
  1700 - RUNSQL2 SQL('commit') SQLCOD(&amp;SQLCOD)                      
SQL statement succeeded.                                            
       - RETURN        <span class="comment">/* RETURN due to end of CL program */</span>        

<span class="comment">/* 通知ISQLSVR2退出 */</span>
ISQL2 SQL('qu')
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>由于ISQLSVR2使用事务访问物理文件，所以需要对以上示例中的物理文件PF16启用日志。</dd></dl>
<h3><a class="anchor" name="ss_using_q_usage_demo_java">
6.6. Java和i5/OS Queue object</a></h3>
作为IPC手段，Queue object同样可以供Java程序使用。 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzahh/page1.htm">IBM Toolbox for Java</a> 中提供了对Data Queue的访问支持， 这样通过使用 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzahh/page1.htm">IBM Toolbox for Java</a> 的客户机版本jt400.jar或主机版本jt400Native.jar，Java程序可以 从客户机或主机侧操作Data Queue对象；详细信息请参考 <a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/rzahh/TW/javadoc/com/ibm/as400/access/BaseDataQueue.html">BaseDataQueue</a> 类及及派生类的文档。<p>
IBM没有提供由Java直接访问User Queue的接口，要在Java程序中使用User Queue需要使用主机语言编写访问User Queue的JNI方法。<p>
作为IPC方法，Queue Object为Java程序与Java程序间，或Java程序与主机语言程序间进行进程间通讯带来了这样的好处<ul>
<li>尽管会影响Java程序的可移植性，i5/OS queue object偢为IPC手段的灵活，和易用性，可以为Java进程/线程间的通讯一个灵活，易用，高效的选择；</li><li>java程序与主机语言程序间使用Queue Object进行IPC，可以<ul>
<li>解耦JVM与的主机语言程序线程模型，资源管理模型；例如传统业务系统中的主机语言程序多数是没有考虑线程安全的，如果在 执行JVM的多线程作业中被调用，会引发线程安全问题；又如，以客户模式使用SQL/CLI访问数据库的主机语言程序，如果被JVM 的多个线程并发调用，主机语言程序创建数据库连接的尝试将可能失败，因为以客户模式使用SQL/CLI时，同一作业同一时间 只能拥有一个对数据库的连接。</li><li>当Java程序服务主机语言程序请求时，可以避免频繁启动JVM；</li></ul>
</li></ul>
<p>
这里，作为示例，我们将使用Java实现 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_pointer">6.5. 通过i5/OS queue object传递变长数据</a> 中的客户程序ISQL2。<p>
Java版本的ISQL2组件如下:<ul>
<li>Java类isql<br>
 由输入参数取得待执行的SQL语句，调用JNI方法isqlsvr.sendRequest， 后者通过入列USRQ ISQL2，向ISQLSVR2提交请求，并等待ISQLSVR2 返回的SQLCOD；</li><li>Java类isqlsvr声明了一个JNI方法sendRequest；</li><li>Service Program(*SRVPGM) ISQLSVR<br>
 实现JNI方法isqlsvr.sendRequest，将SQL请求入列到请求USRQ ISQL2， 然后由响应USRQ ISQLR2接收ISQLSVR2返回的SQLCOD。</li></ul>
<p>
这里的内容:<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java_1">6.6.1. 编写Java程序isql.java, isqlsvr.java</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java_2">6.6.2. 编写JNI方法</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_java_3">6.6.3. 执行Java类isql</a></li></ul>
<h3><a class="anchor" name="ss_using_q_usage_demo_java_1">
6.6.1. 编写Java程序isql.java, isqlsvr.java</a></h3>
Java程序 <a href="src/isql.java">isql.java</a> <div class="fragment"><pre class="fragment">
<span class="keyword">public</span> <span class="keyword">class </span>isql {

    <span class="keyword">static</span> {

        System.loadLibrary(<span class="stringliteral">"ISQLSVR"</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String _usage =
        <span class="stringliteral">"usage info: java isql \"SQL statement to run.\""</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main(String[] args) {

        isql client = <span class="keyword">new</span> isql();
        client.run(args);

    }

    <span class="keyword">protected</span> <span class="keywordtype">void</span> run(String[] args) {

        <span class="keywordflow">if</span>(args.length &lt; 1) {

            System.out.println(_usage);
            <span class="keywordflow">return</span>;
        }

        String msg = <span class="stringliteral">""</span>;
        <span class="keywordflow">try</span> {

            <span class="comment">// send request to ISQLSVR</span>
            <span class="keywordtype">int</span> sqlcod = isqlsvr.sendRequest(args[0]);

            <span class="comment">// compose msg</span>
            <span class="keywordflow">if</span>(sqlcod &lt; 0)
                msg = <span class="stringliteral">"SQL statement failed with SQLCOD "</span> + sqlcod;
            <span class="keywordflow">else</span>
                msg = <span class="stringliteral">"SQL statement succeeded with SQLCOD "</span> + sqlcod;

        } <span class="keywordflow">catch</span>(Exception e) {

            System.out.println(e.getMessage());
            <span class="keywordflow">return</span>;
        }

        <span class="comment">// report execuation result</span>
        System.out.println(msg);
    }

}

<span class="comment">/* eof - isql.java */</span>
</pre></div> Java类<a href="src/isqlsvr.java">isqlsvr.java</a> <div class="fragment"><pre class="fragment">
<span class="keyword">public</span> <span class="keyword">class </span>isqlsvr {

    <span class="keyword">public</span>
        <span class="keyword">static</span>
        native
        <span class="keyword">synchronized</span>
            <span class="keywordtype">int</span> sendRequest(
                            String sql
                            ) <span class="keywordflow">throws</span> Exception;

}

<span class="comment">/* eof - isqlsvr.java */</span>
</pre></div><p>
编译Java源码 <div class="fragment"><pre class="fragment"><span class="comment">/* 将源码上传到IFS */</span>
<span class="comment">/* 启动一个QShell session */</span>
qsh

<span class="comment">/* 确定CLASSPATH环境变量中包含当前路径，如： */</span>
export CLASSPATH=.

<span class="comment">/* 切换到源码目录 */</span>
<span class="comment">/* 使用javac编译Java类 */</span>
javac -encoding utf-8 *java

<span class="comment">/* 使用javah生成JNI方法头文件isqlsvr.h */</span>
javah isqlsvr
</pre></div> <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>使用javac编译时，如果使用-encoding选项指定源文件码制， 则-encoding选项指定的码制要与流文件的实际 码制相符；例如，如果流文件CCSID属性为1208，则应使用-encoding utf-8； 如果流文件CCSID属性为935，则应使用-encoding ibm-935。 <p>
查看流文件的CCSID属性可以使用CL命令wrklnk，然后在文件项上使用 8(Display attributes)选项；或使用QShell命令attr，如 <div class="fragment"><pre class="fragment">attr isql.java
</pre></div></dd></dl>
<h3><a class="anchor" name="ss_using_q_usage_demo_java_2">
6.6.2. 编写JNI方法</a></h3>
<a href="src/isqlsvr.c">isqlsvr.c</a> <div class="fragment"><pre class="fragment">
<span class="preprocessor"># include &lt;isqlsvr.h&gt;</span>

<span class="comment">// libc</span>
<span class="preprocessor"># include &lt;stdlib.h&gt;</span>
<span class="preprocessor"># include &lt;string.h&gt;</span>
<span class="preprocessor"># include &lt;except.h&gt;</span>

<span class="comment">// libmi</span>
<span class="preprocessor"># include &lt;mih/rslvsp.h&gt;</span>
<span class="preprocessor"># include &lt;mih/enq.h&gt;</span>
<span class="preprocessor"># include &lt;mih/genuuid.h&gt;</span>

<span class="comment">// libiconv</span>
<span class="preprocessor"># include &lt;iconv.h&gt;</span>

<span class="comment">// apis</span>
<span class="preprocessor"># include &lt;qusec.h&gt;</span>
<span class="preprocessor"># include &lt;qusrjobi.h&gt;</span>

<span class="keyword">typedef</span> _Packed <span class="keyword">struct </span>_deq_prefix {

  <span class="keywordtype">char</span> time_enqueued[8];
  <span class="keywordtype">char</span> timeout[8];
  <span class="keywordtype">int</span> text_len_returned;
  <span class="keywordtype">char</span> acc_state_mod[1];
  <span class="keywordtype">char</span> key_in[16];
  <span class="keywordtype">char</span> key_out[16];
} deq_prefix_t;

<span class="comment">// prototype of instruction DEQWAIT</span>
<span class="preprocessor"># pragma linkage(_DEQWAIT, builtin)</span>
<span class="preprocessor"></span><span class="keywordtype">void</span> _DEQWAIT (
               deq_prefix_t *,
               <span class="keywordtype">void</span>*,
               _SYSPTR*
               );

<span class="preprocessor"># define REQUEST_Q "ISQL2"</span>
<span class="preprocessor"></span><span class="preprocessor"># define REPLY_Q   "ISQLR2"</span>
<span class="preprocessor"></span><span class="preprocessor"># define UTF8_CCSID \</span>
<span class="preprocessor">  "IBMCCSID012080000000\0\0\0\0\0\0\0\0\0\0\0\0"</span>
<span class="preprocessor"></span><span class="preprocessor"># define ECLEN   256</span>
<span class="preprocessor"></span><span class="preprocessor"># define TEXTLEN 16</span>
<span class="preprocessor"></span><span class="preprocessor"># define KEYLEN  16</span>
<span class="preprocessor"></span><span class="preprocessor"># define ENQ_PREFIX_LEN 20</span>
<span class="preprocessor"></span><span class="preprocessor"># define DEQ_PREFIX_LEN 53</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> _Packed <span class="keyword">struct </span>_request {

  <span class="keywordtype">size_t</span> sql_len;
  <span class="keywordtype">char</span> reserved[8];
  <span class="keywordtype">char</span> *sql;
} request_t;

<span class="keyword">static</span> request_t _r;

<span class="keyword">typedef</span> _Packed <span class="keyword">struct </span>_reply {

  <span class="keywordtype">int</span> sqlcod;
  <span class="keywordtype">char</span> reserved[12];
} reply_t;

<span class="keywordtype">void</span> gen_uuid(<span class="keywordtype">char</span> *uuid);

<span class="keywordtype">int</span> get_job_ccsid();

<span class="keywordtype">void</span>
utf8_2_ebcdic (
               <span class="keyword">const</span> <span class="keywordtype">char</span> *source,
               <span class="keywordtype">size_t</span> source_length,
               <span class="keywordtype">char</span> *dest
               );

<span class="keywordtype">void</span> enq_request(
                 _SYSPTR q,
                 <span class="keyword">const</span> <span class="keywordtype">char</span> *key,
                 <span class="keyword">const</span> <span class="keywordtype">char</span> *sql
                 );

<span class="keywordtype">int</span> deq_reply(_SYSPTR q, <span class="keyword">const</span> <span class="keywordtype">char</span>* key);

<span class="keywordtype">int</span> resolve_queues(
                   _SYSPTR *request_q,
                   _SYSPTR *reply_q
                   );

<span class="comment">/*</span>
<span class="comment"> * implements isqlsvr.sendRequest()</span>
<span class="comment"> *</span>
<span class="comment"> * - resolve request q</span>
<span class="comment"> * - resolve reply q</span>
<span class="comment"> * - enq SQL</span>
<span class="comment"> */</span>
JNIEXPORT
jint
JNICALL
Java_isqlsvr_sendRequest (
                          JNIEnv *env,
                          jclass jthis,
                          jstring jsql
                          ) {

  <span class="keywordtype">int</span> r = 0;
  <span class="keywordtype">int</span> sqlcod = 0;
  jclass class_exception;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *utf8_sql = NULL;
  <span class="keywordtype">char</span> *sql = NULL;
  jboolean is_copy = JNI_FALSE;
  <span class="keywordtype">size_t</span> len = 0;
  <span class="keywordtype">char</span> uuid[16] = {0};

  _SYSPTR request_q = NULL;
  _SYSPTR reply_q = NULL;

  <span class="comment">/* resolve qs */</span>
  <span class="keywordflow">if</span>(resolve_queues(&amp;request_q, &amp;reply_q) != 0) {

    <span class="comment">// raise exception and return</span>
<span class="preprocessor"># pragma convert(819)</span>
<span class="preprocessor"></span>    class_exception = (*env)-&gt;FindClass(env, <span class="stringliteral">"java/lang/Exception"</span>);
<span class="preprocessor"># pragma convert(0)</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span>(class_exception != 0)
      (*env)-&gt;ThrowNew(env,
                       class_exception,
                       <span class="stringliteral">"Failed to resolve user queues"</span>
                       );
    <span class="keywordflow">return</span>;
  }

  <span class="comment">// convert sql to ebcdic</span>
  utf8_sql = (*env)-&gt;GetStringUTFChars(env, jsql, &amp;is_copy);
  len = (*env)-&gt;GetStringUTFLength(env, jsql);
  sql = malloc(len * 2 + 1);
  utf8_2_ebcdic(utf8_sql, len, sql);
  (*env)-&gt;ReleaseStringUTFChars(env, jsql, utf8_sql);

  <span class="comment">// enq request q</span>
  gen_uuid(uuid);
  enq_request(request_q, uuid, sql);

  <span class="comment">// deq reply q</span>
  sqlcod = deq_reply(reply_q, uuid);

  free(sql);
  <span class="keywordflow">return</span> sqlcod;
}

<span class="keywordtype">void</span> gen_uuid(<span class="keywordtype">char</span> *uuid) {

  _UUID_Template_T tmpl;

  memset(&amp;tmpl, 0, 32);
  tmpl.bytesProv = 32;
  _GENUUID(&amp;tmpl);

  memcpy(uuid, tmpl.uuid, 16);
}

<span class="keywordtype">int</span> get_job_ccsid() {

  <span class="keywordtype">int</span> ccsid = 0;
  Qwc_JOBI0400_t jobi;
  Qus_EC_t *ec = NULL;

  ec = (Qus_EC_t*)malloc(ECLEN);
  memset(ec, 0, ECLEN);
  ec-&gt;Bytes_Provided = ECLEN;
  jobi.Bytes_Avail = <span class="keyword">sizeof</span>(Qwc_JOBI0400_t);
  QUSRJOBI(
           &amp;jobi,
           <span class="keyword">sizeof</span>(Qwc_JOBI0400_t),
           <span class="stringliteral">"JOBI0400"</span>,
           <span class="stringliteral">"*                         "</span>,
           <span class="stringliteral">"                "</span>,
           ec
           );
  <span class="keywordflow">if</span>(ec-&gt;Bytes_Available != 0)
    ccsid = 37; <span class="comment">// ascii ccsid</span>
  <span class="keywordflow">else</span>
    ccsid = jobi.Coded_Char_Set_ID;

  free(ec);
  <span class="keywordflow">return</span> ccsid;
}

<span class="keywordtype">void</span>
utf8_2_ebcdic (
               <span class="keyword">const</span> <span class="keywordtype">char</span> *source,
               <span class="keywordtype">size_t</span> source_length,
               <span class="keywordtype">char</span> *dest
               ) {

  <span class="keywordtype">size_t</span> result_length = source_length * 2;
  <span class="keywordtype">char</span> host_ccsid[32 + 1] = {0};
  iconv_t cvt;

  sprintf(host_ccsid,
          <span class="stringliteral">"IBMCCSID%05d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"</span>,
          get_job_ccsid());
  cvt = iconv_open(host_ccsid, UTF8_CCSID);

  iconv(cvt,
        &amp;source,
        &amp;source_length,
        &amp;dest,
        &amp;result_length
        );

  iconv_close(cvt);
}

<span class="keywordtype">void</span> enq_request(
                 _SYSPTR q,
                 <span class="keyword">const</span> <span class="keywordtype">char</span> *key,
                 <span class="keywordtype">char</span> *sql
                 ) {

  _ENQ_Msg_Prefix_T *prefix;
  request_t *request = &amp;_r;
  <span class="keywordtype">char</span> text[16] = {0};

  prefix = (_ENQ_Msg_Prefix_T*)malloc(ENQ_PREFIX_LEN);
  memset(prefix, 0, ENQ_PREFIX_LEN);
  prefix-&gt;Msg_Len = TEXTLEN;
  memcpy(prefix-&gt;Msg, key, KEYLEN);

  request-&gt;sql_len = strlen(sql);
  request-&gt;sql = sql;
  memcpy(text, &amp;request, 16);

  _ENQ(&amp;q, prefix, text);

  free(prefix);
}

<span class="keywordtype">int</span> deq_reply(_SYSPTR q, <span class="keyword">const</span> <span class="keywordtype">char</span>* key) {

  deq_prefix_t prefix;
  reply_t reply;

  prefix.acc_state_mod[0] = 0xF8; <span class="comment">// 1111,1000; key realtion=EQ, deq infinitely</span>
  memcpy(prefix.key_in, key, KEYLEN);

  _DEQWAIT(&amp;prefix, &amp;reply, &amp;q);

  <span class="keywordflow">return</span> reply.sqlcod;
}

<span class="keywordtype">int</span> resolve_queues(
                   _SYSPTR *request_q,
                   _SYSPTR *reply_q
                   ) {

  <span class="keywordtype">int</span> resolved = -1;
  <span class="keyword">volatile</span> <span class="keywordtype">int</span> ca = 0;

<span class="preprocessor"># pragma exception_handler(end, ca, _C1_OBJECT_NOT_FOUND, \</span>
<span class="preprocessor">                           _C2_ALL, _CTLA_HANDLE)</span>
<span class="preprocessor"></span>  *request_q = rslvsp(0x0A02, REQUEST_Q, <span class="stringliteral">""</span>, 0x0000);
  *reply_q = rslvsp(0x0A02, REPLY_Q, <span class="stringliteral">""</span>, 0x0000);
  resolved = 0;

<span class="preprocessor"># pragma disable_handler</span>
<span class="preprocessor"></span>
 end:
  <span class="keywordflow">return</span> resolved;
}

<span class="comment">/* eof - isqlsvr.c */</span>
</pre></div><p>
编译Service Program ISQLSVR <div class="fragment"><pre class="fragment"><span class="comment">/* 编译module ISQLSVR */</span>
CRTCMOD MODULE(LSBIN/ISQLSVR) SRCSTMF(isqlsvr.c) INCDIR('.')

<span class="comment">/* 创建*SRVPGM ISQLSVR */</span>
CRTSRVPGM LSBIN/ISQLSVR MODULE(*LIBL/ISQLSVR) EXPORT(*ALL)
</pre></div><h3><a class="anchor" name="ss_using_q_usage_demo_java_3">
6.6.3. 执行Java类isql</a></h3>
在i5/OS上运行Java程序，可以使用CL命令JAVA或RUNJVA，或QShell命令java。 下面首先提交ISQLSVR2作业，然后执行Java类isql。 <div class="fragment"><pre class="fragment"><span class="comment">/* clear physical file PF16 */</span>
CLRPFM PF16

<span class="comment">/* submit job ISQLSVR2 */</span>
SBMJOB CMD(CALL ISQLSVR2)

<span class="comment">/* 修改当前路径为isql.class, isqlsvr.class所在的IFS目录，如 */</span>
CHGCURDIR <span class="stringliteral">'/home/ljl/tmp'</span>

<span class="comment">/* run java class isql */</span>
JAVA CLASS(isql) PARM('delete from pf16')
<span class="comment">/*</span>
<span class="comment">结果</span>
<span class="comment">SQL statement succeeded with SQLCOD 100</span>
<span class="comment">Java program completed</span>
<span class="comment">*/</span>

JAVA CLASS(isql) PARM('insert into pf16 values(''20081212'', ''冬天'',''Friday'')')
<span class="comment">/*</span>
<span class="comment">结果</span>
<span class="comment">SQL statement succeeded with SQLCOD 0</span>
<span class="comment">Java program completed</span>
<span class="comment">*/</span>

<span class="comment">/* check physical file PF16 */</span>
RUNQRY *N PF16
<span class="comment">/*</span>
<span class="comment">结果</span>
<span class="comment">Line   ....+....1....+....2....+....3....+.</span>
<span class="comment">       RQ        NAME              REMARK  </span>
<span class="comment">000001 20081212  冬天              Friday  </span>
<span class="comment"> ********  End of report  ********   </span>
<span class="comment">*/</span>
</pre></div><h2><a class="anchor" name="sect_using_q_appendices">
附录</a></h2>
<b>附录列表</b> <br>
<ul>
<li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_1">Appendix 1. Enqueue USRQ Q11 for 1000 times</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_3">Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_4">Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_5">Appendix 5 A Joblog Saver Program</a></li><li><a class="el" href="page_using_q_cn.html#ss_using_q_appendix_6">Appendix 6 参考信息</a></li></ul>
<h3><a class="anchor" name="ss_using_q_appendix_1">
Appendix 1. Enqueue USRQ Q11 for 1000 times</a></h3>
使用API QUSCRTUQ创建USRQ Q11，类型为FIFO，entry长度64 <div class="fragment"><pre class="fragment">CALL PGM(QUSCRTUQ) PARM(
  'Q11       LSBIN'        <span class="comment">/* queue name: LSBIN/Q11 */</span>
  'USRQ'                   <span class="comment">/* extended attribute    */</span>
  'F'                      <span class="comment">/* queue type: keyed     */</span>
  X'00000000'              <span class="comment">/* key length: 0         */</span>
  X'00000040'              <span class="comment">/* max entry length: 64  */</span>
  X'00010000'              <span class="comment">/* initial number of messages: 65536  */</span>
  X'00001000'              <span class="comment">/* extend number of messages: 4096    */</span>
  '*EXCLUDE'               <span class="comment">/* public authority                   */</span>
  'FIFO USRQ: entry length = 64'  <span class="comment">/* text description            */</span>
)
</pre></div><p>
入列 USRQ Q11的MI程序<a href="src/enq11.mi">enq11.mi</a> <div class="fragment"><pre class="fragment">
dcl sysptr q auto                ; 
dcl dd message-prefix char(4) auto;
  dcl dd prefix-msglen bin(4) def(message-prefix) pos(1);

dcl dd message <span class="keywordtype">char</span>(64) auto init("is usrq more faster?") ;
dcl spcptr .message auto init(message) ; 

entry * ext;

dcl dd index bin(4) auto init(0) ; 

        cpybla rslv-option-obj-type, x"0A02";
        cpyblap rslv-option-obj-name, "Q11", " ";
        rslvsp q, rslv-option-<span class="keywordtype">short</span>, *, x'0000';

        <span class="comment">/* enq */</span>
        cpynv prefix-msglen, 64;
        cpynv index, 0          ; 
enq-loop:
        addn(s) index, 1        ;
        cmpnv(b) index, 1000 / hi(end-loop) ; 
        enq q, message-prefix, .message;

        b enq-loop              ; 
end-loop:       

        rtx *;

%include ptrres.mi              ; 

pend;

<span class="comment">/* eof - enq11.mi */</span>
</pre></div><p>
ILE RPG程序<a href="src/renq11.rpgle">renq11.rpgle</a> 负责调用program enq11完成1000次入列操作，并统计用时: <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file renq11.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * call PGM ENQ11 for 1000 times</span>
<span class="comment">      */</span>

     d b               s               z
     d e               s               z
     d ind             s             10i 0
     d dur             s             15p 0

     c                   eval      b = %timestamp()
     c                   call      'ENQ11'
     c                   eval      e = %timestamp()
     c                   eval      dur = %diff(e : b : *ms)

     c     'microseconds'dsply                   dur
     c                   seton                                          lr
     <span class="comment">/* eof - renq11.rpgle */</span>
</pre></div><p>
调用程序RENQ11 10次，执行结果如下: <div class="fragment"><pre class="fragment">DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
DSPLY  microseconds              4000
<span class="comment">/*</span>
<span class="comment">结果:</span>
<span class="comment">10次调用的平均结果为4000 micro-seconds(0.004s)</span>
<span class="comment">*/</span>
</pre></div><p>
使用 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a>的 <a href="../q/page_dspqd.html">DSPQD</a>:命令查看USRQ Q11 <div class="fragment"><pre class="fragment">DSPQD Q(LSBIN/Q11) QTYPE(*USRQ)
</pre></div> <div class="fragment"><pre class="fragment"><span class="comment">/* DSPQD命令的部分输出 */</span>
Current maximum number of             
  messages . . . . . . . . . :   65536
Current number of messages            
  enqueued . . . . . . . . . :   10000
Extension value  . . . . . . :   4096 
Key length . . . . . . . . . :   0    
Maximum size of message to be         
  enqueued . . . . . . . . . :   64   
Maximum number of extends  . :   35
Current number of extends  . :   0   
Initial number of messages . :   65536
</pre></div> 可以看到当进行10次对RENQ11的调用后，USRQ Q11上当前有10000条message(Current number of messages enqueued)， 未发生过扩展(Current number of extends)。<h3><a class="anchor" name="ss_using_q_appendix_2">
Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a></h3>
使用CL命令CRTDTAQ创建DTAQ Q12，类型为FIFO，entry长度64: <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/Q12)       <span class="comment">/* queue name         */</span>
        MAXLEN(64)            <span class="comment">/* entry length: 64   */</span>
        SEQ(*FIFO)            <span class="comment">/* queue type: keyed  */</span>
        SIZE(*MAX16MB 65536)  <span class="comment">/* initial number of messages: 65536 */</span>
        TEXT('FIFO DTAQ: entry length=64')
</pre></div><p>
ILE RPG程序<a href="src/renq12.rpgle">renq12.rpgle</a> 负责完成1000次入列 DTAQ Q12的操作，并统计用时: <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file renq12.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * enqueue DTAQ Q12 for 1000 times</span>
<span class="comment">      */</span>

     d b               s               z
     d e               s               z
     d ind             s             10i 0
     d dur             s             15p 0

     c                   eval      b = %timestamp()
     c                   for       ind = 1 to 1000  by 1
     c                   call      'QSNDDTAQ'
     c                   parm      'Q12'         qname            10
     c                   parm      'LSBIN'       qlib             10
     c                   parm      64            entlen            5 0
     c                   parm      *all'1'       ent              64
     c                   endfor
     c                   eval      e = %timestamp()
     c                   eval      dur = %diff(e : b : *ms)

     c     'microseconds'dsply                   dur
     c                   seton                                          lr
     <span class="comment">/* eof */</span>
</pre></div><p>
调用程序RENQ12 10次，执行结果如下: <div class="fragment"><pre class="fragment">DSPLY  microseconds             17000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
DSPLY  microseconds             14000
DSPLY  microseconds             15000
DSPLY  microseconds             15000
<span class="comment">/*</span>
<span class="comment">结果：</span>
<span class="comment">10次调用的平均结果为15100 micro-seconds(0.0151s)</span>
<span class="comment">*/</span>
</pre></div><h3><a class="anchor" name="ss_using_q_appendix_3">
Appendix 3. Enqueue DTAQ Q12(journaled) for 1000 times</a></h3>
使用API QCLRDTAQ清空DTAQ Q12： <div class="fragment"><pre class="fragment">CALL PGM(QCLRDTAQ) PARM('Q12' 'LSBIN')
</pre></div><p>
对DTAQ Q12启用日志： <div class="fragment"><pre class="fragment">STRJRNOBJ OBJ(LSBIN/Q12) OBJTYPE(*DTAQ) JRN(LSBIN/JRN01)
</pre></div><p>
调用 <a class="el" href="page_using_q_cn.html#ss_using_q_appendix_2">Appendix 2. Enqueue DTAQ Q12(not journaled) for 1000 times</a> 中的ILE RPG程序RENQ12 10次，执行结果如下: <div class="fragment"><pre class="fragment">DSPLY  microseconds            4066000
DSPLY  microseconds            4019000
DSPLY  microseconds            4145000
DSPLY  microseconds            4018000
DSPLY  microseconds            4007000
DSPLY  microseconds            4206000
DSPLY  microseconds            4031000
DSPLY  microseconds            4042000
DSPLY  microseconds            4023000
DSPLY  microseconds            4042000
<span class="comment">/*</span>
<span class="comment">结果：</span>
<span class="comment">10次调用的平均结果为4059900 micro-seconds(4.0599s)</span>
<span class="comment">*/</span>
</pre></div><h3><a class="anchor" name="ss_using_q_appendix_4">
Appendix 4 Possible Journal Entry Type for Journal Code Q(Data queue operation)</a></h3>
<ul>
<li>QB - Start data queue journaling</li><li>QC - Data queue cleared, no key</li><li>QD - Data queue deleted</li><li>QE - End data queue journaling</li><li>QI - Queue in use at abnormal end</li><li>QJ - Data queue cleared, has key</li><li>QK - Send data queue entry, has key</li><li>QL - Receive data queue entry, has key</li><li>QM - Data queue moved</li><li>QN - Data queue renamed</li><li>QR - Receive data queue entry, no key</li><li>QS - Send data queue entry, no key</li><li>QX - Start of save-while-active for data queue</li><li>QY - Data queue saved</li><li>QZ - Data queue restored</li><li>VE - Internal entry</li><li>VQ - Internal entry</li></ul>
<h3><a class="anchor" name="ss_using_q_appendix_5">
Appendix 5 A Joblog Saver Program</a></h3>
作为对 <a class="el" href="page_using_q_cn.html#ss_using_q_usage_demo_outputq">6.2. Output Queue的Data Queue支持</a> 的补充说明，这里介绍一个 Joblog Saver程序。 该程序将OUTQ QEZJOBLOG中的spooled file实时地存入数据文件，用于在 进行问题分析时备查；同时删除OUTQ中的spooled file，即时地回收 处于OUTQ状态的作业及spooled file自身占用的系统资源。<p>
<b>创建DTAQ</b><br>
 创建DTAQ JOBLOGNTF，类型为FIFO，entry长度128 <div class="fragment"><pre class="fragment">CRTDTAQ DTAQ(LSBIN/JOBLOGNTF) MAXLEN(128) SIZE(*MAX2GB) AUTORCL(*YES) TEXT('i watch joblogs')
</pre></div><p>
<b>准备保存joblog的数据文件JOBLOG</b><br>
 <div class="fragment"><pre class="fragment">CRTPF FILE(LSBIN/JOBLOG) RCDLEN(132) IGCDTA(*YES)
</pre></div><p>
<b>修改OUTQ的DTAQ属性</b><br>
 <div class="fragment"><pre class="fragment">CHGOUTQ OUTQ(QEZJOBLOG) DTAQ(LSBIN/JOBLOGNTF)
</pre></div><p>
<b>Joblog Saver程序</b><br>
 编写ILE RPG程序 <a href="src/savjoblog.rpgle">savjoblog.rpgle</a> <div class="fragment"><pre class="fragment">     <span class="comment">/*</span>
<span class="comment">      * @file savjoblog.rpgle</span>
<span class="comment">      *</span>
<span class="comment">      * @remark 需要退出时，向DTAQ JOBLOGNTF入列个QUIT</span>
<span class="comment">      *          e.g. CALL PGM(QSNDDTAQ) PARM('JOBLOGNTF'</span>
<span class="comment">      *                 'LSBIN' X'00010F' 'QUIT')</span>
<span class="comment">      *</span>
<span class="comment">      */</span>
     h dftactgrp(*no)

     <span class="comment">/*</span>
<span class="comment">      * dequeue a notification message from DTAQ JOBLOGNTF</span>
<span class="comment">      *</span>
<span class="comment">      * @return *on if okey, *off if notified to quit.</span>
<span class="comment">      */</span>
     d deq_notify      pr              n
     <span class="comment">/*</span>
<span class="comment">      * copy joblog to PF JOBLOG;</span>
<span class="comment">      * delete spooled file.</span>
<span class="comment">      */</span>
     d wrk_with_splf   pr

     <span class="comment">/* Notification information */</span>
     d notify          ds           128    qualified
     d   func_code                   10a
     d   rec_type                     2a
     d   job_id                      26a
     d   splf_name                   10a
     d   splf_num                    10i 0

      /free

          dow deq_notify();
              wrk_with_splf();
          enddo;

          *inlr = *on;
      /end-free

     <span class="comment">/* deq_notify() */</span>
     p deq_notify      b
     <span class="comment">/* prototype of API QRCVDTAQ */</span>
     d qrcvdtaq        pr                  extpgm('QRCVDTAQ')
     d   qname                       10a
     d   qlib                        10a
     d   qentrylen                    5p 0
     d   qentry                     128a
     d   timeout                      5p 0

     d qname           s             10a   inz('JOBLOGNTF')
     d qlib            s             10a   inz('LSBIN')
     d qentrylen       s              5p 0 inz(128)
     d timeout         s              5p 0 inz(-1)
     d quit            c                   'QUIT'

     d deq_notify      pi              n

      /free

          qrcvdtaq( qname
                   : qlib
                   : qentrylen
                   : notify
                   : timeout );

          if %subst(notify.func_code : 1 : 4) = quit;
              return *off;
          endif;

          return *on;
      /end-free
     p deq_notify      e

     p wrk_with_splf   b
     <span class="comment">/* prototype of API QCMDEXC */</span>
     d qcmdexc         pr                  extpgm('QCMDEXC')
     d   cmdstr                     128    options(*varsize)
     d   cmdlen                      15p 5

     d cmd             s            128a
     d len             s             15p 5
     d jid             s             28a

      /free

          jid = %subst(notify.job_id:21:6)
                + '/'
                + %trim(%subst(notify.job_id:11:10))
                + '/'
                + %trim(%subst(notify.job_id: 1:10));

          monitor;

          <span class="comment">// copy spooled file to PF JOBLOG</span>
          cmd = 'CPYSPLF FILE('
                + %trim(notify.splf_name)
                + ') TOFILE(LSBIN/JOBLOG) JOB('
                + %trim(jid)
                + ') SPLNBR('
                + %<span class="keywordtype">char</span>(notify.splf_num)
                + ') MBROPT(*ADD)';
          len = %len(%trim(cmd));
          qcmdexc(cmd : len);

          <span class="comment">// delete spooled file</span>
          cmd = 'DLTSPLF FILE('
                + %trim(notify.splf_name)
                + ') JOB('
                + %trim(jid)
                + ') SPLNBR('
                + %<span class="keywordtype">char</span>(notify.splf_num)
                + ') ';
          len = %len(%trim(cmd));
          qcmdexc(cmd : len);

          on-error;
          endmon;

      /end-free
     p wrk_with_splf   e
     <span class="comment">/* eof */</span>
</pre></div><p>
<b>提交Joblog Saver作业</b><br>
 <div class="fragment"><pre class="fragment">SBMJOB CMD(CALL PGM(LSBIN/SAVJOBLOG)) JOB(JOBLOGSVR)
</pre></div> 当joblog saver作业提交后，在OUTQ QEZJOBLOG上产生的spooled file 被joblog saver自动复制到数据文件JOBLOG，然后被删除。 用于试验，可以故意在OUTQ QEZJOBLOG上制造一个spooled file，如: <div class="fragment"><pre class="fragment"><span class="comment">/* 下面的命令将导致被提交的作业在正常退出后，记录joblog */</span>
SBMJOB CMD(DLYJOB DLY(3)) JOB(MAKEJOBLOG) LOG(*JOBD *JOBD *SECLVL)
</pre></div> 当上面提交的作业退出后，查看文件JOBLOG，将可以看到该作业的JOBLOG信息。 <div class="fragment"><pre class="fragment">  5722SS1 V5R2M0 020719                           Job Log                             810      09/05/19 14:24:35          Page    1
   Job name . . . . . . . . . . :   MAKEJOBLOG      User  . . . . . . :   LJL          Number . . . . . . . . . . . :   254693
   Job description  . . . . . . :   LJL_DAILY       Library . . . . . :   QGPL
 MSGID      TYPE                    SEV  DATE      TIME             FROM PGM     LIBRARY     INST     TO PGM      LIBRARY     INST
 CPF1124    Information             00   09/05/19  14:24:32.615208  QWTPIIPP     QSYS        05D4     *EXT                    *N
                                      Message . . . . :   Job 254693/LJL/MAKEJOBLOG started on 09/05/19 at 14:24:32
                                        in subsystem QBATCH in QSYS. Job entered system on 09/05/19 at 14:24:32.
 CPI1125    Information             00   09/05/19  14:24:32.619792  QWTPCRJA     QSYS        0108     *EXT                    *N
                                      Message . . . . :   Job 254693/LJL/MAKEJOBLOG submitted.
                                      Cause . . . . . :   Job 254693/LJL/MAKEJOBLOG submitted to job queue QBATCH in
                                        QGPL from job 254687/LJL/GREENTEA. Job 254693/LJL/MAKEJOBLOG was started
                                        <span class="keyword">using</span> the Submit Job (SBMJOB) command with the following job attributes:
                                        JOBPTY(5) OUTPTY(5) PRTTXT() RTGDTA(QCMDB) SYSLIBL(QSYS       QSYS2
                                        QHLPSYS    QUSRSYS) CURLIB(LSBIN) INLLIBL(QGPL       QTEMP      LSBIN
                                        LJLCP      ATS        XTXRUN     MN         I5TOOLKIT) LOG(4 00 *SECLVL)
<span class="comment">/* .... ... */</span>
</pre></div><p>
<b>通知joblog saver作业退出</b><br>
 当<a href="src/savjoblog.rpgle">savjoblog.rpgle</a>在DTAQ JOBLOGNTF上 接收一条内容为‘QUIT'的entry时，认为被通知退出。因此通知joblog saver作业退出只需要: <div class="fragment"><pre class="fragment">CALL PGM(QSNDDTAQ) PARM('JOBLOGNTF' 'LSBIN' X'00010F' 'QUIT')
</pre></div><h3><a class="anchor" name="ss_using_q_appendix_6">
Appendix 6 参考信息</a></h3>
<ul>
<li><a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apis/obj1.htm">Object APIs</a></li><li><a href="http://publib.boulder.ibm.com/infocenter/iseries/v5r4/topic/apiref/MIpgmg.htm">Machine interface programming</a></li><li>开源项目<a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> 维护着 <a href="../q/page_dspqd.html">DSPQD</a>，<a href="../q/page_dspqmsg.html">DSPQMSG</a> 等Queue Object工具。 项目文档和相关文章请参考 <a href="http://i5toolkit.sourceforge.net/">项目首页</a>。</li></ul>
<h2><a class="anchor" name="sect_using_q_about_me">
关于作者</a></h2>
自我介绍下呗，我是李君磊，来自天津，一个很讲究生活质量的城市。 严格来说，我是个400新手，到这个OS下面来写东西不过3年多的时间。 不能讲对这个OS喜爱或不喜爱，但有一点是肯定的， 这个OS是精巧复杂的，在许多方面的设计是先进或超前的。<p>
在我维护的开源项目 <a href="http://sourceforge.net/projects/i5toolkit/">i5/OS Programmer's Toolkit</a> 中，多半代码是MI的。 在此，不得不感谢 Mr. Leif Svalgaard，他在 <a href="http://archive.midrange.com/mi400/index.htm">midrange.com</a> 的文章为我学习MI提供了莫大帮助。 还有几个我常去的网站，相信大家也常常去看，比如:<ul>
<li><a href="http://code400.com/">http://code400.com</a></li><li><a href="http://www.mcpressonline.com">www.mcpressonline.com</a></li><li><a href="http://bbs2.chinaunix.net/forumdisplay.php?fid=10">chinaunix的400论坛</a></li></ul>
<p>
我的邮件: <a href="mailto:junleili-cn@users.sourceforge.net">junleili-cn@users.sourceforge.net</a>，欢迎同行们的意见与建议 :) </div>
<hr size="1">

<a href="http://sourceforge.net/donate/index.php?group_id=254578"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> </a>

<address style="text-align: right;"><small>Generated on Tue May 10 19:55:08 2011 for i5/OS Programmer's Toolkit: Articles by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9  </small></address>
</body>
</html>
